// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stratum/hal/lib/common/common.proto

package stratum_hal

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Mode of operation of the stack.
type OperationMode int32

const (
	OperationMode_OPERATION_MODE_UNKNOWN    OperationMode = 0
	OperationMode_OPERATION_MODE_STANDALONE OperationMode = 1
	OperationMode_OPERATION_MODE_COUPLED    OperationMode = 2
	OperationMode_OPERATION_MODE_SIM        OperationMode = 3
)

var OperationMode_name = map[int32]string{
	0: "OPERATION_MODE_UNKNOWN",
	1: "OPERATION_MODE_STANDALONE",
	2: "OPERATION_MODE_COUPLED",
	3: "OPERATION_MODE_SIM",
}

var OperationMode_value = map[string]int32{
	"OPERATION_MODE_UNKNOWN":    0,
	"OPERATION_MODE_STANDALONE": 1,
	"OPERATION_MODE_COUPLED":    2,
	"OPERATION_MODE_SIM":        3,
}

func (x OperationMode) String() string {
	return proto.EnumName(OperationMode_name, int32(x))
}

func (OperationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0}
}

// Tri-state boolean for the case 'false' is not a default.
type TriState int32

const (
	TriState_TRI_STATE_UNKNOWN TriState = 0
	TriState_TRI_STATE_TRUE    TriState = 1
	TriState_TRI_STATE_FALSE   TriState = 2
)

var TriState_name = map[int32]string{
	0: "TRI_STATE_UNKNOWN",
	1: "TRI_STATE_TRUE",
	2: "TRI_STATE_FALSE",
}

var TriState_value = map[string]int32{
	"TRI_STATE_UNKNOWN": 0,
	"TRI_STATE_TRUE":    1,
	"TRI_STATE_FALSE":   2,
}

func (x TriState) String() string {
	return proto.EnumName(TriState_name, int32(x))
}

func (TriState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{1}
}

// Target platforms (aka the type of the switch/chassis).
type Platform int32

const (
	Platform_PLT_UNKNOWN                  Platform = 0
	Platform_PLT_GENERIC_TRIDENT_PLUS     Platform = 1
	Platform_PLT_GENERIC_TRIDENT2         Platform = 2
	Platform_PLT_GENERIC_TOMAHAWK         Platform = 3
	Platform_PLT_GENERIC_TOMAHAWK_PLUS    Platform = 4
	Platform_PLT_GENERIC_TOMAHAWK2        Platform = 5
	Platform_PLT_GENERIC_TOMAHAWK3        Platform = 6
	Platform_PLT_MLNX_SN2700              Platform = 9
	Platform_PLT_P4_SOFT_SWITCH           Platform = 10
	Platform_PLT_NP4_INTEL_N3000          Platform = 13
	Platform_PLT_GENERIC_BAREFOOT_TOFINO  Platform = 14
	Platform_PLT_GENERIC_BAREFOOT_TOFINO2 Platform = 15
)

var Platform_name = map[int32]string{
	0:  "PLT_UNKNOWN",
	1:  "PLT_GENERIC_TRIDENT_PLUS",
	2:  "PLT_GENERIC_TRIDENT2",
	3:  "PLT_GENERIC_TOMAHAWK",
	4:  "PLT_GENERIC_TOMAHAWK_PLUS",
	5:  "PLT_GENERIC_TOMAHAWK2",
	6:  "PLT_GENERIC_TOMAHAWK3",
	9:  "PLT_MLNX_SN2700",
	10: "PLT_P4_SOFT_SWITCH",
	13: "PLT_NP4_INTEL_N3000",
	14: "PLT_GENERIC_BAREFOOT_TOFINO",
	15: "PLT_GENERIC_BAREFOOT_TOFINO2",
}

var Platform_value = map[string]int32{
	"PLT_UNKNOWN":                  0,
	"PLT_GENERIC_TRIDENT_PLUS":     1,
	"PLT_GENERIC_TRIDENT2":         2,
	"PLT_GENERIC_TOMAHAWK":         3,
	"PLT_GENERIC_TOMAHAWK_PLUS":    4,
	"PLT_GENERIC_TOMAHAWK2":        5,
	"PLT_GENERIC_TOMAHAWK3":        6,
	"PLT_MLNX_SN2700":              9,
	"PLT_P4_SOFT_SWITCH":           10,
	"PLT_NP4_INTEL_N3000":          13,
	"PLT_GENERIC_BAREFOOT_TOFINO":  14,
	"PLT_GENERIC_BAREFOOT_TOFINO2": 15,
}

func (x Platform) String() string {
	return proto.EnumName(Platform_name, int32(x))
}

func (Platform) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2}
}

// List of traffic classes (aka class of services).
// Note: The names of the enum cases are important and are used to identify
// QoS queues in gNMI YANG model.
type TrafficClass int32

const (
	TrafficClass_UNDEFINED TrafficClass = 0
	TrafficClass_BE1       TrafficClass = 20
	TrafficClass_AF1       TrafficClass = 21
	TrafficClass_AF2       TrafficClass = 22
	TrafficClass_AF3       TrafficClass = 23
	TrafficClass_AF4       TrafficClass = 24
	TrafficClass_NC1       TrafficClass = 25
	TrafficClass_NC0       TrafficClass = 26
	TrafficClass_BE0       TrafficClass = 27
	TrafficClass_LLQ1      TrafficClass = 29
	TrafficClass_LLQ2      TrafficClass = 30
)

var TrafficClass_name = map[int32]string{
	0:  "UNDEFINED",
	20: "BE1",
	21: "AF1",
	22: "AF2",
	23: "AF3",
	24: "AF4",
	25: "NC1",
	26: "NC0",
	27: "BE0",
	29: "LLQ1",
	30: "LLQ2",
}

var TrafficClass_value = map[string]int32{
	"UNDEFINED": 0,
	"BE1":       20,
	"AF1":       21,
	"AF2":       22,
	"AF3":       23,
	"AF4":       24,
	"NC1":       25,
	"NC0":       26,
	"BE0":       27,
	"LLQ1":      29,
	"LLQ2":      30,
}

func (x TrafficClass) String() string {
	return proto.EnumName(TrafficClass_name, int32(x))
}

func (TrafficClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{3}
}

// FEC operational mode for a singleton port.
type FecMode int32

const (
	FecMode_FEC_MODE_UNKNOWN FecMode = 0
	FecMode_FEC_MODE_ON      FecMode = 1
	FecMode_FEC_MODE_OFF     FecMode = 2
	FecMode_FEC_MODE_AUTO    FecMode = 3
)

var FecMode_name = map[int32]string{
	0: "FEC_MODE_UNKNOWN",
	1: "FEC_MODE_ON",
	2: "FEC_MODE_OFF",
	3: "FEC_MODE_AUTO",
}

var FecMode_value = map[string]int32{
	"FEC_MODE_UNKNOWN": 0,
	"FEC_MODE_ON":      1,
	"FEC_MODE_OFF":     2,
	"FEC_MODE_AUTO":    3,
}

func (x FecMode) String() string {
	return proto.EnumName(FecMode_name, int32(x))
}

func (FecMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{4}
}

// A enum for describing the operational state (aka oper state) of a singleton
// port.
type PortState int32

const (
	// Default/invalid oper state.
	PortState_PORT_STATE_UNKNOWN PortState = 0
	// Port is up, which also means the link that the port is part is up as well.
	PortState_PORT_STATE_UP PortState = 1
	// Port is down, which also means the link that the port is part is down as
	// well.
	PortState_PORT_STATE_DOWN PortState = 2
	// Port has indicated some low-level failures. This is a special case of a
	// port down which is associated with a failure.
	PortState_PORT_STATE_FAILED PortState = 3
)

var PortState_name = map[int32]string{
	0: "PORT_STATE_UNKNOWN",
	1: "PORT_STATE_UP",
	2: "PORT_STATE_DOWN",
	3: "PORT_STATE_FAILED",
}

var PortState_value = map[string]int32{
	"PORT_STATE_UNKNOWN": 0,
	"PORT_STATE_UP":      1,
	"PORT_STATE_DOWN":    2,
	"PORT_STATE_FAILED":  3,
}

func (x PortState) String() string {
	return proto.EnumName(PortState_name, int32(x))
}

func (PortState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{5}
}

// A enum for describing the operational state (aka oper state) of a trunk port.
type TrunkState int32

const (
	// Default/invalid trunk state.
	TrunkState_TRUNK_STATE_UNKNOWN TrunkState = 0
	// Trunk is not empty and at least one member of the trunk is up and
	// forwarding traffic (i.e. not blocked).
	TrunkState_TRUNK_STATE_UP TrunkState = 1
	// Trunk is empty or all the members of the trunk are either down or blocked.
	TrunkState_TRUNK_STATE_DOWN TrunkState = 2
)

var TrunkState_name = map[int32]string{
	0: "TRUNK_STATE_UNKNOWN",
	1: "TRUNK_STATE_UP",
	2: "TRUNK_STATE_DOWN",
}

var TrunkState_value = map[string]int32{
	"TRUNK_STATE_UNKNOWN": 0,
	"TRUNK_STATE_UP":      1,
	"TRUNK_STATE_DOWN":    2,
}

func (x TrunkState) String() string {
	return proto.EnumName(TrunkState_name, int32(x))
}

func (TrunkState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{6}
}

// An enum for describing the traffic block state of a singleton port that is
// part of a trunk.
type TrunkMemberBlockState int32

const (
	// Default/invalid blocking state.
	TrunkMemberBlockState_TRUNK_MEMBER_BLOCK_STATE_UNKNOWN TrunkMemberBlockState = 0
	// The trunk member port may be up and receiving traffic, but egress traffic
	// is blocked. Only control traffic can be egressed from the port (if it is
	// up). A port that is part of a trunk is set to blocked as part of LACP
	// protocol or forcefully by the SDN controller.
	TrunkMemberBlockState_TRUNK_MEMBER_BLOCK_STATE_BLOCKED TrunkMemberBlockState = 1
	// The trunk member port is up and forwarding traffic normally.
	TrunkMemberBlockState_TRUNK_MEMBER_BLOCK_STATE_FORWARDING TrunkMemberBlockState = 2
)

var TrunkMemberBlockState_name = map[int32]string{
	0: "TRUNK_MEMBER_BLOCK_STATE_UNKNOWN",
	1: "TRUNK_MEMBER_BLOCK_STATE_BLOCKED",
	2: "TRUNK_MEMBER_BLOCK_STATE_FORWARDING",
}

var TrunkMemberBlockState_value = map[string]int32{
	"TRUNK_MEMBER_BLOCK_STATE_UNKNOWN":    0,
	"TRUNK_MEMBER_BLOCK_STATE_BLOCKED":    1,
	"TRUNK_MEMBER_BLOCK_STATE_FORWARDING": 2,
}

func (x TrunkMemberBlockState) String() string {
	return proto.EnumName(TrunkMemberBlockState_name, int32(x))
}

func (TrunkMemberBlockState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{7}
}

// A generic enum for describing the loopback state of a singleton port.
type LoopbackState int32

const (
	// Default/invalid state.
	LoopbackState_LOOPBACK_STATE_UNKNOWN LoopbackState = 0
	// Normal/non-loopback state.
	LoopbackState_LOOPBACK_STATE_NONE LoopbackState = 1
	// Loopback packets at the MAC layer of the port.
	LoopbackState_LOOPBACK_STATE_MAC LoopbackState = 2
	// Loopback packets at the PHY layer of the port.
	LoopbackState_LOOPBACK_STATE_PHY LoopbackState = 3
)

var LoopbackState_name = map[int32]string{
	0: "LOOPBACK_STATE_UNKNOWN",
	1: "LOOPBACK_STATE_NONE",
	2: "LOOPBACK_STATE_MAC",
	3: "LOOPBACK_STATE_PHY",
}

var LoopbackState_value = map[string]int32{
	"LOOPBACK_STATE_UNKNOWN": 0,
	"LOOPBACK_STATE_NONE":    1,
	"LOOPBACK_STATE_MAC":     2,
	"LOOPBACK_STATE_PHY":     3,
}

func (x LoopbackState) String() string {
	return proto.EnumName(LoopbackState_name, int32(x))
}

func (LoopbackState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{8}
}

// A generic enum for describing the administrative state (aka admin state) of
// a HW component. Admin state is typically the "intended oper state". After
// the admin state of a HW component changes, we expect the oper state to change
// eventually, however there is no direct dependency. For example, for a port,
// the SDN controller may request the admin state to be enabled. The stack will
// then set the port to be disabled on HW. The port will eventually change its
// state and the linkscan will report the change, in which case we update the
// operational state of the port to be down. In this case, one can expect the
// admin state to be down, while the oper state is still up. It should be noted
// that admin state can also specifiy some logical state which does not fully
// translate to a new oper state. For example, setting a HW component to diag
// mode, may not trasnlate to a new oper state.
type AdminState int32

const (
	// Default/invalid admin state.
	AdminState_ADMIN_STATE_UNKNOWN AdminState = 0
	// HW component is set to be enabled. Setting a HW component (e.g., a port) to
	// enabled translates to some HW operations, as a result of which the oper
	// state of the HW component may change (e.g., in case of a port oper state of
	// the port will eventually become up).
	AdminState_ADMIN_STATE_ENABLED AdminState = 1
	// HW component is set to be disabled. Setting a HW component (e.g., a port)
	// to disabled translates to some HW operations, as a result of which the oper
	// state of the HW component may change (e.g., in case of a port oper state of
	// the port will eventually become down).
	AdminState_ADMIN_STATE_DISABLED AdminState = 2
	// HW component is set to be in diag mode. This typically indicates that the
	// HW component is being used by a diagnostics SW underneath and should not be
	// used like a normal component. Setting a HW component to diag mode will
	// eventually change the HW state of the component.
	// TODO(unknown): This mode is not supported at the moment.
	AdminState_ADMIN_STATE_DIAG AdminState = 3
)

var AdminState_name = map[int32]string{
	0: "ADMIN_STATE_UNKNOWN",
	1: "ADMIN_STATE_ENABLED",
	2: "ADMIN_STATE_DISABLED",
	3: "ADMIN_STATE_DIAG",
}

var AdminState_value = map[string]int32{
	"ADMIN_STATE_UNKNOWN":  0,
	"ADMIN_STATE_ENABLED":  1,
	"ADMIN_STATE_DISABLED": 2,
	"ADMIN_STATE_DIAG":     3,
}

func (x AdminState) String() string {
	return proto.EnumName(AdminState_name, int32(x))
}

func (AdminState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{9}
}

// A generic enum for describing the state of HW components (e.g. QSFP module).
type HwState int32

const (
	// Hardware is present, but details (type/state) are unknown.
	HwState_HW_STATE_UNKNOWN HwState = 0
	// Hardware is present, configured, and operational.
	HwState_HW_STATE_READY HwState = 1
	// Hardware is present, but not yet operational.
	HwState_HW_STATE_PRESENT HwState = 2
	// No hardware is present.
	HwState_HW_STATE_NOT_PRESENT HwState = 3
	// Hardware is present, but not powered on.
	HwState_HW_STATE_OFF HwState = 4
	// Hardware is operational, but configured off.
	HwState_HW_STATE_CONFIGURED_OFF HwState = 5
	// A hardware failure has been detected.
	HwState_HW_STATE_FAILED HwState = 6
	// Hardware is in a diagnostic mode. This typically indicates that the HW
	// component is being used by a diagnostics SW underneath
	HwState_HW_STATE_DIAGNOSTIC HwState = 7
)

var HwState_name = map[int32]string{
	0: "HW_STATE_UNKNOWN",
	1: "HW_STATE_READY",
	2: "HW_STATE_PRESENT",
	3: "HW_STATE_NOT_PRESENT",
	4: "HW_STATE_OFF",
	5: "HW_STATE_CONFIGURED_OFF",
	6: "HW_STATE_FAILED",
	7: "HW_STATE_DIAGNOSTIC",
}

var HwState_value = map[string]int32{
	"HW_STATE_UNKNOWN":        0,
	"HW_STATE_READY":          1,
	"HW_STATE_PRESENT":        2,
	"HW_STATE_NOT_PRESENT":    3,
	"HW_STATE_OFF":            4,
	"HW_STATE_CONFIGURED_OFF": 5,
	"HW_STATE_FAILED":         6,
	"HW_STATE_DIAGNOSTIC":     7,
}

func (x HwState) String() string {
	return proto.EnumName(HwState_name, int32(x))
}

func (HwState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{10}
}

// A generic enum for describing the health state of a HW component, as seen
// by a remote telemetry agent or set by an SDN controller. Note that the health
// state of a component "may" be correlated to its HW state and/or operational
// state, but no inherent correlation is required in general. Also, similar to
// admin state, health state of a component can be set by a remote agent, such
// as an SDN controller. In that case, the health state indicates whether the
// the component is healthy from the controller POV or not.
type HealthState int32

const (
	// Default/invalid health state.
	HealthState_HEALTH_STATE_UNKNOWN HealthState = 0
	// The HW component is healthy. The meaning will be case specific. For the
	// case of ports as seen by the SDN controller, a healthy port means a port
	// which is ready for sending traffic, which boils down to be being up with
	// ND/LLDP reporting correct neighbor.
	HealthState_HEALTH_STATE_GOOD HealthState = 1
	// The HW component is unhealthy. The meaning will be case specific. For the
	// case of ports as seen by the SDN controller, an unhealthy port means a port
	// which is not ready for sending traffic, e.g., it is up by ND/LLDP reports
	// wrong neighbor.
	HealthState_HEALTH_STATE_BAD HealthState = 2
)

var HealthState_name = map[int32]string{
	0: "HEALTH_STATE_UNKNOWN",
	1: "HEALTH_STATE_GOOD",
	2: "HEALTH_STATE_BAD",
}

var HealthState_value = map[string]int32{
	"HEALTH_STATE_UNKNOWN": 0,
	"HEALTH_STATE_GOOD":    1,
	"HEALTH_STATE_BAD":     2,
}

func (x HealthState) String() string {
	return proto.EnumName(HealthState_name, int32(x))
}

func (HealthState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11}
}

// Possible state for LED lights. Possible LedState for any supported LedType
// should be listed here.
type LedState int32

const (
	LedState_LED_STATE_UNKNOWN LedState = 0
	// e.g. after warm boot
	LedState_LED_STATE_OFF           LedState = 1
	LedState_LED_STATE_SOLID         LedState = 2
	LedState_LED_STATE_BLINKING_SLOW LedState = 3
	LedState_LED_STATE_BLINKING_FAST LedState = 4
)

var LedState_name = map[int32]string{
	0: "LED_STATE_UNKNOWN",
	1: "LED_STATE_OFF",
	2: "LED_STATE_SOLID",
	3: "LED_STATE_BLINKING_SLOW",
	4: "LED_STATE_BLINKING_FAST",
}

var LedState_value = map[string]int32{
	"LED_STATE_UNKNOWN":       0,
	"LED_STATE_OFF":           1,
	"LED_STATE_SOLID":         2,
	"LED_STATE_BLINKING_SLOW": 3,
	"LED_STATE_BLINKING_FAST": 4,
}

func (x LedState) String() string {
	return proto.EnumName(LedState_name, int32(x))
}

func (LedState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12}
}

// Different type of LED has different possible color & state conbination and
// different number & control value of control path. LedType determin the value
// for each control path for a given color & state combination.
type LedType int32

const (
	// Unknown led type is regard as an config error.
	LedType_LED_TYPE_UNKNOWN LedType = 0
	// Green/Red non-blinking LEDs (Front Panel, PSU, Fan).
	LedType_LED_TYPE_BICOLOR_FPGA LedType = 1
	// Green/Amber solid/blinking LEDs (10G interfaces)
	LedType_LED_TYPE_BICOLOR_LINK LedType = 2
	// Non-blinking Green LED and Red LED. Used by Markab ports.
	LedType_LED_TYPE_BICOLOR_FPGA_G_R LedType = 3
	// Non-blinking Green/Red and Green/Yellow LEDs. Used by Markab ports.
	LedType_LED_TYPE_TRICOLOR_FPGA_GR_GY LedType = 4
	// Solid/blinking Green/Red and solid Yellow LED. Used by Markab ports.
	LedType_LED_TYPE_TRICOLOR_FPGA_GR_Y LedType = 5
	// Non-blinking Green, Red, and Yellow LEDs. Used by Markab ports.
	LedType_LED_TYPE_TRICOLOR_FPGA_G_R_Y LedType = 6
	// Non-blinking Green, Red LEDs controlled by multiple GPIO pins.
	LedType_LED_TYPE_BICOLOR_GPIO_G_R LedType = 7
)

var LedType_name = map[int32]string{
	0: "LED_TYPE_UNKNOWN",
	1: "LED_TYPE_BICOLOR_FPGA",
	2: "LED_TYPE_BICOLOR_LINK",
	3: "LED_TYPE_BICOLOR_FPGA_G_R",
	4: "LED_TYPE_TRICOLOR_FPGA_GR_GY",
	5: "LED_TYPE_TRICOLOR_FPGA_GR_Y",
	6: "LED_TYPE_TRICOLOR_FPGA_G_R_Y",
	7: "LED_TYPE_BICOLOR_GPIO_G_R",
}

var LedType_value = map[string]int32{
	"LED_TYPE_UNKNOWN":             0,
	"LED_TYPE_BICOLOR_FPGA":        1,
	"LED_TYPE_BICOLOR_LINK":        2,
	"LED_TYPE_BICOLOR_FPGA_G_R":    3,
	"LED_TYPE_TRICOLOR_FPGA_GR_GY": 4,
	"LED_TYPE_TRICOLOR_FPGA_GR_Y":  5,
	"LED_TYPE_TRICOLOR_FPGA_G_R_Y": 6,
	"LED_TYPE_BICOLOR_GPIO_G_R":    7,
}

func (x LedType) String() string {
	return proto.EnumName(LedType_name, int32(x))
}

func (LedType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{13}
}

// Possible color for LED lights. Possible LedColor for any supported LedType
// should be listed here.
type LedColor int32

const (
	LedColor_LED_COLOR_UNKNOWN LedColor = 0
	// e.g. after warm boot
	LedColor_LED_COLOR_GREEN LedColor = 1
	LedColor_LED_COLOR_RED   LedColor = 2
	LedColor_LED_COLOR_AMBER LedColor = 3
)

var LedColor_name = map[int32]string{
	0: "LED_COLOR_UNKNOWN",
	1: "LED_COLOR_GREEN",
	2: "LED_COLOR_RED",
	3: "LED_COLOR_AMBER",
}

var LedColor_value = map[string]int32{
	"LED_COLOR_UNKNOWN": 0,
	"LED_COLOR_GREEN":   1,
	"LED_COLOR_RED":     2,
	"LED_COLOR_AMBER":   3,
}

func (x LedColor) String() string {
	return proto.EnumName(LedColor_name, int32(x))
}

func (LedColor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{14}
}

// Possible physcial types for a frontpanel port.
type PhysicalPortType int32

const (
	PhysicalPortType_PHYSICAL_PORT_TYPE_UNKNOWN     PhysicalPortType = 0
	PhysicalPortType_PHYSICAL_PORT_TYPE_ETHERNET_1G PhysicalPortType = 1
	PhysicalPortType_PHYSICAL_PORT_TYPE_IPASS       PhysicalPortType = 2
	PhysicalPortType_PHYSICAL_PORT_TYPE_SFP_CAGE    PhysicalPortType = 3
	PhysicalPortType_PHYSICAL_PORT_TYPE_QSFP_CAGE   PhysicalPortType = 4
	PhysicalPortType_PHYSICAL_PORT_TYPE_LP_CAGE     PhysicalPortType = 5
	PhysicalPortType_PHYSICAL_PORT_TYPE_CFP_CAGE    PhysicalPortType = 6
	PhysicalPortType_PHYSICAL_PORT_TYPE_BACKPLANE   PhysicalPortType = 7
	PhysicalPortType_PHYSICAL_PORT_TYPE_DWDM        PhysicalPortType = 8
)

var PhysicalPortType_name = map[int32]string{
	0: "PHYSICAL_PORT_TYPE_UNKNOWN",
	1: "PHYSICAL_PORT_TYPE_ETHERNET_1G",
	2: "PHYSICAL_PORT_TYPE_IPASS",
	3: "PHYSICAL_PORT_TYPE_SFP_CAGE",
	4: "PHYSICAL_PORT_TYPE_QSFP_CAGE",
	5: "PHYSICAL_PORT_TYPE_LP_CAGE",
	6: "PHYSICAL_PORT_TYPE_CFP_CAGE",
	7: "PHYSICAL_PORT_TYPE_BACKPLANE",
	8: "PHYSICAL_PORT_TYPE_DWDM",
}

var PhysicalPortType_value = map[string]int32{
	"PHYSICAL_PORT_TYPE_UNKNOWN":     0,
	"PHYSICAL_PORT_TYPE_ETHERNET_1G": 1,
	"PHYSICAL_PORT_TYPE_IPASS":       2,
	"PHYSICAL_PORT_TYPE_SFP_CAGE":    3,
	"PHYSICAL_PORT_TYPE_QSFP_CAGE":   4,
	"PHYSICAL_PORT_TYPE_LP_CAGE":     5,
	"PHYSICAL_PORT_TYPE_CFP_CAGE":    6,
	"PHYSICAL_PORT_TYPE_BACKPLANE":   7,
	"PHYSICAL_PORT_TYPE_DWDM":        8,
}

func (x PhysicalPortType) String() string {
	return proto.EnumName(PhysicalPortType_name, int32(x))
}

func (PhysicalPortType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{15}
}

// The media type for a frontpanel port.
type MediaType int32

const (
	MediaType_MEDIA_TYPE_UNKNOWN     MediaType = 0
	MediaType_MEDIA_TYPE_QSFP_SR4    MediaType = 1
	MediaType_MEDIA_TYPE_QSFP_LR4    MediaType = 2
	MediaType_MEDIA_TYPE_QSFP_COPPER MediaType = 3
	MediaType_MEDIA_TYPE_SFP         MediaType = 5
	MediaType_MEDIA_TYPE_QSFP_PSM4   MediaType = 6
	MediaType_MEDIA_TYPE_CFP_LR4     MediaType = 7
	MediaType_MEDIA_TYPE_CFP_COPPER  MediaType = 8
	MediaType_MEDIA_TYPE_BP_COPPER   MediaType = 9
	MediaType_MEDIA_TYPE_QSFP_CSR4   MediaType = 11
	MediaType_MEDIA_TYPE_QSFP_CLR4   MediaType = 12
	MediaType_MEDIA_TYPE_QSFP_CCR4   MediaType = 14
)

var MediaType_name = map[int32]string{
	0:  "MEDIA_TYPE_UNKNOWN",
	1:  "MEDIA_TYPE_QSFP_SR4",
	2:  "MEDIA_TYPE_QSFP_LR4",
	3:  "MEDIA_TYPE_QSFP_COPPER",
	5:  "MEDIA_TYPE_SFP",
	6:  "MEDIA_TYPE_QSFP_PSM4",
	7:  "MEDIA_TYPE_CFP_LR4",
	8:  "MEDIA_TYPE_CFP_COPPER",
	9:  "MEDIA_TYPE_BP_COPPER",
	11: "MEDIA_TYPE_QSFP_CSR4",
	12: "MEDIA_TYPE_QSFP_CLR4",
	14: "MEDIA_TYPE_QSFP_CCR4",
}

var MediaType_value = map[string]int32{
	"MEDIA_TYPE_UNKNOWN":     0,
	"MEDIA_TYPE_QSFP_SR4":    1,
	"MEDIA_TYPE_QSFP_LR4":    2,
	"MEDIA_TYPE_QSFP_COPPER": 3,
	"MEDIA_TYPE_SFP":         5,
	"MEDIA_TYPE_QSFP_PSM4":   6,
	"MEDIA_TYPE_CFP_LR4":     7,
	"MEDIA_TYPE_CFP_COPPER":  8,
	"MEDIA_TYPE_BP_COPPER":   9,
	"MEDIA_TYPE_QSFP_CSR4":   11,
	"MEDIA_TYPE_QSFP_CLR4":   12,
	"MEDIA_TYPE_QSFP_CCR4":   14,
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{16}
}

// TODO(unknown): revise these enum as needed per ASIC integration
//       currently maps to sff_sfp_type_t defined in sff.h
type SfpType int32

const (
	SfpType_SFP_TYPE_UNKNOWN   SfpType = 0
	SfpType_SFP_TYPE_SFP       SfpType = 1
	SfpType_SFP_TYPE_QSFP      SfpType = 2
	SfpType_SFP_TYPE_QSFP_PLUS SfpType = 3
	SfpType_SFP_TYPE_QSFP28    SfpType = 4
	SfpType_SFP_TYPE_SFP28     SfpType = 5
)

var SfpType_name = map[int32]string{
	0: "SFP_TYPE_UNKNOWN",
	1: "SFP_TYPE_SFP",
	2: "SFP_TYPE_QSFP",
	3: "SFP_TYPE_QSFP_PLUS",
	4: "SFP_TYPE_QSFP28",
	5: "SFP_TYPE_SFP28",
}

var SfpType_value = map[string]int32{
	"SFP_TYPE_UNKNOWN":   0,
	"SFP_TYPE_SFP":       1,
	"SFP_TYPE_QSFP":      2,
	"SFP_TYPE_QSFP_PLUS": 3,
	"SFP_TYPE_QSFP28":    4,
	"SFP_TYPE_SFP28":     5,
}

func (x SfpType) String() string {
	return proto.EnumName(SfpType_name, int32(x))
}

func (SfpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{17}
}

// TODO(unknown): revise these enum as needed per ASIC integration
//       currently maps to sff_module_type_t defined in sff.h
type SfpModuleType int32

const (
	SfpModuleType_SFP_MODULE_TYPE_UNKNOWN       SfpModuleType = 0
	SfpModuleType_SFP_MODULE_TYPE_100G_BASE_CR4 SfpModuleType = 1
	SfpModuleType_SFP_MODULE_TYPE_10G_BASE_CR   SfpModuleType = 2
	SfpModuleType_SFP_MODULE_TYPE_1G_BASE_SX    SfpModuleType = 3
)

var SfpModuleType_name = map[int32]string{
	0: "SFP_MODULE_TYPE_UNKNOWN",
	1: "SFP_MODULE_TYPE_100G_BASE_CR4",
	2: "SFP_MODULE_TYPE_10G_BASE_CR",
	3: "SFP_MODULE_TYPE_1G_BASE_SX",
}

var SfpModuleType_value = map[string]int32{
	"SFP_MODULE_TYPE_UNKNOWN":       0,
	"SFP_MODULE_TYPE_100G_BASE_CR4": 1,
	"SFP_MODULE_TYPE_10G_BASE_CR":   2,
	"SFP_MODULE_TYPE_1G_BASE_SX":    3,
}

func (x SfpModuleType) String() string {
	return proto.EnumName(SfpModuleType_name, int32(x))
}

func (SfpModuleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{18}
}

// Possible directions for a fan module.
// currently maps to onlp_fan_info_t defined in fan.h
type FanDir int32

const (
	FanDir_FAN_DIR_UNKNOWN FanDir = 0
	FanDir_FAN_DIR_B2F     FanDir = 1
	FanDir_FAN_DIR_F2B     FanDir = 2
)

var FanDir_name = map[int32]string{
	0: "FAN_DIR_UNKNOWN",
	1: "FAN_DIR_B2F",
	2: "FAN_DIR_F2B",
}

var FanDir_value = map[string]int32{
	"FAN_DIR_UNKNOWN": 0,
	"FAN_DIR_B2F":     1,
	"FAN_DIR_F2B":     2,
}

func (x FanDir) String() string {
	return proto.EnumName(FanDir_name, int32(x))
}

func (FanDir) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{19}
}

// Possible types for a PSU.
// currently maps to onlp_psu_type_t defined in psu.h
type PsuType int32

const (
	PsuType_PSU_TYPE_UNKNOWN PsuType = 0
	PsuType_PSU_TYPE_AC      PsuType = 1
	PsuType_PSU_TYPE_DC12    PsuType = 2
	PsuType_PSU_TYPE_DC48    PsuType = 3
)

var PsuType_name = map[int32]string{
	0: "PSU_TYPE_UNKNOWN",
	1: "PSU_TYPE_AC",
	2: "PSU_TYPE_DC12",
	3: "PSU_TYPE_DC48",
}

var PsuType_value = map[string]int32{
	"PSU_TYPE_UNKNOWN": 0,
	"PSU_TYPE_AC":      1,
	"PSU_TYPE_DC12":    2,
	"PSU_TYPE_DC48":    3,
}

func (x PsuType) String() string {
	return proto.EnumName(PsuType_name, int32(x))
}

func (PsuType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{20}
}

// Possible modes for a LED module.
// currently maps to onlp_led_info_t defined in led.h
type LedMode int32

const (
	LedMode_LED_MODE_UNKNOWN         LedMode = 0
	LedMode_LED_MODE_OFF             LedMode = 1
	LedMode_LED_MODE_AUTO            LedMode = 2
	LedMode_LED_MODE_AUTO_BLINKING   LedMode = 3
	LedMode_LED_MODE_CHAR            LedMode = 4
	LedMode_LED_MODE_RED             LedMode = 5
	LedMode_LED_MODE_RED_BLINKING    LedMode = 6
	LedMode_LED_MODE_ORANGE          LedMode = 7
	LedMode_LED_MODE_ORANGE_BLINKING LedMode = 8
	LedMode_LED_MODE_YELLOW          LedMode = 9
	LedMode_LED_MODE_YELLOW_BLINKING LedMode = 10
	LedMode_LED_MODE_GREEN           LedMode = 11
	LedMode_LED_MODE_GREEN_BLINKING  LedMode = 12
	LedMode_LED_MODE_BLUE            LedMode = 13
	LedMode_LED_MODE_BLUE_BLINKING   LedMode = 14
	LedMode_LED_MODE_PURPLE          LedMode = 15
	LedMode_LED_MODE_PURPLE_BLINKING LedMode = 16
)

var LedMode_name = map[int32]string{
	0:  "LED_MODE_UNKNOWN",
	1:  "LED_MODE_OFF",
	2:  "LED_MODE_AUTO",
	3:  "LED_MODE_AUTO_BLINKING",
	4:  "LED_MODE_CHAR",
	5:  "LED_MODE_RED",
	6:  "LED_MODE_RED_BLINKING",
	7:  "LED_MODE_ORANGE",
	8:  "LED_MODE_ORANGE_BLINKING",
	9:  "LED_MODE_YELLOW",
	10: "LED_MODE_YELLOW_BLINKING",
	11: "LED_MODE_GREEN",
	12: "LED_MODE_GREEN_BLINKING",
	13: "LED_MODE_BLUE",
	14: "LED_MODE_BLUE_BLINKING",
	15: "LED_MODE_PURPLE",
	16: "LED_MODE_PURPLE_BLINKING",
}

var LedMode_value = map[string]int32{
	"LED_MODE_UNKNOWN":         0,
	"LED_MODE_OFF":             1,
	"LED_MODE_AUTO":            2,
	"LED_MODE_AUTO_BLINKING":   3,
	"LED_MODE_CHAR":            4,
	"LED_MODE_RED":             5,
	"LED_MODE_RED_BLINKING":    6,
	"LED_MODE_ORANGE":          7,
	"LED_MODE_ORANGE_BLINKING": 8,
	"LED_MODE_YELLOW":          9,
	"LED_MODE_YELLOW_BLINKING": 10,
	"LED_MODE_GREEN":           11,
	"LED_MODE_GREEN_BLINKING":  12,
	"LED_MODE_BLUE":            13,
	"LED_MODE_BLUE_BLINKING":   14,
	"LED_MODE_PURPLE":          15,
	"LED_MODE_PURPLE_BLINKING": 16,
}

func (x LedMode) String() string {
	return proto.EnumName(LedMode_name, int32(x))
}

func (LedMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{21}
}

type ChassisConfigParams_TuntapConfig_Mode int32

const (
	ChassisConfigParams_TuntapConfig_UNKNOWN      ChassisConfigParams_TuntapConfig_Mode = 0
	ChassisConfigParams_TuntapConfig_DISABLED     ChassisConfigParams_TuntapConfig_Mode = 1
	ChassisConfigParams_TuntapConfig_BOOTSTRAP    ChassisConfigParams_TuntapConfig_Mode = 2
	ChassisConfigParams_TuntapConfig_LOAD_BALANCE ChassisConfigParams_TuntapConfig_Mode = 3
)

var ChassisConfigParams_TuntapConfig_Mode_name = map[int32]string{
	0: "UNKNOWN",
	1: "DISABLED",
	2: "BOOTSTRAP",
	3: "LOAD_BALANCE",
}

var ChassisConfigParams_TuntapConfig_Mode_value = map[string]int32{
	"UNKNOWN":      0,
	"DISABLED":     1,
	"BOOTSTRAP":    2,
	"LOAD_BALANCE": 3,
}

func (x ChassisConfigParams_TuntapConfig_Mode) String() string {
	return proto.EnumName(ChassisConfigParams_TuntapConfig_Mode_name, int32(x))
}

func (ChassisConfigParams_TuntapConfig_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 4, 0}
}

// Scheduling mode.
type NodeConfigParams_QosConfig_SchedulingMode int32

const (
	NodeConfigParams_QosConfig_QOS_SCHED_UNKNOWN NodeConfigParams_QosConfig_SchedulingMode = 0
	NodeConfigParams_QosConfig_QOS_SCHED_SP      NodeConfigParams_QosConfig_SchedulingMode = 1
	NodeConfigParams_QosConfig_QOS_SCHED_RR      NodeConfigParams_QosConfig_SchedulingMode = 2
	NodeConfigParams_QosConfig_QOS_SCHED_WRR     NodeConfigParams_QosConfig_SchedulingMode = 3
	NodeConfigParams_QosConfig_QOS_SCHED_WDRR    NodeConfigParams_QosConfig_SchedulingMode = 4
)

var NodeConfigParams_QosConfig_SchedulingMode_name = map[int32]string{
	0: "QOS_SCHED_UNKNOWN",
	1: "QOS_SCHED_SP",
	2: "QOS_SCHED_RR",
	3: "QOS_SCHED_WRR",
	4: "QOS_SCHED_WDRR",
}

var NodeConfigParams_QosConfig_SchedulingMode_value = map[string]int32{
	"QOS_SCHED_UNKNOWN": 0,
	"QOS_SCHED_SP":      1,
	"QOS_SCHED_RR":      2,
	"QOS_SCHED_WRR":     3,
	"QOS_SCHED_WDRR":    4,
}

func (x NodeConfigParams_QosConfig_SchedulingMode) String() string {
	return proto.EnumName(NodeConfigParams_QosConfig_SchedulingMode_name, int32(x))
}

func (NodeConfigParams_QosConfig_SchedulingMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 0}
}

// Modulation type for ports.
type PortConfigParams_ModulationType int32

const (
	PortConfigParams_PORT_MODULATION_UNKNOWN PortConfigParams_ModulationType = 0
	PortConfigParams_PORT_MODULATION_NRZ     PortConfigParams_ModulationType = 1
	PortConfigParams_PORT_MODULATION_PAM4    PortConfigParams_ModulationType = 2
)

var PortConfigParams_ModulationType_name = map[int32]string{
	0: "PORT_MODULATION_UNKNOWN",
	1: "PORT_MODULATION_NRZ",
	2: "PORT_MODULATION_PAM4",
}

var PortConfigParams_ModulationType_value = map[string]int32{
	"PORT_MODULATION_UNKNOWN": 0,
	"PORT_MODULATION_NRZ":     1,
	"PORT_MODULATION_PAM4":    2,
}

func (x PortConfigParams_ModulationType) String() string {
	return proto.EnumName(PortConfigParams_ModulationType_name, int32(x))
}

func (PortConfigParams_ModulationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{4, 0}
}

type TrunkPort_TrunkType int32

const (
	TrunkPort_UNKNOWN_TRUNK TrunkPort_TrunkType = 0
	TrunkPort_STATIC_TRUNK  TrunkPort_TrunkType = 1
	TrunkPort_LACP_TRUNK    TrunkPort_TrunkType = 2
)

var TrunkPort_TrunkType_name = map[int32]string{
	0: "UNKNOWN_TRUNK",
	1: "STATIC_TRUNK",
	2: "LACP_TRUNK",
}

var TrunkPort_TrunkType_value = map[string]int32{
	"UNKNOWN_TRUNK": 0,
	"STATIC_TRUNK":  1,
	"LACP_TRUNK":    2,
}

func (x TrunkPort_TrunkType) String() string {
	return proto.EnumName(TrunkPort_TrunkType_name, int32(x))
}

func (TrunkPort_TrunkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{9, 0}
}

// BcmKnetIntfPurpose defines which application will supposed to use a KNET
// interface defined on a unit and CPU queue.
type GoogleConfig_BcmKnetIntfPurpose int32

const (
	GoogleConfig_BCM_KNET_INTF_PURPOSE_UNKNOWN    GoogleConfig_BcmKnetIntfPurpose = 0
	GoogleConfig_BCM_KNET_INTF_PURPOSE_CONTROLLER GoogleConfig_BcmKnetIntfPurpose = 1
	GoogleConfig_BCM_KNET_INTF_PURPOSE_SFLOW      GoogleConfig_BcmKnetIntfPurpose = 2
)

var GoogleConfig_BcmKnetIntfPurpose_name = map[int32]string{
	0: "BCM_KNET_INTF_PURPOSE_UNKNOWN",
	1: "BCM_KNET_INTF_PURPOSE_CONTROLLER",
	2: "BCM_KNET_INTF_PURPOSE_SFLOW",
}

var GoogleConfig_BcmKnetIntfPurpose_value = map[string]int32{
	"BCM_KNET_INTF_PURPOSE_UNKNOWN":    0,
	"BCM_KNET_INTF_PURPOSE_CONTROLLER": 1,
	"BCM_KNET_INTF_PURPOSE_SFLOW":      2,
}

func (x GoogleConfig_BcmKnetIntfPurpose) String() string {
	return proto.EnumName(GoogleConfig_BcmKnetIntfPurpose_name, int32(x))
}

func (GoogleConfig_BcmKnetIntfPurpose) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 0}
}

type GoogleConfig_BcmRtag7HashConfig_HashField int32

const (
	GoogleConfig_BcmRtag7HashConfig_UNKNOWN_FIELD              GoogleConfig_BcmRtag7HashConfig_HashField = 0
	GoogleConfig_BcmRtag7HashConfig_SRC_IP                     GoogleConfig_BcmRtag7HashConfig_HashField = 1
	GoogleConfig_BcmRtag7HashConfig_DST_IP                     GoogleConfig_BcmRtag7HashConfig_HashField = 2
	GoogleConfig_BcmRtag7HashConfig_SRC_PORT                   GoogleConfig_BcmRtag7HashConfig_HashField = 3
	GoogleConfig_BcmRtag7HashConfig_DST_PORT                   GoogleConfig_BcmRtag7HashConfig_HashField = 4
	GoogleConfig_BcmRtag7HashConfig_VLAN_ID                    GoogleConfig_BcmRtag7HashConfig_HashField = 5
	GoogleConfig_BcmRtag7HashConfig_IP_PROTO                   GoogleConfig_BcmRtag7HashConfig_HashField = 6
	GoogleConfig_BcmRtag7HashConfig_MPLS_LABEL                 GoogleConfig_BcmRtag7HashConfig_HashField = 7
	GoogleConfig_BcmRtag7HashConfig_IPV6_LO_FLOW_LABEL_16_BITS GoogleConfig_BcmRtag7HashConfig_HashField = 8
	GoogleConfig_BcmRtag7HashConfig_IPV6_HI_FLOW_LABEL_4_BITS  GoogleConfig_BcmRtag7HashConfig_HashField = 9
)

var GoogleConfig_BcmRtag7HashConfig_HashField_name = map[int32]string{
	0: "UNKNOWN_FIELD",
	1: "SRC_IP",
	2: "DST_IP",
	3: "SRC_PORT",
	4: "DST_PORT",
	5: "VLAN_ID",
	6: "IP_PROTO",
	7: "MPLS_LABEL",
	8: "IPV6_LO_FLOW_LABEL_16_BITS",
	9: "IPV6_HI_FLOW_LABEL_4_BITS",
}

var GoogleConfig_BcmRtag7HashConfig_HashField_value = map[string]int32{
	"UNKNOWN_FIELD":              0,
	"SRC_IP":                     1,
	"DST_IP":                     2,
	"SRC_PORT":                   3,
	"DST_PORT":                   4,
	"VLAN_ID":                    5,
	"IP_PROTO":                   6,
	"MPLS_LABEL":                 7,
	"IPV6_LO_FLOW_LABEL_16_BITS": 8,
	"IPV6_HI_FLOW_LABEL_4_BITS":  9,
}

func (x GoogleConfig_BcmRtag7HashConfig_HashField) String() string {
	return proto.EnumName(GoogleConfig_BcmRtag7HashConfig_HashField_name, int32(x))
}

func (GoogleConfig_BcmRtag7HashConfig_HashField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 0}
}

type GoogleConfig_BcmRtag7HashConfig_HashBlock int32

const (
	GoogleConfig_BcmRtag7HashConfig_UNKNOWN_BLOCK GoogleConfig_BcmRtag7HashConfig_HashBlock = 0
	GoogleConfig_BcmRtag7HashConfig_RTAG7A        GoogleConfig_BcmRtag7HashConfig_HashBlock = 1
	GoogleConfig_BcmRtag7HashConfig_RTAG7B        GoogleConfig_BcmRtag7HashConfig_HashBlock = 2
)

var GoogleConfig_BcmRtag7HashConfig_HashBlock_name = map[int32]string{
	0: "UNKNOWN_BLOCK",
	1: "RTAG7A",
	2: "RTAG7B",
}

var GoogleConfig_BcmRtag7HashConfig_HashBlock_value = map[string]int32{
	"UNKNOWN_BLOCK": 0,
	"RTAG7A":        1,
	"RTAG7B":        2,
}

func (x GoogleConfig_BcmRtag7HashConfig_HashBlock) String() string {
	return proto.EnumName(GoogleConfig_BcmRtag7HashConfig_HashBlock_name, int32(x))
}

func (GoogleConfig_BcmRtag7HashConfig_HashBlock) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 1}
}

type GoogleConfig_BcmRtag7HashConfig_HashSubBlock int32

const (
	GoogleConfig_BcmRtag7HashConfig_UNKNOWN_SUB_BLOCK GoogleConfig_BcmRtag7HashConfig_HashSubBlock = 0
	GoogleConfig_BcmRtag7HashConfig_RTAG7A0           GoogleConfig_BcmRtag7HashConfig_HashSubBlock = 1
	GoogleConfig_BcmRtag7HashConfig_RTAG7B0           GoogleConfig_BcmRtag7HashConfig_HashSubBlock = 2
	GoogleConfig_BcmRtag7HashConfig_RTAG7A1           GoogleConfig_BcmRtag7HashConfig_HashSubBlock = 3
	GoogleConfig_BcmRtag7HashConfig_RTAG7B1           GoogleConfig_BcmRtag7HashConfig_HashSubBlock = 4
)

var GoogleConfig_BcmRtag7HashConfig_HashSubBlock_name = map[int32]string{
	0: "UNKNOWN_SUB_BLOCK",
	1: "RTAG7A0",
	2: "RTAG7B0",
	3: "RTAG7A1",
	4: "RTAG7B1",
}

var GoogleConfig_BcmRtag7HashConfig_HashSubBlock_value = map[string]int32{
	"UNKNOWN_SUB_BLOCK": 0,
	"RTAG7A0":           1,
	"RTAG7B0":           2,
	"RTAG7A1":           3,
	"RTAG7B1":           4,
}

func (x GoogleConfig_BcmRtag7HashConfig_HashSubBlock) String() string {
	return proto.EnumName(GoogleConfig_BcmRtag7HashConfig_HashSubBlock_name, int32(x))
}

func (GoogleConfig_BcmRtag7HashConfig_HashSubBlock) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 2}
}

type GoogleConfig_BcmRtag7HashConfig_Polynomial int32

const (
	GoogleConfig_BcmRtag7HashConfig_UNKNOWN_POLYNOMIAL GoogleConfig_BcmRtag7HashConfig_Polynomial = 0
	GoogleConfig_BcmRtag7HashConfig_BISYNC             GoogleConfig_BcmRtag7HashConfig_Polynomial = 1
	GoogleConfig_BcmRtag7HashConfig_BISYNC_XOR1        GoogleConfig_BcmRtag7HashConfig_Polynomial = 2
	GoogleConfig_BcmRtag7HashConfig_BISYNC_XOR2        GoogleConfig_BcmRtag7HashConfig_Polynomial = 3
	GoogleConfig_BcmRtag7HashConfig_BISYNC_XOR4        GoogleConfig_BcmRtag7HashConfig_Polynomial = 4
	GoogleConfig_BcmRtag7HashConfig_BISYNC_XOR8        GoogleConfig_BcmRtag7HashConfig_Polynomial = 5
	GoogleConfig_BcmRtag7HashConfig_CCITT              GoogleConfig_BcmRtag7HashConfig_Polynomial = 6
	GoogleConfig_BcmRtag7HashConfig_XOR16              GoogleConfig_BcmRtag7HashConfig_Polynomial = 7
	GoogleConfig_BcmRtag7HashConfig_CRC32_LO           GoogleConfig_BcmRtag7HashConfig_Polynomial = 8
	GoogleConfig_BcmRtag7HashConfig_CRC32_HI           GoogleConfig_BcmRtag7HashConfig_Polynomial = 9
	GoogleConfig_BcmRtag7HashConfig_CRC32_ETH_LO       GoogleConfig_BcmRtag7HashConfig_Polynomial = 10
	GoogleConfig_BcmRtag7HashConfig_CRC32_ETH_HI       GoogleConfig_BcmRtag7HashConfig_Polynomial = 11
	GoogleConfig_BcmRtag7HashConfig_CRC32_KOOPMAN_LO   GoogleConfig_BcmRtag7HashConfig_Polynomial = 12
	GoogleConfig_BcmRtag7HashConfig_CRC32_KOOPMAN_HI   GoogleConfig_BcmRtag7HashConfig_Polynomial = 13
)

var GoogleConfig_BcmRtag7HashConfig_Polynomial_name = map[int32]string{
	0:  "UNKNOWN_POLYNOMIAL",
	1:  "BISYNC",
	2:  "BISYNC_XOR1",
	3:  "BISYNC_XOR2",
	4:  "BISYNC_XOR4",
	5:  "BISYNC_XOR8",
	6:  "CCITT",
	7:  "XOR16",
	8:  "CRC32_LO",
	9:  "CRC32_HI",
	10: "CRC32_ETH_LO",
	11: "CRC32_ETH_HI",
	12: "CRC32_KOOPMAN_LO",
	13: "CRC32_KOOPMAN_HI",
}

var GoogleConfig_BcmRtag7HashConfig_Polynomial_value = map[string]int32{
	"UNKNOWN_POLYNOMIAL": 0,
	"BISYNC":             1,
	"BISYNC_XOR1":        2,
	"BISYNC_XOR2":        3,
	"BISYNC_XOR4":        4,
	"BISYNC_XOR8":        5,
	"CCITT":              6,
	"XOR16":              7,
	"CRC32_LO":           8,
	"CRC32_HI":           9,
	"CRC32_ETH_LO":       10,
	"CRC32_ETH_HI":       11,
	"CRC32_KOOPMAN_LO":   12,
	"CRC32_KOOPMAN_HI":   13,
}

func (x GoogleConfig_BcmRtag7HashConfig_Polynomial) String() string {
	return proto.EnumName(GoogleConfig_BcmRtag7HashConfig_Polynomial_name, int32(x))
}

func (GoogleConfig_BcmRtag7HashConfig_Polynomial) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 3}
}

type TofinoConfig_TofinoQosConfig_ApplicationPool int32

const (
	TofinoConfig_TofinoQosConfig_UNKNOWN_APP_POOL   TofinoConfig_TofinoQosConfig_ApplicationPool = 0
	TofinoConfig_TofinoQosConfig_INGRESS_APP_POOL_0 TofinoConfig_TofinoQosConfig_ApplicationPool = 1
	TofinoConfig_TofinoQosConfig_INGRESS_APP_POOL_1 TofinoConfig_TofinoQosConfig_ApplicationPool = 2
	TofinoConfig_TofinoQosConfig_INGRESS_APP_POOL_2 TofinoConfig_TofinoQosConfig_ApplicationPool = 3
	TofinoConfig_TofinoQosConfig_INGRESS_APP_POOL_3 TofinoConfig_TofinoQosConfig_ApplicationPool = 4
	TofinoConfig_TofinoQosConfig_EGRESS_APP_POOL_0  TofinoConfig_TofinoQosConfig_ApplicationPool = 5
	TofinoConfig_TofinoQosConfig_EGRESS_APP_POOL_1  TofinoConfig_TofinoQosConfig_ApplicationPool = 6
	TofinoConfig_TofinoQosConfig_EGRESS_APP_POOL_2  TofinoConfig_TofinoQosConfig_ApplicationPool = 7
	TofinoConfig_TofinoQosConfig_EGRESS_APP_POOL_3  TofinoConfig_TofinoQosConfig_ApplicationPool = 8
)

var TofinoConfig_TofinoQosConfig_ApplicationPool_name = map[int32]string{
	0: "UNKNOWN_APP_POOL",
	1: "INGRESS_APP_POOL_0",
	2: "INGRESS_APP_POOL_1",
	3: "INGRESS_APP_POOL_2",
	4: "INGRESS_APP_POOL_3",
	5: "EGRESS_APP_POOL_0",
	6: "EGRESS_APP_POOL_1",
	7: "EGRESS_APP_POOL_2",
	8: "EGRESS_APP_POOL_3",
}

var TofinoConfig_TofinoQosConfig_ApplicationPool_value = map[string]int32{
	"UNKNOWN_APP_POOL":   0,
	"INGRESS_APP_POOL_0": 1,
	"INGRESS_APP_POOL_1": 2,
	"INGRESS_APP_POOL_2": 3,
	"INGRESS_APP_POOL_3": 4,
	"EGRESS_APP_POOL_0":  5,
	"EGRESS_APP_POOL_1":  6,
	"EGRESS_APP_POOL_2":  7,
	"EGRESS_APP_POOL_3":  8,
}

func (x TofinoConfig_TofinoQosConfig_ApplicationPool) String() string {
	return proto.EnumName(TofinoConfig_TofinoQosConfig_ApplicationPool_name, int32(x))
}

func (TofinoConfig_TofinoQosConfig_ApplicationPool) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 0}
}

type TofinoConfig_TofinoQosConfig_Baf int32

const (
	TofinoConfig_TofinoQosConfig_UNKNOWN_BAF           TofinoConfig_TofinoQosConfig_Baf = 0
	TofinoConfig_TofinoQosConfig_BAF_1_POINT_5_PERCENT TofinoConfig_TofinoQosConfig_Baf = 1
	TofinoConfig_TofinoQosConfig_BAF_3_PERCENT         TofinoConfig_TofinoQosConfig_Baf = 2
	TofinoConfig_TofinoQosConfig_BAF_6_PERCENT         TofinoConfig_TofinoQosConfig_Baf = 3
	TofinoConfig_TofinoQosConfig_BAF_11_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 4
	TofinoConfig_TofinoQosConfig_BAF_20_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 5
	TofinoConfig_TofinoQosConfig_BAF_33_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 6
	TofinoConfig_TofinoQosConfig_BAF_50_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 7
	TofinoConfig_TofinoQosConfig_BAF_66_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 8
	TofinoConfig_TofinoQosConfig_BAF_80_PERCENT        TofinoConfig_TofinoQosConfig_Baf = 9
	TofinoConfig_TofinoQosConfig_DISABLE_BAF           TofinoConfig_TofinoQosConfig_Baf = 10
)

var TofinoConfig_TofinoQosConfig_Baf_name = map[int32]string{
	0:  "UNKNOWN_BAF",
	1:  "BAF_1_POINT_5_PERCENT",
	2:  "BAF_3_PERCENT",
	3:  "BAF_6_PERCENT",
	4:  "BAF_11_PERCENT",
	5:  "BAF_20_PERCENT",
	6:  "BAF_33_PERCENT",
	7:  "BAF_50_PERCENT",
	8:  "BAF_66_PERCENT",
	9:  "BAF_80_PERCENT",
	10: "DISABLE_BAF",
}

var TofinoConfig_TofinoQosConfig_Baf_value = map[string]int32{
	"UNKNOWN_BAF":           0,
	"BAF_1_POINT_5_PERCENT": 1,
	"BAF_3_PERCENT":         2,
	"BAF_6_PERCENT":         3,
	"BAF_11_PERCENT":        4,
	"BAF_20_PERCENT":        5,
	"BAF_33_PERCENT":        6,
	"BAF_50_PERCENT":        7,
	"BAF_66_PERCENT":        8,
	"BAF_80_PERCENT":        9,
	"DISABLE_BAF":           10,
}

func (x TofinoConfig_TofinoQosConfig_Baf) String() string {
	return proto.EnumName(TofinoConfig_TofinoQosConfig_Baf_name, int32(x))
}

func (TofinoConfig_TofinoQosConfig_Baf) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 1}
}

type TofinoConfig_TofinoQosConfig_SchedulingPriority int32

const (
	TofinoConfig_TofinoQosConfig_UNKNOWN_PRIO TofinoConfig_TofinoQosConfig_SchedulingPriority = 0
	TofinoConfig_TofinoQosConfig_PRIO_0       TofinoConfig_TofinoQosConfig_SchedulingPriority = 1
	TofinoConfig_TofinoQosConfig_PRIO_1       TofinoConfig_TofinoQosConfig_SchedulingPriority = 2
	TofinoConfig_TofinoQosConfig_PRIO_2       TofinoConfig_TofinoQosConfig_SchedulingPriority = 3
	TofinoConfig_TofinoQosConfig_PRIO_3       TofinoConfig_TofinoQosConfig_SchedulingPriority = 4
	TofinoConfig_TofinoQosConfig_PRIO_4       TofinoConfig_TofinoQosConfig_SchedulingPriority = 5
	TofinoConfig_TofinoQosConfig_PRIO_5       TofinoConfig_TofinoQosConfig_SchedulingPriority = 6
	TofinoConfig_TofinoQosConfig_PRIO_6       TofinoConfig_TofinoQosConfig_SchedulingPriority = 7
	TofinoConfig_TofinoQosConfig_PRIO_7       TofinoConfig_TofinoQosConfig_SchedulingPriority = 8
)

var TofinoConfig_TofinoQosConfig_SchedulingPriority_name = map[int32]string{
	0: "UNKNOWN_PRIO",
	1: "PRIO_0",
	2: "PRIO_1",
	3: "PRIO_2",
	4: "PRIO_3",
	5: "PRIO_4",
	6: "PRIO_5",
	7: "PRIO_6",
	8: "PRIO_7",
}

var TofinoConfig_TofinoQosConfig_SchedulingPriority_value = map[string]int32{
	"UNKNOWN_PRIO": 0,
	"PRIO_0":       1,
	"PRIO_1":       2,
	"PRIO_2":       3,
	"PRIO_3":       4,
	"PRIO_4":       5,
	"PRIO_5":       6,
	"PRIO_6":       7,
	"PRIO_7":       8,
}

func (x TofinoConfig_TofinoQosConfig_SchedulingPriority) String() string {
	return proto.EnumName(TofinoConfig_TofinoQosConfig_SchedulingPriority_name, int32(x))
}

func (TofinoConfig_TofinoQosConfig_SchedulingPriority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 2}
}

type TofinoConfig_TofinoQosConfig_QueueColorLimit int32

const (
	TofinoConfig_TofinoQosConfig_UNKNOWN_LIMIT            TofinoConfig_TofinoQosConfig_QueueColorLimit = 0
	TofinoConfig_TofinoQosConfig_LIMIT_12_POINT_5_PERCENT TofinoConfig_TofinoQosConfig_QueueColorLimit = 1
	TofinoConfig_TofinoQosConfig_LIMIT_25_PERCENT         TofinoConfig_TofinoQosConfig_QueueColorLimit = 2
	TofinoConfig_TofinoQosConfig_LIMIT_37_POINT_5_PERCENT TofinoConfig_TofinoQosConfig_QueueColorLimit = 3
	TofinoConfig_TofinoQosConfig_LIMIT_50_PERCENT         TofinoConfig_TofinoQosConfig_QueueColorLimit = 4
	TofinoConfig_TofinoQosConfig_LIMIT_62_POINT_5_PERCENT TofinoConfig_TofinoQosConfig_QueueColorLimit = 5
	TofinoConfig_TofinoQosConfig_LIMIT_75_PERCENT         TofinoConfig_TofinoQosConfig_QueueColorLimit = 6
	TofinoConfig_TofinoQosConfig_LIMIT_87_POINT_5_PERCENT TofinoConfig_TofinoQosConfig_QueueColorLimit = 7
	TofinoConfig_TofinoQosConfig_LIMIT_100_PERCENT        TofinoConfig_TofinoQosConfig_QueueColorLimit = 8
)

var TofinoConfig_TofinoQosConfig_QueueColorLimit_name = map[int32]string{
	0: "UNKNOWN_LIMIT",
	1: "LIMIT_12_POINT_5_PERCENT",
	2: "LIMIT_25_PERCENT",
	3: "LIMIT_37_POINT_5_PERCENT",
	4: "LIMIT_50_PERCENT",
	5: "LIMIT_62_POINT_5_PERCENT",
	6: "LIMIT_75_PERCENT",
	7: "LIMIT_87_POINT_5_PERCENT",
	8: "LIMIT_100_PERCENT",
}

var TofinoConfig_TofinoQosConfig_QueueColorLimit_value = map[string]int32{
	"UNKNOWN_LIMIT":            0,
	"LIMIT_12_POINT_5_PERCENT": 1,
	"LIMIT_25_PERCENT":         2,
	"LIMIT_37_POINT_5_PERCENT": 3,
	"LIMIT_50_PERCENT":         4,
	"LIMIT_62_POINT_5_PERCENT": 5,
	"LIMIT_75_PERCENT":         6,
	"LIMIT_87_POINT_5_PERCENT": 7,
	"LIMIT_100_PERCENT":        8,
}

func (x TofinoConfig_TofinoQosConfig_QueueColorLimit) String() string {
	return proto.EnumName(TofinoConfig_TofinoQosConfig_QueueColorLimit_name, int32(x))
}

func (TofinoConfig_TofinoQosConfig_QueueColorLimit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 3}
}

type Alarm_Severity int32

const (
	Alarm_UNKNOWN  Alarm_Severity = 0
	Alarm_MINOR    Alarm_Severity = 1
	Alarm_WARNING  Alarm_Severity = 2
	Alarm_MAJOR    Alarm_Severity = 3
	Alarm_CRITICAL Alarm_Severity = 4
)

var Alarm_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "MINOR",
	2: "WARNING",
	3: "MAJOR",
	4: "CRITICAL",
}

var Alarm_Severity_value = map[string]int32{
	"UNKNOWN":  0,
	"MINOR":    1,
	"WARNING":  2,
	"MAJOR":    3,
	"CRITICAL": 4,
}

func (x Alarm_Severity) String() string {
	return proto.EnumName(Alarm_Severity_name, int32(x))
}

func (Alarm_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{30, 0}
}

// Config-related parameters for the entire chassis.
type ChassisConfigParams struct {
	LacpConfig    *ChassisConfigParams_LacpConfig     `protobuf:"bytes,1,opt,name=lacp_config,json=lacpConfig,proto3" json:"lacp_config,omitempty"`
	NetConfig     *ChassisConfigParams_NtpConfig      `protobuf:"bytes,2,opt,name=net_config,json=netConfig,proto3" json:"net_config,omitempty"`
	PowerConfig   *ChassisConfigParams_PowerConfig    `protobuf:"bytes,3,opt,name=power_config,json=powerConfig,proto3" json:"power_config,omitempty"`
	FanConfigs    []*ChassisConfigParams_FanConfig    `protobuf:"bytes,4,rep,name=fan_configs,json=fanConfigs,proto3" json:"fan_configs,omitempty"`
	TuntapConfigs []*ChassisConfigParams_TuntapConfig `protobuf:"bytes,5,rep,name=tuntap_configs,json=tuntapConfigs,proto3" json:"tuntap_configs,omitempty"`
}

func (m *ChassisConfigParams) Reset()         { *m = ChassisConfigParams{} }
func (m *ChassisConfigParams) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams) ProtoMessage()    {}
func (*ChassisConfigParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0}
}
func (m *ChassisConfigParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams.Merge(m, src)
}
func (m *ChassisConfigParams) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams proto.InternalMessageInfo

func (m *ChassisConfigParams) GetLacpConfig() *ChassisConfigParams_LacpConfig {
	if m != nil {
		return m.LacpConfig
	}
	return nil
}

func (m *ChassisConfigParams) GetNetConfig() *ChassisConfigParams_NtpConfig {
	if m != nil {
		return m.NetConfig
	}
	return nil
}

func (m *ChassisConfigParams) GetPowerConfig() *ChassisConfigParams_PowerConfig {
	if m != nil {
		return m.PowerConfig
	}
	return nil
}

func (m *ChassisConfigParams) GetFanConfigs() []*ChassisConfigParams_FanConfig {
	if m != nil {
		return m.FanConfigs
	}
	return nil
}

func (m *ChassisConfigParams) GetTuntapConfigs() []*ChassisConfigParams_TuntapConfig {
	if m != nil {
		return m.TuntapConfigs
	}
	return nil
}

type ChassisConfigParams_LacpConfig struct {
	// Router MAC portion of LACP system ID. A mac address stored on 6
	// least-siginificant bytes.
	LacpRouterMac uint64 `protobuf:"varint,1,opt,name=lacp_router_mac,json=lacpRouterMac,proto3" json:"lacp_router_mac,omitempty"`
	// System priority portion of LACP system ID.
	LacpSystemPriority uint32 `protobuf:"varint,2,opt,name=lacp_system_priority,json=lacpSystemPriority,proto3" json:"lacp_system_priority,omitempty"`
}

func (m *ChassisConfigParams_LacpConfig) Reset()         { *m = ChassisConfigParams_LacpConfig{} }
func (m *ChassisConfigParams_LacpConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams_LacpConfig) ProtoMessage()    {}
func (*ChassisConfigParams_LacpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 0}
}
func (m *ChassisConfigParams_LacpConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams_LacpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams_LacpConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams_LacpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams_LacpConfig.Merge(m, src)
}
func (m *ChassisConfigParams_LacpConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams_LacpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams_LacpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams_LacpConfig proto.InternalMessageInfo

func (m *ChassisConfigParams_LacpConfig) GetLacpRouterMac() uint64 {
	if m != nil {
		return m.LacpRouterMac
	}
	return 0
}

func (m *ChassisConfigParams_LacpConfig) GetLacpSystemPriority() uint32 {
	if m != nil {
		return m.LacpSystemPriority
	}
	return 0
}

type ChassisConfigParams_NtpConfig struct {
}

func (m *ChassisConfigParams_NtpConfig) Reset()         { *m = ChassisConfigParams_NtpConfig{} }
func (m *ChassisConfigParams_NtpConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams_NtpConfig) ProtoMessage()    {}
func (*ChassisConfigParams_NtpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 1}
}
func (m *ChassisConfigParams_NtpConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams_NtpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams_NtpConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams_NtpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams_NtpConfig.Merge(m, src)
}
func (m *ChassisConfigParams_NtpConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams_NtpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams_NtpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams_NtpConfig proto.InternalMessageInfo

type ChassisConfigParams_PowerConfig struct {
}

func (m *ChassisConfigParams_PowerConfig) Reset()         { *m = ChassisConfigParams_PowerConfig{} }
func (m *ChassisConfigParams_PowerConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams_PowerConfig) ProtoMessage()    {}
func (*ChassisConfigParams_PowerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 2}
}
func (m *ChassisConfigParams_PowerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams_PowerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams_PowerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams_PowerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams_PowerConfig.Merge(m, src)
}
func (m *ChassisConfigParams_PowerConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams_PowerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams_PowerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams_PowerConfig proto.InternalMessageInfo

type ChassisConfigParams_FanConfig struct {
	// The unique ID of the fan within the chassis. Association of an ID to a
	// fan is done internally and can be queried by an external tool.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Speed in percentage (0 means off and 100 means max speed). Used only
	// manual speed change is available. If so and this value is set to zero,
	// the fan will be off, unless the fan has a closed loop temperature
	// controller and a non zero target_temp_celsius is given. If manual speed
	// set is not available, giving a fan config for the fan will result in an
	// error.
	SpeedPercentage uint32 `protobuf:"varint,2,opt,name=speed_percentage,json=speedPercentage,proto3" json:"speed_percentage,omitempty"`
	// Target temperature for the sensor used for fan speed control. Used only
	// when a closed loop temperature controller is available and the value is
	// non-zero. Otherwise, it is ignored.
	TargetTemperatureCelsius uint32 `protobuf:"varint,3,opt,name=target_temperature_celsius,json=targetTemperatureCelsius,proto3" json:"target_temperature_celsius,omitempty"`
}

func (m *ChassisConfigParams_FanConfig) Reset()         { *m = ChassisConfigParams_FanConfig{} }
func (m *ChassisConfigParams_FanConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams_FanConfig) ProtoMessage()    {}
func (*ChassisConfigParams_FanConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 3}
}
func (m *ChassisConfigParams_FanConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams_FanConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams_FanConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams_FanConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams_FanConfig.Merge(m, src)
}
func (m *ChassisConfigParams_FanConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams_FanConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams_FanConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams_FanConfig proto.InternalMessageInfo

func (m *ChassisConfigParams_FanConfig) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChassisConfigParams_FanConfig) GetSpeedPercentage() uint32 {
	if m != nil {
		return m.SpeedPercentage
	}
	return 0
}

func (m *ChassisConfigParams_FanConfig) GetTargetTemperatureCelsius() uint32 {
	if m != nil {
		return m.TargetTemperatureCelsius
	}
	return 0
}

type ChassisConfigParams_TuntapConfig struct {
	// The name of the tuntap device (e.g. tap0).
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Dataplane mode (typically set to LOAD_BALANCE).
	Mode ChassisConfigParams_TuntapConfig_Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=stratum.hal.ChassisConfigParams_TuntapConfig_Mode" json:"mode,omitempty"`
	// v4 and v6 IP addresses and prefixelens.
	Ipv4Address   string `protobuf:"bytes,3,opt,name=ipv4_address,json=ipv4Address,proto3" json:"ipv4_address,omitempty"`
	Ipv4Prefixlen uint32 `protobuf:"varint,4,opt,name=ipv4_prefixlen,json=ipv4Prefixlen,proto3" json:"ipv4_prefixlen,omitempty"`
	Ipv6Address   string `protobuf:"bytes,5,opt,name=ipv6_address,json=ipv6Address,proto3" json:"ipv6_address,omitempty"`
	Ipv6Prefixlen uint32 `protobuf:"varint,6,opt,name=ipv6_prefixlen,json=ipv6Prefixlen,proto3" json:"ipv6_prefixlen,omitempty"`
	// Is this netdev used for default route in Linux.
	DefaultNetdev bool `protobuf:"varint,7,opt,name=default_netdev,json=defaultNetdev,proto3" json:"default_netdev,omitempty"`
}

func (m *ChassisConfigParams_TuntapConfig) Reset()         { *m = ChassisConfigParams_TuntapConfig{} }
func (m *ChassisConfigParams_TuntapConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfigParams_TuntapConfig) ProtoMessage()    {}
func (*ChassisConfigParams_TuntapConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{0, 4}
}
func (m *ChassisConfigParams_TuntapConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfigParams_TuntapConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfigParams_TuntapConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfigParams_TuntapConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfigParams_TuntapConfig.Merge(m, src)
}
func (m *ChassisConfigParams_TuntapConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfigParams_TuntapConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfigParams_TuntapConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfigParams_TuntapConfig proto.InternalMessageInfo

func (m *ChassisConfigParams_TuntapConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChassisConfigParams_TuntapConfig) GetMode() ChassisConfigParams_TuntapConfig_Mode {
	if m != nil {
		return m.Mode
	}
	return ChassisConfigParams_TuntapConfig_UNKNOWN
}

func (m *ChassisConfigParams_TuntapConfig) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *ChassisConfigParams_TuntapConfig) GetIpv4Prefixlen() uint32 {
	if m != nil {
		return m.Ipv4Prefixlen
	}
	return 0
}

func (m *ChassisConfigParams_TuntapConfig) GetIpv6Address() string {
	if m != nil {
		return m.Ipv6Address
	}
	return ""
}

func (m *ChassisConfigParams_TuntapConfig) GetIpv6Prefixlen() uint32 {
	if m != nil {
		return m.Ipv6Prefixlen
	}
	return 0
}

func (m *ChassisConfigParams_TuntapConfig) GetDefaultNetdev() bool {
	if m != nil {
		return m.DefaultNetdev
	}
	return false
}

// Flow-related parameters for for switching nodes (aka chips).
type NodeFlowParams struct {
}

func (m *NodeFlowParams) Reset()         { *m = NodeFlowParams{} }
func (m *NodeFlowParams) String() string { return proto.CompactTextString(m) }
func (*NodeFlowParams) ProtoMessage()    {}
func (*NodeFlowParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{1}
}
func (m *NodeFlowParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeFlowParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeFlowParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeFlowParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeFlowParams.Merge(m, src)
}
func (m *NodeFlowParams) XXX_Size() int {
	return m.Size()
}
func (m *NodeFlowParams) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeFlowParams.DiscardUnknown(m)
}

var xxx_messageInfo_NodeFlowParams proto.InternalMessageInfo

// Config-related parameters for switching nodes (aka chips).
type NodeConfigParams struct {
	VlanConfigs []*NodeConfigParams_VlanConfig `protobuf:"bytes,1,rep,name=vlan_configs,json=vlanConfigs,proto3" json:"vlan_configs,omitempty"`
	L2Config    *NodeConfigParams_L2Config     `protobuf:"bytes,2,opt,name=l2_config,json=l2Config,proto3" json:"l2_config,omitempty"`
	QosConfig   *NodeConfigParams_QosConfig    `protobuf:"bytes,3,opt,name=qos_config,json=qosConfig,proto3" json:"qos_config,omitempty"`
}

func (m *NodeConfigParams) Reset()         { *m = NodeConfigParams{} }
func (m *NodeConfigParams) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams) ProtoMessage()    {}
func (*NodeConfigParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2}
}
func (m *NodeConfigParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams.Merge(m, src)
}
func (m *NodeConfigParams) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams proto.InternalMessageInfo

func (m *NodeConfigParams) GetVlanConfigs() []*NodeConfigParams_VlanConfig {
	if m != nil {
		return m.VlanConfigs
	}
	return nil
}

func (m *NodeConfigParams) GetL2Config() *NodeConfigParams_L2Config {
	if m != nil {
		return m.L2Config
	}
	return nil
}

func (m *NodeConfigParams) GetQosConfig() *NodeConfigParams_QosConfig {
	if m != nil {
		return m.QosConfig
	}
	return nil
}

// Per-VLAN configuration.
type NodeConfigParams_VlanConfig struct {
	// VLAN id.
	VlanId int32 `protobuf:"varint,1,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	// Block broadcast packets for this VLAN?
	BlockBroadcast bool `protobuf:"varint,2,opt,name=block_broadcast,json=blockBroadcast,proto3" json:"block_broadcast,omitempty"`
	// Block known multicast packets for this VLAN?
	BlockKnownMulticast bool `protobuf:"varint,3,opt,name=block_known_multicast,json=blockKnownMulticast,proto3" json:"block_known_multicast,omitempty"`
	// Block unknown multicast packets for this VLAN?
	BlockUnknownMulticast bool `protobuf:"varint,4,opt,name=block_unknown_multicast,json=blockUnknownMulticast,proto3" json:"block_unknown_multicast,omitempty"`
	// Block unknown multicast packets for this VLAN?
	BlockUnknownUnicast bool `protobuf:"varint,5,opt,name=block_unknown_unicast,json=blockUnknownUnicast,proto3" json:"block_unknown_unicast,omitempty"`
	// L2 learning needs to be disabled for this VLAN?
	DisableL2Learning bool `protobuf:"varint,6,opt,name=disable_l2_learning,json=disableL2Learning,proto3" json:"disable_l2_learning,omitempty"`
}

func (m *NodeConfigParams_VlanConfig) Reset()         { *m = NodeConfigParams_VlanConfig{} }
func (m *NodeConfigParams_VlanConfig) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_VlanConfig) ProtoMessage()    {}
func (*NodeConfigParams_VlanConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 0}
}
func (m *NodeConfigParams_VlanConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_VlanConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_VlanConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_VlanConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_VlanConfig.Merge(m, src)
}
func (m *NodeConfigParams_VlanConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_VlanConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_VlanConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_VlanConfig proto.InternalMessageInfo

func (m *NodeConfigParams_VlanConfig) GetVlanId() int32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

func (m *NodeConfigParams_VlanConfig) GetBlockBroadcast() bool {
	if m != nil {
		return m.BlockBroadcast
	}
	return false
}

func (m *NodeConfigParams_VlanConfig) GetBlockKnownMulticast() bool {
	if m != nil {
		return m.BlockKnownMulticast
	}
	return false
}

func (m *NodeConfigParams_VlanConfig) GetBlockUnknownMulticast() bool {
	if m != nil {
		return m.BlockUnknownMulticast
	}
	return false
}

func (m *NodeConfigParams_VlanConfig) GetBlockUnknownUnicast() bool {
	if m != nil {
		return m.BlockUnknownUnicast
	}
	return false
}

func (m *NodeConfigParams_VlanConfig) GetDisableL2Learning() bool {
	if m != nil {
		return m.DisableL2Learning
	}
	return false
}

// Per node L2-related configs.
type NodeConfigParams_L2Config struct {
	// L2 aging for L2 entries. Affects VLANs with L2 learning enabled. 0
	// (default) will disable aging timer.
	L2AgeDurationSec int32 `protobuf:"varint,1,opt,name=l2_age_duration_sec,json=l2AgeDurationSec,proto3" json:"l2_age_duration_sec,omitempty"`
}

func (m *NodeConfigParams_L2Config) Reset()         { *m = NodeConfigParams_L2Config{} }
func (m *NodeConfigParams_L2Config) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_L2Config) ProtoMessage()    {}
func (*NodeConfigParams_L2Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 1}
}
func (m *NodeConfigParams_L2Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_L2Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_L2Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_L2Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_L2Config.Merge(m, src)
}
func (m *NodeConfigParams_L2Config) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_L2Config) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_L2Config.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_L2Config proto.InternalMessageInfo

func (m *NodeConfigParams_L2Config) GetL2AgeDurationSec() int32 {
	if m != nil {
		return m.L2AgeDurationSec
	}
	return 0
}

// Per node QoS configuration. This config is expected to be common among
// all the chips.
type NodeConfigParams_QosConfig struct {
	SchedulingMode            NodeConfigParams_QosConfig_SchedulingMode               `protobuf:"varint,1,opt,name=scheduling_mode,json=schedulingMode,proto3,enum=stratum.hal.NodeConfigParams_QosConfig_SchedulingMode" json:"scheduling_mode,omitempty"`
	SchedulingConfig          []*NodeConfigParams_QosConfig_SchedulerConfig           `protobuf:"bytes,2,rep,name=scheduling_config,json=schedulingConfig,proto3" json:"scheduling_config,omitempty"`
	Dot1PMapping              []*NodeConfigParams_QosConfig_Dot1PMapping              `protobuf:"bytes,3,rep,name=dot1p_mapping,json=dot1pMapping,proto3" json:"dot1p_mapping,omitempty"`
	DscpMapping               []*NodeConfigParams_QosConfig_DscpMapping               `protobuf:"bytes,4,rep,name=dscp_mapping,json=dscpMapping,proto3" json:"dscp_mapping,omitempty"`
	TrafficClassMapping       []*NodeConfigParams_QosConfig_TrafficClassMapping       `protobuf:"bytes,5,rep,name=traffic_class_mapping,json=trafficClassMapping,proto3" json:"traffic_class_mapping,omitempty"`
	CosqMapping               []*NodeConfigParams_QosConfig_CosqMapping               `protobuf:"bytes,6,rep,name=cosq_mapping,json=cosqMapping,proto3" json:"cosq_mapping,omitempty"`
	PriorityGroupMapping      []*NodeConfigParams_QosConfig_PriorityGroupMapping      `protobuf:"bytes,7,rep,name=priority_group_mapping,json=priorityGroupMapping,proto3" json:"priority_group_mapping,omitempty"`
	IngressServicePoolMapping []*NodeConfigParams_QosConfig_IngressServicePoolMapping `protobuf:"bytes,8,rep,name=ingress_service_pool_mapping,json=ingressServicePoolMapping,proto3" json:"ingress_service_pool_mapping,omitempty"`
	EgressServicePoolMapping  []*NodeConfigParams_QosConfig_EgressServicePoolMapping  `protobuf:"bytes,9,rep,name=egress_service_pool_mapping,json=egressServicePoolMapping,proto3" json:"egress_service_pool_mapping,omitempty"`
}

func (m *NodeConfigParams_QosConfig) Reset()         { *m = NodeConfigParams_QosConfig{} }
func (m *NodeConfigParams_QosConfig) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_QosConfig) ProtoMessage()    {}
func (*NodeConfigParams_QosConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2}
}
func (m *NodeConfigParams_QosConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig) GetSchedulingMode() NodeConfigParams_QosConfig_SchedulingMode {
	if m != nil {
		return m.SchedulingMode
	}
	return NodeConfigParams_QosConfig_QOS_SCHED_UNKNOWN
}

func (m *NodeConfigParams_QosConfig) GetSchedulingConfig() []*NodeConfigParams_QosConfig_SchedulerConfig {
	if m != nil {
		return m.SchedulingConfig
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetDot1PMapping() []*NodeConfigParams_QosConfig_Dot1PMapping {
	if m != nil {
		return m.Dot1PMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetDscpMapping() []*NodeConfigParams_QosConfig_DscpMapping {
	if m != nil {
		return m.DscpMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetTrafficClassMapping() []*NodeConfigParams_QosConfig_TrafficClassMapping {
	if m != nil {
		return m.TrafficClassMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetCosqMapping() []*NodeConfigParams_QosConfig_CosqMapping {
	if m != nil {
		return m.CosqMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetPriorityGroupMapping() []*NodeConfigParams_QosConfig_PriorityGroupMapping {
	if m != nil {
		return m.PriorityGroupMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetIngressServicePoolMapping() []*NodeConfigParams_QosConfig_IngressServicePoolMapping {
	if m != nil {
		return m.IngressServicePoolMapping
	}
	return nil
}

func (m *NodeConfigParams_QosConfig) GetEgressServicePoolMapping() []*NodeConfigParams_QosConfig_EgressServicePoolMapping {
	if m != nil {
		return m.EgressServicePoolMapping
	}
	return nil
}

// Per internal priority scheduling config.
type NodeConfigParams_QosConfig_SchedulerConfig struct {
	// Internal priority.
	InternalPriority uint32 `protobuf:"varint,1,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
	// Weights used for WRR and WDRR. Ignored for other modes.
	SchedulerWeight uint32 `protobuf:"varint,2,opt,name=scheduler_weight,json=schedulerWeight,proto3" json:"scheduler_weight,omitempty"`
	// Max and min bandwidth for each internal priority.
	MinBandwidthPercent uint32 `protobuf:"varint,3,opt,name=min_bandwidth_percent,json=minBandwidthPercent,proto3" json:"min_bandwidth_percent,omitempty"`
	MaxBandwidthPercent uint32 `protobuf:"varint,4,opt,name=max_bandwidth_percent,json=maxBandwidthPercent,proto3" json:"max_bandwidth_percent,omitempty"`
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) Reset() {
	*m = NodeConfigParams_QosConfig_SchedulerConfig{}
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) String() string {
	return proto.CompactTextString(m)
}
func (*NodeConfigParams_QosConfig_SchedulerConfig) ProtoMessage() {}
func (*NodeConfigParams_QosConfig_SchedulerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 0}
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_SchedulerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_SchedulerConfig.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_SchedulerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_SchedulerConfig proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_SchedulerConfig) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) GetSchedulerWeight() uint32 {
	if m != nil {
		return m.SchedulerWeight
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) GetMinBandwidthPercent() uint32 {
	if m != nil {
		return m.MinBandwidthPercent
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) GetMaxBandwidthPercent() uint32 {
	if m != nil {
		return m.MaxBandwidthPercent
	}
	return 0
}

// 802.1p priority to internal priority map entry.
type NodeConfigParams_QosConfig_Dot1PMapping struct {
	Dot1PPriority    uint32 `protobuf:"varint,1,opt,name=dot1p_priority,json=dot1pPriority,proto3" json:"dot1p_priority,omitempty"`
	InternalPriority uint32 `protobuf:"varint,2,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) Reset() {
	*m = NodeConfigParams_QosConfig_Dot1PMapping{}
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_QosConfig_Dot1PMapping) ProtoMessage()    {}
func (*NodeConfigParams_QosConfig_Dot1PMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 1}
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_Dot1PMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_Dot1PMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_Dot1PMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_Dot1PMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_Dot1PMapping) GetDot1PPriority() uint32 {
	if m != nil {
		return m.Dot1PPriority
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

// DSCP range to internal priority map entry.
type NodeConfigParams_QosConfig_DscpMapping struct {
	DscpStart        uint32 `protobuf:"varint,1,opt,name=dscp_start,json=dscpStart,proto3" json:"dscp_start,omitempty"`
	DscpEnd          uint32 `protobuf:"varint,2,opt,name=dscp_end,json=dscpEnd,proto3" json:"dscp_end,omitempty"`
	InternalPriority uint32 `protobuf:"varint,3,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
}

func (m *NodeConfigParams_QosConfig_DscpMapping) Reset() {
	*m = NodeConfigParams_QosConfig_DscpMapping{}
}
func (m *NodeConfigParams_QosConfig_DscpMapping) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_QosConfig_DscpMapping) ProtoMessage()    {}
func (*NodeConfigParams_QosConfig_DscpMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 2}
}
func (m *NodeConfigParams_QosConfig_DscpMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_DscpMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_DscpMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_DscpMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_DscpMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_DscpMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_DscpMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_DscpMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_DscpMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_DscpMapping) GetDscpStart() uint32 {
	if m != nil {
		return m.DscpStart
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_DscpMapping) GetDscpEnd() uint32 {
	if m != nil {
		return m.DscpEnd
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_DscpMapping) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

// Internal priority to the traffic class map entry.
// The map is expected to be 1-to-1.
type NodeConfigParams_QosConfig_TrafficClassMapping struct {
	InternalPriority uint32       `protobuf:"varint,1,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
	TrafficClass     TrafficClass `protobuf:"varint,2,opt,name=traffic_class,json=trafficClass,proto3,enum=stratum.hal.TrafficClass" json:"traffic_class,omitempty"`
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) Reset() {
	*m = NodeConfigParams_QosConfig_TrafficClassMapping{}
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) String() string {
	return proto.CompactTextString(m)
}
func (*NodeConfigParams_QosConfig_TrafficClassMapping) ProtoMessage() {}
func (*NodeConfigParams_QosConfig_TrafficClassMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 3}
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_TrafficClassMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_TrafficClassMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_TrafficClassMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_TrafficClassMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) GetTrafficClass() TrafficClass {
	if m != nil {
		return m.TrafficClass
	}
	return TrafficClass_UNDEFINED
}

// Internal priority to the ingress priority group number map entry.
// The map is expected to be 1-to-1.
type NodeConfigParams_QosConfig_PriorityGroupMapping struct {
	InternalPriority uint32 `protobuf:"varint,1,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
	PgNum            uint32 `protobuf:"varint,2,opt,name=pg_num,json=pgNum,proto3" json:"pg_num,omitempty"`
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) Reset() {
	*m = NodeConfigParams_QosConfig_PriorityGroupMapping{}
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) String() string {
	return proto.CompactTextString(m)
}
func (*NodeConfigParams_QosConfig_PriorityGroupMapping) ProtoMessage() {}
func (*NodeConfigParams_QosConfig_PriorityGroupMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 4}
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_PriorityGroupMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_PriorityGroupMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_PriorityGroupMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_PriorityGroupMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) GetPgNum() uint32 {
	if m != nil {
		return m.PgNum
	}
	return 0
}

// Internal priority to the egress CoS queue number map entry.
// The map is expected to be 1-to-1.
type NodeConfigParams_QosConfig_CosqMapping struct {
	InternalPriority uint32 `protobuf:"varint,1,opt,name=internal_priority,json=internalPriority,proto3" json:"internal_priority,omitempty"`
	QNum             uint32 `protobuf:"varint,2,opt,name=q_num,json=qNum,proto3" json:"q_num,omitempty"`
}

func (m *NodeConfigParams_QosConfig_CosqMapping) Reset() {
	*m = NodeConfigParams_QosConfig_CosqMapping{}
}
func (m *NodeConfigParams_QosConfig_CosqMapping) String() string { return proto.CompactTextString(m) }
func (*NodeConfigParams_QosConfig_CosqMapping) ProtoMessage()    {}
func (*NodeConfigParams_QosConfig_CosqMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 5}
}
func (m *NodeConfigParams_QosConfig_CosqMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_CosqMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_CosqMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_CosqMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_CosqMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_CosqMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_CosqMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_CosqMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_CosqMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_CosqMapping) GetInternalPriority() uint32 {
	if m != nil {
		return m.InternalPriority
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_CosqMapping) GetQNum() uint32 {
	if m != nil {
		return m.QNum
	}
	return 0
}

// Ingress priority group number to the ingress service pool map entry.
type NodeConfigParams_QosConfig_IngressServicePoolMapping struct {
	PgNum uint32 `protobuf:"varint,1,opt,name=pg_num,json=pgNum,proto3" json:"pg_num,omitempty"`
	SpNum uint32 `protobuf:"varint,2,opt,name=sp_num,json=spNum,proto3" json:"sp_num,omitempty"`
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) Reset() {
	*m = NodeConfigParams_QosConfig_IngressServicePoolMapping{}
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) String() string {
	return proto.CompactTextString(m)
}
func (*NodeConfigParams_QosConfig_IngressServicePoolMapping) ProtoMessage() {}
func (*NodeConfigParams_QosConfig_IngressServicePoolMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 6}
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_IngressServicePoolMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_IngressServicePoolMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_IngressServicePoolMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_IngressServicePoolMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) GetPgNum() uint32 {
	if m != nil {
		return m.PgNum
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) GetSpNum() uint32 {
	if m != nil {
		return m.SpNum
	}
	return 0
}

// Egress CoS queue number to egress service pool map entry.
type NodeConfigParams_QosConfig_EgressServicePoolMapping struct {
	QNum  uint32 `protobuf:"varint,1,opt,name=q_num,json=qNum,proto3" json:"q_num,omitempty"`
	SpNum uint32 `protobuf:"varint,2,opt,name=sp_num,json=spNum,proto3" json:"sp_num,omitempty"`
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) Reset() {
	*m = NodeConfigParams_QosConfig_EgressServicePoolMapping{}
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) String() string {
	return proto.CompactTextString(m)
}
func (*NodeConfigParams_QosConfig_EgressServicePoolMapping) ProtoMessage() {}
func (*NodeConfigParams_QosConfig_EgressServicePoolMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{2, 2, 7}
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfigParams_QosConfig_EgressServicePoolMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfigParams_QosConfig_EgressServicePoolMapping.Merge(m, src)
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfigParams_QosConfig_EgressServicePoolMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfigParams_QosConfig_EgressServicePoolMapping proto.InternalMessageInfo

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) GetQNum() uint32 {
	if m != nil {
		return m.QNum
	}
	return 0
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) GetSpNum() uint32 {
	if m != nil {
		return m.SpNum
	}
	return 0
}

// Flow-related parameters for the ports (singleton and trunk ports).
type PortFlowParams struct {
}

func (m *PortFlowParams) Reset()         { *m = PortFlowParams{} }
func (m *PortFlowParams) String() string { return proto.CompactTextString(m) }
func (*PortFlowParams) ProtoMessage()    {}
func (*PortFlowParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{3}
}
func (m *PortFlowParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortFlowParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortFlowParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortFlowParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortFlowParams.Merge(m, src)
}
func (m *PortFlowParams) XXX_Size() int {
	return m.Size()
}
func (m *PortFlowParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PortFlowParams.DiscardUnknown(m)
}

var xxx_messageInfo_PortFlowParams proto.InternalMessageInfo

// Config-related parameters for the ports (singleton and trunk ports).
type PortConfigParams struct {
	// The configured admin state for this port.
	AdminState AdminState `protobuf:"varint,1,opt,name=admin_state,json=adminState,proto3,enum=stratum.hal.AdminState" json:"admin_state,omitempty"`
	// The per port MTU (aka max frame size) for this port.
	Mtu int32 `protobuf:"varint,2,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Whether autoneg is enabled for this port.
	Autoneg TriState `protobuf:"varint,3,opt,name=autoneg,proto3,enum=stratum.hal.TriState" json:"autoneg,omitempty"`
	// The per port hash config for this port.
	HashConfig *PortConfigParams_HashConfig `protobuf:"bytes,4,opt,name=hash_config,json=hashConfig,proto3" json:"hash_config,omitempty"`
	// The modulation type used for the port. Required for some platforms.
	ModulationType PortConfigParams_ModulationType `protobuf:"varint,5,opt,name=modulation_type,json=modulationType,proto3,enum=stratum.hal.PortConfigParams_ModulationType" json:"modulation_type,omitempty"`
	// FEC operational mode
	FecMode FecMode `protobuf:"varint,6,opt,name=fec_mode,json=fecMode,proto3,enum=stratum.hal.FecMode" json:"fec_mode,omitempty"`
	// The configured mac address for this port.
	MacAddress *MacAddress `protobuf:"bytes,7,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// The configured loopback state for this port.
	LoopbackMode LoopbackState `protobuf:"varint,8,opt,name=loopback_mode,json=loopbackMode,proto3,enum=stratum.hal.LoopbackState" json:"loopback_mode,omitempty"`
}

func (m *PortConfigParams) Reset()         { *m = PortConfigParams{} }
func (m *PortConfigParams) String() string { return proto.CompactTextString(m) }
func (*PortConfigParams) ProtoMessage()    {}
func (*PortConfigParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{4}
}
func (m *PortConfigParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortConfigParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortConfigParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortConfigParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortConfigParams.Merge(m, src)
}
func (m *PortConfigParams) XXX_Size() int {
	return m.Size()
}
func (m *PortConfigParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PortConfigParams.DiscardUnknown(m)
}

var xxx_messageInfo_PortConfigParams proto.InternalMessageInfo

func (m *PortConfigParams) GetAdminState() AdminState {
	if m != nil {
		return m.AdminState
	}
	return AdminState_ADMIN_STATE_UNKNOWN
}

func (m *PortConfigParams) GetMtu() int32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *PortConfigParams) GetAutoneg() TriState {
	if m != nil {
		return m.Autoneg
	}
	return TriState_TRI_STATE_UNKNOWN
}

func (m *PortConfigParams) GetHashConfig() *PortConfigParams_HashConfig {
	if m != nil {
		return m.HashConfig
	}
	return nil
}

func (m *PortConfigParams) GetModulationType() PortConfigParams_ModulationType {
	if m != nil {
		return m.ModulationType
	}
	return PortConfigParams_PORT_MODULATION_UNKNOWN
}

func (m *PortConfigParams) GetFecMode() FecMode {
	if m != nil {
		return m.FecMode
	}
	return FecMode_FEC_MODE_UNKNOWN
}

func (m *PortConfigParams) GetMacAddress() *MacAddress {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *PortConfigParams) GetLoopbackMode() LoopbackState {
	if m != nil {
		return m.LoopbackMode
	}
	return LoopbackState_LOOPBACK_STATE_UNKNOWN
}

// Per port hash config. Most of the hash configuration is given per node.
// These are the only hash config we need to provide per node, for ports that
// are part of a trunk/lag or ECMP group.
type PortConfigParams_HashConfig struct {
	// TODO(unknown): Instead of hash_select, we need a better way. this is
	// RTAG7 specific. Maybe based on the port type?
	Rtag7EcmpHashSelect int32 `protobuf:"varint,1,opt,name=rtag7_ecmp_hash_select,json=rtag7EcmpHashSelect,proto3" json:"rtag7_ecmp_hash_select,omitempty"`
	Rtag7LagHashSelect  int32 `protobuf:"varint,2,opt,name=rtag7_lag_hash_select,json=rtag7LagHashSelect,proto3" json:"rtag7_lag_hash_select,omitempty"`
}

func (m *PortConfigParams_HashConfig) Reset()         { *m = PortConfigParams_HashConfig{} }
func (m *PortConfigParams_HashConfig) String() string { return proto.CompactTextString(m) }
func (*PortConfigParams_HashConfig) ProtoMessage()    {}
func (*PortConfigParams_HashConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{4, 0}
}
func (m *PortConfigParams_HashConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortConfigParams_HashConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortConfigParams_HashConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortConfigParams_HashConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortConfigParams_HashConfig.Merge(m, src)
}
func (m *PortConfigParams_HashConfig) XXX_Size() int {
	return m.Size()
}
func (m *PortConfigParams_HashConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PortConfigParams_HashConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PortConfigParams_HashConfig proto.InternalMessageInfo

func (m *PortConfigParams_HashConfig) GetRtag7EcmpHashSelect() int32 {
	if m != nil {
		return m.Rtag7EcmpHashSelect
	}
	return 0
}

func (m *PortConfigParams_HashConfig) GetRtag7LagHashSelect() int32 {
	if m != nil {
		return m.Rtag7LagHashSelect
	}
	return 0
}

// Chassis uniquely identifies a switch with a single management interface,
// one or more slots (aka linecards), and one or more switching nodes (aka
// chips) on each linecard.
// NOTE: There is no need to specifiy a unique ID for chassis. Also, there
// is no flow-related parameters specified for the chassis. Flow-related
// parameters only apply to nodes and ports, as specified in this section.
type Chassis struct {
	// The chassis platforms. Required for any platform-specific code.
	Platform Platform `protobuf:"varint,1,opt,name=platform,proto3,enum=stratum.hal.Platform" json:"platform,omitempty"`
	// An optional arbitrary name for the chassis. WILL NOT BE PARSED.
	// Example: ju1u1t1.cbf97.net.google.com.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Parameters configured for the entire chassis when config is pushed to the
	// the switch.
	ConfigParams *ChassisConfigParams `protobuf:"bytes,3,opt,name=config_params,json=configParams,proto3" json:"config_params,omitempty"`
}

func (m *Chassis) Reset()         { *m = Chassis{} }
func (m *Chassis) String() string { return proto.CompactTextString(m) }
func (*Chassis) ProtoMessage()    {}
func (*Chassis) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{5}
}
func (m *Chassis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chassis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chassis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chassis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chassis.Merge(m, src)
}
func (m *Chassis) XXX_Size() int {
	return m.Size()
}
func (m *Chassis) XXX_DiscardUnknown() {
	xxx_messageInfo_Chassis.DiscardUnknown(m)
}

var xxx_messageInfo_Chassis proto.InternalMessageInfo

func (m *Chassis) GetPlatform() Platform {
	if m != nil {
		return m.Platform
	}
	return Platform_PLT_UNKNOWN
}

func (m *Chassis) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Chassis) GetConfigParams() *ChassisConfigParams {
	if m != nil {
		return m.ConfigParams
	}
	return nil
}

// Node uniquely identifies a single switching node (aka chip) on a chassis
// linecard and all its flow-related and config-related parameters.
type Node struct {
	// The unique ID of the switching node on the chassis as used by the
	// controller.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// An optional arbitrary name for the switching node. WILL NOT BE PARSED.
	// Example: jka1switch.prod.google.com.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The 1-base index of the slot (aka linecard) which this node belongs.
	Slot int32 `protobuf:"varint,3,opt,name=slot,proto3" json:"slot,omitempty"`
	// The optional 1-base index of the node within the chassis. The value
	// must be in {1..N}, where N is the number of chips on the chassis. This
	// index is not necessarily in the model. The stack can use this internally
	// to index the nodes.
	Index int32 `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	// Flow-related parameters for the switching nodes.
	FlowParams *NodeFlowParams `protobuf:"bytes,5,opt,name=flow_params,json=flowParams,proto3" json:"flow_params,omitempty"`
	// Parameters configured for switching node when config is pushed to the
	// the switch.
	ConfigParams *NodeConfigParams `protobuf:"bytes,6,opt,name=config_params,json=configParams,proto3" json:"config_params,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{6}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *Node) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Node) GetFlowParams() *NodeFlowParams {
	if m != nil {
		return m.FlowParams
	}
	return nil
}

func (m *Node) GetConfigParams() *NodeConfigParams {
	if m != nil {
		return m.ConfigParams
	}
	return nil
}

// SingletonPort uniquely identifies a single physical port on a single chassis
// and all its flow-related and config-related parameters.
// NOTE: Each implementation of SwitchInterface class is assumed to be able to
// translate a SingletonPort to any internal presentation of port used by the
// class. For example:
// SaiSwitch: An implementation of SwitchInterface based on SAI. This class
//            translates SingletonPort to SAI port of type sai_object_id_t
//            and viceversa.
// BcmSwitch: An implementation of SwitchInterface that uses BCM SDK directly.
//            This class translates SingletonPort to a tuple of
//            (int unit, bcm_port_t port) and viceversa.
type SingletonPort struct {
	// The unique ID of the singleton port. Used for operations which need a
	// single unique integer ID for each port (e.g. flow programming). Note that
	// all the singleton and trunk ports use a common range of integer IDs. So,
	// using the same integer ID for a singleton port and a trunk port is not
	// allowed.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// An optional arbitrary name for the singleton port. WILL NOT BE
	// PARSED. Example: "ju1u1.xyz99.net.google.com:ce-1/32". Used only for
	// logging purposes.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The 1-base index of the slot (aka linecard) of the port.
	Slot int32 `protobuf:"varint,3,opt,name=slot,proto3" json:"slot,omitempty"`
	// The 1-base index of the singleton port on the slot.
	Port int32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	// The 1-base channel index (only if the port is channelized). Absence or
	// zero means non-channelized.
	Channel int32 `protobuf:"varint,5,opt,name=channel,proto3" json:"channel,omitempty"`
	// The speed of the ports.
	SpeedBps uint64 `protobuf:"varint,6,opt,name=speed_bps,json=speedBps,proto3" json:"speed_bps,omitempty"`
	// The id of the corresponding node that the port belongs to.
	Node uint64 `protobuf:"varint,9,opt,name=node,proto3" json:"node,omitempty"`
	// Flow-related parameters used when SingletonPort message is used in flow
	// programming related operations.
	FlowParams *PortFlowParams `protobuf:"bytes,7,opt,name=flow_params,json=flowParams,proto3" json:"flow_params,omitempty"`
	// Parameters configured for each singleton port when config is pushed to the
	// the switch.
	ConfigParams *PortConfigParams `protobuf:"bytes,8,opt,name=config_params,json=configParams,proto3" json:"config_params,omitempty"`
}

func (m *SingletonPort) Reset()         { *m = SingletonPort{} }
func (m *SingletonPort) String() string { return proto.CompactTextString(m) }
func (*SingletonPort) ProtoMessage()    {}
func (*SingletonPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{7}
}
func (m *SingletonPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingletonPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingletonPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingletonPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingletonPort.Merge(m, src)
}
func (m *SingletonPort) XXX_Size() int {
	return m.Size()
}
func (m *SingletonPort) XXX_DiscardUnknown() {
	xxx_messageInfo_SingletonPort.DiscardUnknown(m)
}

var xxx_messageInfo_SingletonPort proto.InternalMessageInfo

func (m *SingletonPort) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SingletonPort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SingletonPort) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *SingletonPort) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SingletonPort) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *SingletonPort) GetSpeedBps() uint64 {
	if m != nil {
		return m.SpeedBps
	}
	return 0
}

func (m *SingletonPort) GetNode() uint64 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *SingletonPort) GetFlowParams() *PortFlowParams {
	if m != nil {
		return m.FlowParams
	}
	return nil
}

func (m *SingletonPort) GetConfigParams() *PortConfigParams {
	if m != nil {
		return m.ConfigParams
	}
	return nil
}

// OpticalNetworkInterface uniquely identifies a single physical optical
// network interface on a single chassis.
type OpticalNetworkInterface struct {
	// The unique optical network interface ID.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// An optional arbitrary name for the optical port. WILL NOT BE PARSED.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The 1-based module index of this port.
	Module int32 `protobuf:"varint,3,opt,name=module,proto3" json:"module,omitempty"`
	// The 1-based network interface index of this port.
	NetworkInterface int32 `protobuf:"varint,4,opt,name=network_interface,json=networkInterface,proto3" json:"network_interface,omitempty"`
	// Optical channel frequency in Hz.
	Frequency uint64 `protobuf:"varint,5,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// Target output optical power level of the optical channel, expressed in
	// increments of 0.01 decibel-milliwats.
	TargetOutputPower float64 `protobuf:"fixed64,6,opt,name=target_output_power,json=targetOutputPower,proto3" json:"target_output_power,omitempty"`
	// Optical channel operational mode.
	OperationalMode uint64 `protobuf:"varint,7,opt,name=operational_mode,json=operationalMode,proto3" json:"operational_mode,omitempty"`
	// Optical channel line port value.
	LinePort string `protobuf:"bytes,8,opt,name=line_port,json=linePort,proto3" json:"line_port,omitempty"`
}

func (m *OpticalNetworkInterface) Reset()         { *m = OpticalNetworkInterface{} }
func (m *OpticalNetworkInterface) String() string { return proto.CompactTextString(m) }
func (*OpticalNetworkInterface) ProtoMessage()    {}
func (*OpticalNetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{8}
}
func (m *OpticalNetworkInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticalNetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticalNetworkInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticalNetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticalNetworkInterface.Merge(m, src)
}
func (m *OpticalNetworkInterface) XXX_Size() int {
	return m.Size()
}
func (m *OpticalNetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticalNetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_OpticalNetworkInterface proto.InternalMessageInfo

func (m *OpticalNetworkInterface) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OpticalNetworkInterface) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpticalNetworkInterface) GetModule() int32 {
	if m != nil {
		return m.Module
	}
	return 0
}

func (m *OpticalNetworkInterface) GetNetworkInterface() int32 {
	if m != nil {
		return m.NetworkInterface
	}
	return 0
}

func (m *OpticalNetworkInterface) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *OpticalNetworkInterface) GetTargetOutputPower() float64 {
	if m != nil {
		return m.TargetOutputPower
	}
	return 0
}

func (m *OpticalNetworkInterface) GetOperationalMode() uint64 {
	if m != nil {
		return m.OperationalMode
	}
	return 0
}

func (m *OpticalNetworkInterface) GetLinePort() string {
	if m != nil {
		return m.LinePort
	}
	return ""
}

// TrunkPort uniquely identifies a single trunk port on a single chassis and
// all its flow-related and config-related parameters. This message is the
// only message we will use to specify trunk ports in the HAL and avoid
// defining any other message to specify trunks of any sort.
type TrunkPort struct {
	// The unique ID of the trunk port. Used for operations which need a
	// single unique integer ID for each port (e.g. flow programming). Note that
	// all the singleton and trunk ports use a common range of integer IDs. So,
	// using the same integer ID for a singleton port and a trunk port is not
	// allowed.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// An optional arbitrary name for the trunk port. WILL NOT BE PARSED.
	// Example: trk-df101s1i1.cbf96-2.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The id of the corresponding node that the trunk belongs to.
	Node uint64 `protobuf:"varint,3,opt,name=node,proto3" json:"node,omitempty"`
	// The type of the trunk.
	Type TrunkPort_TrunkType `protobuf:"varint,4,opt,name=type,proto3,enum=stratum.hal.TrunkPort_TrunkType" json:"type,omitempty"`
	// The id of the SingletonPorts or TrunkPorts members. This list can be empty
	// for a LACP trunk but cannot be empty for STATIC trunks.
	Members []uint32 `protobuf:"varint,5,rep,packed,name=members,proto3" json:"members,omitempty"`
	// Flow-related parameters used when TrunkPort message is used in flow
	// programming related operations.
	FlowParams *PortFlowParams `protobuf:"bytes,6,opt,name=flow_params,json=flowParams,proto3" json:"flow_params,omitempty"`
	// Parameters configured for each trunk port when config is pushed to the
	// the switch.
	ConfigParams *PortConfigParams `protobuf:"bytes,7,opt,name=config_params,json=configParams,proto3" json:"config_params,omitempty"`
}

func (m *TrunkPort) Reset()         { *m = TrunkPort{} }
func (m *TrunkPort) String() string { return proto.CompactTextString(m) }
func (*TrunkPort) ProtoMessage()    {}
func (*TrunkPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{9}
}
func (m *TrunkPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrunkPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrunkPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrunkPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrunkPort.Merge(m, src)
}
func (m *TrunkPort) XXX_Size() int {
	return m.Size()
}
func (m *TrunkPort) XXX_DiscardUnknown() {
	xxx_messageInfo_TrunkPort.DiscardUnknown(m)
}

var xxx_messageInfo_TrunkPort proto.InternalMessageInfo

func (m *TrunkPort) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrunkPort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TrunkPort) GetNode() uint64 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *TrunkPort) GetType() TrunkPort_TrunkType {
	if m != nil {
		return m.Type
	}
	return TrunkPort_UNKNOWN_TRUNK
}

func (m *TrunkPort) GetMembers() []uint32 {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *TrunkPort) GetFlowParams() *PortFlowParams {
	if m != nil {
		return m.FlowParams
	}
	return nil
}

func (m *TrunkPort) GetConfigParams() *PortConfigParams {
	if m != nil {
		return m.ConfigParams
	}
	return nil
}

// PortGroup uniquely identifies an ECMP/WCMP port group.
type PortGroup struct {
	// The unique ID of the port group used for flow programming.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// An optional arbitrary name for the port group. WILL NOT BE PARSED.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The port group members.
	Members []*PortGroup_PortGroupMember `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *PortGroup) Reset()         { *m = PortGroup{} }
func (m *PortGroup) String() string { return proto.CompactTextString(m) }
func (*PortGroup) ProtoMessage()    {}
func (*PortGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{10}
}
func (m *PortGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortGroup.Merge(m, src)
}
func (m *PortGroup) XXX_Size() int {
	return m.Size()
}
func (m *PortGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_PortGroup.DiscardUnknown(m)
}

var xxx_messageInfo_PortGroup proto.InternalMessageInfo

func (m *PortGroup) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PortGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortGroup) GetMembers() []*PortGroup_PortGroupMember {
	if m != nil {
		return m.Members
	}
	return nil
}

type PortGroup_PortGroupMember struct {
	// The id of the singleton port member.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The weight (in WCMP mode).
	Weight int32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *PortGroup_PortGroupMember) Reset()         { *m = PortGroup_PortGroupMember{} }
func (m *PortGroup_PortGroupMember) String() string { return proto.CompactTextString(m) }
func (*PortGroup_PortGroupMember) ProtoMessage()    {}
func (*PortGroup_PortGroupMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{10, 0}
}
func (m *PortGroup_PortGroupMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortGroup_PortGroupMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortGroup_PortGroupMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortGroup_PortGroupMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortGroup_PortGroupMember.Merge(m, src)
}
func (m *PortGroup_PortGroupMember) XXX_Size() int {
	return m.Size()
}
func (m *PortGroup_PortGroupMember) XXX_DiscardUnknown() {
	xxx_messageInfo_PortGroup_PortGroupMember.DiscardUnknown(m)
}

var xxx_messageInfo_PortGroup_PortGroupMember proto.InternalMessageInfo

func (m *PortGroup_PortGroupMember) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PortGroup_PortGroupMember) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Config specific to Google-build chassis.
type GoogleConfig struct {
	// The BcmChassisMap id. Only needed if the chassis supports more than one
	// chassis map.
	BcmChassisMapId string `protobuf:"bytes,1,opt,name=bcm_chassis_map_id,json=bcmChassisMapId,proto3" json:"bcm_chassis_map_id,omitempty"`
	// Maps from the index of the nodes (1-based) to all the configs related to
	// that specific node.
	NodeIdToKnetConfig      map[uint64]*GoogleConfig_BcmKnetConfig      `protobuf:"bytes,2,rep,name=node_id_to_knet_config,json=nodeIdToKnetConfig,proto3" json:"node_id_to_knet_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToRxConfig        map[uint64]*GoogleConfig_BcmRxConfig        `protobuf:"bytes,3,rep,name=node_id_to_rx_config,json=nodeIdToRxConfig,proto3" json:"node_id_to_rx_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToTxConfig        map[uint64]*GoogleConfig_BcmTxConfig        `protobuf:"bytes,4,rep,name=node_id_to_tx_config,json=nodeIdToTxConfig,proto3" json:"node_id_to_tx_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToRateLimitConfig map[uint64]*GoogleConfig_BcmRateLimitConfig `protobuf:"bytes,5,rep,name=node_id_to_rate_limit_config,json=nodeIdToRateLimitConfig,proto3" json:"node_id_to_rate_limit_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToBufferConfig    map[uint64]*GoogleConfig_BcmBufferConfig    `protobuf:"bytes,6,rep,name=node_id_to_buffer_config,json=nodeIdToBufferConfig,proto3" json:"node_id_to_buffer_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToRtag7HashConfig map[uint64]*GoogleConfig_BcmRtag7HashConfig `protobuf:"bytes,7,rep,name=node_id_to_rtag7_hash_config,json=nodeIdToRtag7HashConfig,proto3" json:"node_id_to_rtag7_hash_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GoogleConfig) Reset()         { *m = GoogleConfig{} }
func (m *GoogleConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig) ProtoMessage()    {}
func (*GoogleConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11}
}
func (m *GoogleConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig.Merge(m, src)
}
func (m *GoogleConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig proto.InternalMessageInfo

func (m *GoogleConfig) GetBcmChassisMapId() string {
	if m != nil {
		return m.BcmChassisMapId
	}
	return ""
}

func (m *GoogleConfig) GetNodeIdToKnetConfig() map[uint64]*GoogleConfig_BcmKnetConfig {
	if m != nil {
		return m.NodeIdToKnetConfig
	}
	return nil
}

func (m *GoogleConfig) GetNodeIdToRxConfig() map[uint64]*GoogleConfig_BcmRxConfig {
	if m != nil {
		return m.NodeIdToRxConfig
	}
	return nil
}

func (m *GoogleConfig) GetNodeIdToTxConfig() map[uint64]*GoogleConfig_BcmTxConfig {
	if m != nil {
		return m.NodeIdToTxConfig
	}
	return nil
}

func (m *GoogleConfig) GetNodeIdToRateLimitConfig() map[uint64]*GoogleConfig_BcmRateLimitConfig {
	if m != nil {
		return m.NodeIdToRateLimitConfig
	}
	return nil
}

func (m *GoogleConfig) GetNodeIdToBufferConfig() map[uint64]*GoogleConfig_BcmBufferConfig {
	if m != nil {
		return m.NodeIdToBufferConfig
	}
	return nil
}

func (m *GoogleConfig) GetNodeIdToRtag7HashConfig() map[uint64]*GoogleConfig_BcmRtag7HashConfig {
	if m != nil {
		return m.NodeIdToRtag7HashConfig
	}
	return nil
}

// This message encapsulates all the info required to setup KNET interfaces
// on a specific node.
type GoogleConfig_BcmKnetConfig struct {
	KnetIntfConfigs []*GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig `protobuf:"bytes,1,rep,name=knet_intf_configs,json=knetIntfConfigs,proto3" json:"knet_intf_configs,omitempty"`
}

func (m *GoogleConfig_BcmKnetConfig) Reset()         { *m = GoogleConfig_BcmKnetConfig{} }
func (m *GoogleConfig_BcmKnetConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmKnetConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmKnetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 0}
}
func (m *GoogleConfig_BcmKnetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmKnetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmKnetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmKnetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmKnetConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmKnetConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmKnetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmKnetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmKnetConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmKnetConfig) GetKnetIntfConfigs() []*GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig {
	if m != nil {
		return m.KnetIntfConfigs
	}
	return nil
}

// KNET config for a single KNET interface on a node.
type GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig struct {
	Mtu      int32                           `protobuf:"varint,1,opt,name=mtu,proto3" json:"mtu,omitempty"`
	CpuQueue int32                           `protobuf:"varint,2,opt,name=cpu_queue,json=cpuQueue,proto3" json:"cpu_queue,omitempty"`
	Vlan     int32                           `protobuf:"varint,3,opt,name=vlan,proto3" json:"vlan,omitempty"`
	Purpose  GoogleConfig_BcmKnetIntfPurpose `protobuf:"varint,4,opt,name=purpose,proto3,enum=stratum.hal.GoogleConfig_BcmKnetIntfPurpose" json:"purpose,omitempty"`
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) Reset() {
	*m = GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig{}
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) ProtoMessage() {}
func (*GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 0, 0}
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) GetMtu() int32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) GetCpuQueue() int32 {
	if m != nil {
		return m.CpuQueue
	}
	return 0
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) GetVlan() int32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) GetPurpose() GoogleConfig_BcmKnetIntfPurpose {
	if m != nil {
		return m.Purpose
	}
	return GoogleConfig_BCM_KNET_INTF_PURPOSE_UNKNOWN
}

// BcmRxConfig encapsulates all the data required to fully configure RX on a
// unit. This is just a proto wrapper around BcmSdkInterface::RxConfig.
type GoogleConfig_BcmRxConfig struct {
	// The RX pool size in packets. If non-positive, default will be used.
	RxPoolPktCount int32 `protobuf:"varint,1,opt,name=rx_pool_pkt_count,json=rxPoolPktCount,proto3" json:"rx_pool_pkt_count,omitempty"`
	// Bytes per packet in RX pool. If non-positive, default will be used.
	RxPoolBytesPerPkt int32 `protobuf:"varint,2,opt,name=rx_pool_bytes_per_pkt,json=rxPoolBytesPerPkt,proto3" json:"rx_pool_bytes_per_pkt,omitempty"`
	// Max packet size in bytes. If non-positive, default will be used.
	MaxPktSizeBytes int32 `protobuf:"varint,3,opt,name=max_pkt_size_bytes,json=maxPktSizeBytes,proto3" json:"max_pkt_size_bytes,omitempty"`
	// Packets per chain. If non-positive, default will be used.
	PktsPerChain int32 `protobuf:"varint,4,opt,name=pkts_per_chain,json=pktsPerChain,proto3" json:"pkts_per_chain,omitempty"`
	// Global rate limit in pps. If not given , we set no limit. Note that this
	// limit can be overwritten by the value given in BcmRateLimitConfig.
	MaxRatePps int32 `protobuf:"varint,5,opt,name=max_rate_pps,json=maxRatePps,proto3" json:"max_rate_pps,omitempty"`
	// Max # of pakcet received in single burst. If not given, we set no limit.
	// Note that this limit can be overwritten by the value given in
	// BcmRateLimitConfig.
	MaxBurstPkts int32 `protobuf:"varint,6,opt,name=max_burst_pkts,json=maxBurstPkts,proto3" json:"max_burst_pkts,omitempty"`
	// Are we using interrupts to generate RX callback?
	UseInterrupt bool `protobuf:"varint,7,opt,name=use_interrupt,json=useInterrupt,proto3" json:"use_interrupt,omitempty"`
	// Map from DMA channel (0-based) to DMA channel config given by
	// BcmDmaChannelConfig.
	DmaChannelConfigs map[int32]*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig `protobuf:"bytes,8,rep,name=dma_channel_configs,json=dmaChannelConfigs,proto3" json:"dma_channel_configs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GoogleConfig_BcmRxConfig) Reset()         { *m = GoogleConfig_BcmRxConfig{} }
func (m *GoogleConfig_BcmRxConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmRxConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmRxConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 1}
}
func (m *GoogleConfig_BcmRxConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRxConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRxConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRxConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRxConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRxConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRxConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRxConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRxConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRxConfig) GetRxPoolPktCount() int32 {
	if m != nil {
		return m.RxPoolPktCount
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetRxPoolBytesPerPkt() int32 {
	if m != nil {
		return m.RxPoolBytesPerPkt
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetMaxPktSizeBytes() int32 {
	if m != nil {
		return m.MaxPktSizeBytes
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetPktsPerChain() int32 {
	if m != nil {
		return m.PktsPerChain
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetMaxRatePps() int32 {
	if m != nil {
		return m.MaxRatePps
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetMaxBurstPkts() int32 {
	if m != nil {
		return m.MaxBurstPkts
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig) GetUseInterrupt() bool {
	if m != nil {
		return m.UseInterrupt
	}
	return false
}

func (m *GoogleConfig_BcmRxConfig) GetDmaChannelConfigs() map[int32]*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig {
	if m != nil {
		return m.DmaChannelConfigs
	}
	return nil
}

// BcmDmaChannelConfig encapsulates all the data required to configure an
// RX DMA channel.
type GoogleConfig_BcmRxConfig_BcmDmaChannelConfig struct {
	// The number of chains (DVs).
	Chains int32 `protobuf:"varint,1,opt,name=chains,proto3" json:"chains,omitempty"`
	// Strip CRC from packets?
	StripCrc bool `protobuf:"varint,2,opt,name=strip_crc,json=stripCrc,proto3" json:"strip_crc,omitempty"`
	// Strip VLAN tag from packets?
	StripVlan bool `protobuf:"varint,3,opt,name=strip_vlan,json=stripVlan,proto3" json:"strip_vlan,omitempty"`
	// Accept packets larger than bufsize?
	OversizedPacketsOk bool `protobuf:"varint,4,opt,name=oversized_packets_ok,json=oversizedPacketsOk,proto3" json:"oversized_packets_ok,omitempty"`
	// Do not parse received packets?
	NoPktParsing bool `protobuf:"varint,5,opt,name=no_pkt_parsing,json=noPktParsing,proto3" json:"no_pkt_parsing,omitempty"`
	// The set of COS (classes of service) supported.
	CosSet []int32 `protobuf:"varint,6,rep,packed,name=cos_set,json=cosSet,proto3" json:"cos_set,omitempty"`
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) Reset() {
	*m = GoogleConfig_BcmRxConfig_BcmDmaChannelConfig{}
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 1, 0}
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRxConfig_BcmDmaChannelConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRxConfig_BcmDmaChannelConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRxConfig_BcmDmaChannelConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRxConfig_BcmDmaChannelConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetChains() int32 {
	if m != nil {
		return m.Chains
	}
	return 0
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetStripCrc() bool {
	if m != nil {
		return m.StripCrc
	}
	return false
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetStripVlan() bool {
	if m != nil {
		return m.StripVlan
	}
	return false
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetOversizedPacketsOk() bool {
	if m != nil {
		return m.OversizedPacketsOk
	}
	return false
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetNoPktParsing() bool {
	if m != nil {
		return m.NoPktParsing
	}
	return false
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) GetCosSet() []int32 {
	if m != nil {
		return m.CosSet
	}
	return nil
}

type GoogleConfig_BcmTxConfig struct {
}

func (m *GoogleConfig_BcmTxConfig) Reset()         { *m = GoogleConfig_BcmTxConfig{} }
func (m *GoogleConfig_BcmTxConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmTxConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmTxConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 2}
}
func (m *GoogleConfig_BcmTxConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmTxConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmTxConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmTxConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmTxConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmTxConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmTxConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmTxConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmTxConfig proto.InternalMessageInfo

// BcmRateLimitConfig specifies rate limit settings for a unit. This is just
// a proto wrapper around BcmSdkInterface::RateLimitConfig;
type GoogleConfig_BcmRateLimitConfig struct {
	// Global rate limit in pps. If not given , we set no limit.
	MaxRatePps int32 `protobuf:"varint,1,opt,name=max_rate_pps,json=maxRatePps,proto3" json:"max_rate_pps,omitempty"`
	// Max # of pakcet received in single burst. If not given, we set no limit.
	MaxBurstPkts int32 `protobuf:"varint,2,opt,name=max_burst_pkts,json=maxBurstPkts,proto3" json:"max_burst_pkts,omitempty"`
	// Map from cos (0-based) to its rate limit config given by
	// BcmPerCosRateLimitConfig.
	PerCosRateLimitConfigs map[int32]*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig `protobuf:"bytes,3,rep,name=per_cos_rate_limit_configs,json=perCosRateLimitConfigs,proto3" json:"per_cos_rate_limit_configs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GoogleConfig_BcmRateLimitConfig) Reset()         { *m = GoogleConfig_BcmRateLimitConfig{} }
func (m *GoogleConfig_BcmRateLimitConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmRateLimitConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmRateLimitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 3}
}
func (m *GoogleConfig_BcmRateLimitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRateLimitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRateLimitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRateLimitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRateLimitConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRateLimitConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRateLimitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRateLimitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRateLimitConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRateLimitConfig) GetMaxRatePps() int32 {
	if m != nil {
		return m.MaxRatePps
	}
	return 0
}

func (m *GoogleConfig_BcmRateLimitConfig) GetMaxBurstPkts() int32 {
	if m != nil {
		return m.MaxBurstPkts
	}
	return 0
}

func (m *GoogleConfig_BcmRateLimitConfig) GetPerCosRateLimitConfigs() map[int32]*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig {
	if m != nil {
		return m.PerCosRateLimitConfigs
	}
	return nil
}

// Specifies rate limit settings for a COS.
type GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig struct {
	// Rate limit for this cos in ppc. If not given, we set no limit.
	MaxRatePps int32 `protobuf:"varint,1,opt,name=max_rate_pps,json=maxRatePps,proto3" json:"max_rate_pps,omitempty"`
	// Max # of pakcet received in single burst for this cos. If not given,
	// we set no limit.
	MaxBurstPkts int32 `protobuf:"varint,2,opt,name=max_burst_pkts,json=maxBurstPkts,proto3" json:"max_burst_pkts,omitempty"`
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) Reset() {
	*m = GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig{}
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 3, 0}
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) GetMaxRatePps() int32 {
	if m != nil {
		return m.MaxRatePps
	}
	return 0
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) GetMaxBurstPkts() int32 {
	if m != nil {
		return m.MaxBurstPkts
	}
	return 0
}

// BcmBufferConfig defines the buffer carving config for a BCM unit.
// TODO(unknown): This still needs modification. Not ready yet.
// TODO(unknown): Add documentation.
type GoogleConfig_BcmBufferConfig struct {
	GlobalHdrmLimit uint32 `protobuf:"varint,1,opt,name=global_hdrm_limit,json=globalHdrmLimit,proto3" json:"global_hdrm_limit,omitempty"`
	PortMin         uint32 `protobuf:"varint,2,opt,name=port_min,json=portMin,proto3" json:"port_min,omitempty"`
}

func (m *GoogleConfig_BcmBufferConfig) Reset()         { *m = GoogleConfig_BcmBufferConfig{} }
func (m *GoogleConfig_BcmBufferConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmBufferConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmBufferConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 4}
}
func (m *GoogleConfig_BcmBufferConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmBufferConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmBufferConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmBufferConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmBufferConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmBufferConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmBufferConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmBufferConfig) GetGlobalHdrmLimit() uint32 {
	if m != nil {
		return m.GlobalHdrmLimit
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig) GetPortMin() uint32 {
	if m != nil {
		return m.PortMin
	}
	return 0
}

type GoogleConfig_BcmBufferConfig_ServicePoolConfig struct {
	SpNum              uint32 `protobuf:"varint,1,opt,name=sp_num,json=spNum,proto3" json:"sp_num,omitempty"`
	MaxIngressBufBytes uint32 `protobuf:"varint,2,opt,name=max_ingress_buf_bytes,json=maxIngressBufBytes,proto3" json:"max_ingress_buf_bytes,omitempty"`
	MaxEgressBufBytes  uint32 `protobuf:"varint,3,opt,name=max_egress_buf_bytes,json=maxEgressBufBytes,proto3" json:"max_egress_buf_bytes,omitempty"`
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) Reset() {
	*m = GoogleConfig_BcmBufferConfig_ServicePoolConfig{}
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmBufferConfig_ServicePoolConfig) ProtoMessage() {}
func (*GoogleConfig_BcmBufferConfig_ServicePoolConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 4, 0}
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmBufferConfig_ServicePoolConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_ServicePoolConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_ServicePoolConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmBufferConfig_ServicePoolConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) GetSpNum() uint32 {
	if m != nil {
		return m.SpNum
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) GetMaxIngressBufBytes() uint32 {
	if m != nil {
		return m.MaxIngressBufBytes
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) GetMaxEgressBufBytes() uint32 {
	if m != nil {
		return m.MaxEgressBufBytes
	}
	return 0
}

type GoogleConfig_BcmBufferConfig_PriorityGroupConig struct {
	PgNum              uint32 `protobuf:"varint,1,opt,name=pg_num,json=pgNum,proto3" json:"pg_num,omitempty"`
	PgMin              uint32 `protobuf:"varint,2,opt,name=pg_min,json=pgMin,proto3" json:"pg_min,omitempty"`
	PgHdrmGlobalEnable uint32 `protobuf:"varint,3,opt,name=pg_hdrm_global_enable,json=pgHdrmGlobalEnable,proto3" json:"pg_hdrm_global_enable,omitempty"`
	PgSharedLimitCell  uint32 `protobuf:"varint,4,opt,name=pg_shared_limit_cell,json=pgSharedLimitCell,proto3" json:"pg_shared_limit_cell,omitempty"`
	PgSharedDynamic    uint32 `protobuf:"varint,5,opt,name=pg_shared_dynamic,json=pgSharedDynamic,proto3" json:"pg_shared_dynamic,omitempty"`
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) Reset() {
	*m = GoogleConfig_BcmBufferConfig_PriorityGroupConig{}
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmBufferConfig_PriorityGroupConig) ProtoMessage() {}
func (*GoogleConfig_BcmBufferConfig_PriorityGroupConig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 4, 1}
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmBufferConfig_PriorityGroupConig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_PriorityGroupConig.Merge(m, src)
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_PriorityGroupConig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmBufferConfig_PriorityGroupConig proto.InternalMessageInfo

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) GetPgNum() uint32 {
	if m != nil {
		return m.PgNum
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) GetPgMin() uint32 {
	if m != nil {
		return m.PgMin
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) GetPgHdrmGlobalEnable() uint32 {
	if m != nil {
		return m.PgHdrmGlobalEnable
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) GetPgSharedLimitCell() uint32 {
	if m != nil {
		return m.PgSharedLimitCell
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) GetPgSharedDynamic() uint32 {
	if m != nil {
		return m.PgSharedDynamic
	}
	return 0
}

type GoogleConfig_BcmBufferConfig_CosqConfig struct {
	QNum                   uint32 `protobuf:"varint,1,opt,name=q_num,json=qNum,proto3" json:"q_num,omitempty"`
	QMin                   uint32 `protobuf:"varint,2,opt,name=q_min,json=qMin,proto3" json:"q_min,omitempty"`
	QLimitEnable           uint32 `protobuf:"varint,3,opt,name=q_limit_enable,json=qLimitEnable,proto3" json:"q_limit_enable,omitempty"`
	QLimitDynamic          uint32 `protobuf:"varint,4,opt,name=q_limit_dynamic,json=qLimitDynamic,proto3" json:"q_limit_dynamic,omitempty"`
	QSharedLimitCell       uint32 `protobuf:"varint,5,opt,name=q_shared_limit_cell,json=qSharedLimitCell,proto3" json:"q_shared_limit_cell,omitempty"`
	QSharedAlphaCell       uint32 `protobuf:"varint,6,opt,name=q_shared_alpha_cell,json=qSharedAlphaCell,proto3" json:"q_shared_alpha_cell,omitempty"`
	QColorLimitDynamicCell uint32 `protobuf:"varint,7,opt,name=q_color_limit_dynamic_cell,json=qColorLimitDynamicCell,proto3" json:"q_color_limit_dynamic_cell,omitempty"`
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) Reset() {
	*m = GoogleConfig_BcmBufferConfig_CosqConfig{}
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmBufferConfig_CosqConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmBufferConfig_CosqConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 4, 2}
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmBufferConfig_CosqConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_CosqConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmBufferConfig_CosqConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmBufferConfig_CosqConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQNum() uint32 {
	if m != nil {
		return m.QNum
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQMin() uint32 {
	if m != nil {
		return m.QMin
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQLimitEnable() uint32 {
	if m != nil {
		return m.QLimitEnable
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQLimitDynamic() uint32 {
	if m != nil {
		return m.QLimitDynamic
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQSharedLimitCell() uint32 {
	if m != nil {
		return m.QSharedLimitCell
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQSharedAlphaCell() uint32 {
	if m != nil {
		return m.QSharedAlphaCell
	}
	return 0
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) GetQColorLimitDynamicCell() uint32 {
	if m != nil {
		return m.QColorLimitDynamicCell
	}
	return 0
}

// BcmRtag7HashConfig defines RTAG7 hash config for a unit.
// TODO(unknown): Add documentation.
type GoogleConfig_BcmRtag7HashConfig struct {
	Description         string                                                `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	HashFunctionConfigs []*GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig `protobuf:"bytes,2,rep,name=hash_function_configs,json=hashFunctionConfigs,proto3" json:"hash_function_configs,omitempty"`
	MacroFlowHashConfig *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig  `protobuf:"bytes,3,opt,name=macro_flow_hash_config,json=macroFlowHashConfig,proto3" json:"macro_flow_hash_config,omitempty"`
	EcmpHashConfig      *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig    `protobuf:"bytes,4,opt,name=ecmp_hash_config,json=ecmpHashConfig,proto3" json:"ecmp_hash_config,omitempty"`
	LagHashConfig       *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig    `protobuf:"bytes,5,opt,name=lag_hash_config,json=lagHashConfig,proto3" json:"lag_hash_config,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig) Reset()         { *m = GoogleConfig_BcmRtag7HashConfig{} }
func (m *GoogleConfig_BcmRtag7HashConfig) String() string { return proto.CompactTextString(m) }
func (*GoogleConfig_BcmRtag7HashConfig) ProtoMessage()    {}
func (*GoogleConfig_BcmRtag7HashConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5}
}
func (m *GoogleConfig_BcmRtag7HashConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GoogleConfig_BcmRtag7HashConfig) GetHashFunctionConfigs() []*GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig {
	if m != nil {
		return m.HashFunctionConfigs
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig) GetMacroFlowHashConfig() *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig {
	if m != nil {
		return m.MacroFlowHashConfig
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig) GetEcmpHashConfig() *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig {
	if m != nil {
		return m.EcmpHashConfig
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig) GetLagHashConfig() *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig {
	if m != nil {
		return m.LagHashConfig
	}
	return nil
}

type GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig struct {
	Block        GoogleConfig_BcmRtag7HashConfig_HashBlock   `protobuf:"varint,1,opt,name=block,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashBlock" json:"block,omitempty"`
	Seed         int32                                       `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
	Fields       []GoogleConfig_BcmRtag7HashConfig_HashField `protobuf:"varint,3,rep,packed,name=fields,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashField" json:"fields,omitempty"`
	Polynomial_0 GoogleConfig_BcmRtag7HashConfig_Polynomial  `protobuf:"varint,4,opt,name=polynomial_0,json=polynomial0,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_Polynomial" json:"polynomial_0,omitempty"`
	Polynomial_1 GoogleConfig_BcmRtag7HashConfig_Polynomial  `protobuf:"varint,5,opt,name=polynomial_1,json=polynomial1,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_Polynomial" json:"polynomial_1,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) Reset() {
	*m = GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig{}
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 0}
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) GetBlock() GoogleConfig_BcmRtag7HashConfig_HashBlock {
	if m != nil {
		return m.Block
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_BLOCK
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) GetSeed() int32 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) GetFields() []GoogleConfig_BcmRtag7HashConfig_HashField {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) GetPolynomial_0() GoogleConfig_BcmRtag7HashConfig_Polynomial {
	if m != nil {
		return m.Polynomial_0
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_POLYNOMIAL
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) GetPolynomial_1() GoogleConfig_BcmRtag7HashConfig_Polynomial {
	if m != nil {
		return m.Polynomial_1
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_POLYNOMIAL
}

type GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig struct {
	Polynomial       GoogleConfig_BcmRtag7HashConfig_Polynomial                         `protobuf:"varint,1,opt,name=polynomial,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_Polynomial" json:"polynomial,omitempty"`
	TableConfigs     []*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig `protobuf:"bytes,2,rep,name=table_configs,json=tableConfigs,proto3" json:"table_configs,omitempty"`
	UseMsb_16Bits    bool                                                               `protobuf:"varint,3,opt,name=use_msb_16bits,json=useMsb16bits,proto3" json:"use_msb_16bits,omitempty"`
	RandomizeTable   bool                                                               `protobuf:"varint,4,opt,name=randomize_table,json=randomizeTable,proto3" json:"randomize_table,omitempty"`
	RandomIterations int32                                                              `protobuf:"varint,5,opt,name=random_iterations,json=randomIterations,proto3" json:"random_iterations,omitempty"`
	Seed             int32                                                              `protobuf:"varint,6,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) Reset() {
	*m = GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig{}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 1}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetPolynomial() GoogleConfig_BcmRtag7HashConfig_Polynomial {
	if m != nil {
		return m.Polynomial
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_POLYNOMIAL
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetTableConfigs() []*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig {
	if m != nil {
		return m.TableConfigs
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetUseMsb_16Bits() bool {
	if m != nil {
		return m.UseMsb_16Bits
	}
	return false
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetRandomizeTable() bool {
	if m != nil {
		return m.RandomizeTable
	}
	return false
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetRandomIterations() int32 {
	if m != nil {
		return m.RandomIterations
	}
	return 0
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) GetSeed() int32 {
	if m != nil {
		return m.Seed
	}
	return 0
}

type GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig struct {
	SubBlock   GoogleConfig_BcmRtag7HashConfig_HashSubBlock `protobuf:"varint,1,opt,name=sub_block,json=subBlock,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashSubBlock" json:"sub_block,omitempty"`
	IndexStart int32                                        `protobuf:"varint,2,opt,name=index_start,json=indexStart,proto3" json:"index_start,omitempty"`
	IndexEnd   int32                                        `protobuf:"varint,3,opt,name=index_end,json=indexEnd,proto3" json:"index_end,omitempty"`
	Offset     uint32                                       `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) Reset() {
	*m = GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig{}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 1, 0}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) GetSubBlock() GoogleConfig_BcmRtag7HashConfig_HashSubBlock {
	if m != nil {
		return m.SubBlock
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_SUB_BLOCK
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) GetIndexStart() int32 {
	if m != nil {
		return m.IndexStart
	}
	return 0
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) GetIndexEnd() int32 {
	if m != nil {
		return m.IndexEnd
	}
	return 0
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig struct {
	Block         GoogleConfig_BcmRtag7HashConfig_HashBlock                      `protobuf:"varint,1,opt,name=block,proto3,enum=stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashBlock" json:"block,omitempty"`
	TableConfig_0 *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig `protobuf:"bytes,2,opt,name=table_config_0,json=tableConfig0,proto3" json:"table_config_0,omitempty"`
	TableConfig_1 *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig `protobuf:"bytes,3,opt,name=table_config_1,json=tableConfig1,proto3" json:"table_config_1,omitempty"`
	// RTAG7A and RTAG7B has per port per HashType hash bits selection.
	// Each port can select one of two sets of hash config defined by
	// table_config_0 and table_config_1.
	// Here defines the default value, and it could be overridden by the per
	// port config given in the PortConfigParams.
	PortHashSelect int32 `protobuf:"varint,4,opt,name=port_hash_select,json=portHashSelect,proto3" json:"port_hash_select,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) Reset() {
	*m = GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig{}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 2}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) GetBlock() GoogleConfig_BcmRtag7HashConfig_HashBlock {
	if m != nil {
		return m.Block
	}
	return GoogleConfig_BcmRtag7HashConfig_UNKNOWN_BLOCK
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) GetTableConfig_0() *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig {
	if m != nil {
		return m.TableConfig_0
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) GetTableConfig_1() *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig {
	if m != nil {
		return m.TableConfig_1
	}
	return nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) GetPortHashSelect() int32 {
	if m != nil {
		return m.PortHashSelect
	}
	return 0
}

type GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig struct {
	Offset int32 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// Use macro flow hash. Only applicable to ECMP. If set, offset will be
	// ignored.
	UseMacroFlowHash bool `protobuf:"varint,2,opt,name=use_macro_flow_hash,json=useMacroFlowHash,proto3" json:"use_macro_flow_hash,omitempty"`
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) Reset() {
	*m = GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig{}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) ProtoMessage() {}
func (*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{11, 5, 2, 0}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig.Merge(m, src)
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) XXX_Size() int {
	return m.Size()
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig proto.InternalMessageInfo

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) GetUseMacroFlowHash() bool {
	if m != nil {
		return m.UseMacroFlowHash
	}
	return false
}

// Config specific to Tofino chassis.
type TofinoConfig struct {
	// Maps from the index of the nodes (1-based) to all the configs related to
	// that specific node.
	NodeIdToPortShapingConfig    map[uint64]*TofinoConfig_BfPortShapingConfig       `protobuf:"bytes,1,rep,name=node_id_to_port_shaping_config,json=nodeIdToPortShapingConfig,proto3" json:"node_id_to_port_shaping_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToDeflectOnDropConfigs map[uint64]*TofinoConfig_DeflectOnPacketDropConfig `protobuf:"bytes,2,rep,name=node_id_to_deflect_on_drop_configs,json=nodeIdToDeflectOnDropConfigs,proto3" json:"node_id_to_deflect_on_drop_configs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeIdToQosConfig            map[uint64]*TofinoConfig_TofinoQosConfig           `protobuf:"bytes,3,rep,name=node_id_to_qos_config,json=nodeIdToQosConfig,proto3" json:"node_id_to_qos_config,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TofinoConfig) Reset()         { *m = TofinoConfig{} }
func (m *TofinoConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig) ProtoMessage()    {}
func (*TofinoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12}
}
func (m *TofinoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig.Merge(m, src)
}
func (m *TofinoConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig proto.InternalMessageInfo

func (m *TofinoConfig) GetNodeIdToPortShapingConfig() map[uint64]*TofinoConfig_BfPortShapingConfig {
	if m != nil {
		return m.NodeIdToPortShapingConfig
	}
	return nil
}

func (m *TofinoConfig) GetNodeIdToDeflectOnDropConfigs() map[uint64]*TofinoConfig_DeflectOnPacketDropConfig {
	if m != nil {
		return m.NodeIdToDeflectOnDropConfigs
	}
	return nil
}

func (m *TofinoConfig) GetNodeIdToQosConfig() map[uint64]*TofinoConfig_TofinoQosConfig {
	if m != nil {
		return m.NodeIdToQosConfig
	}
	return nil
}

type TofinoConfig_PacketShape struct {
	RatePps      uint64 `protobuf:"varint,1,opt,name=rate_pps,json=ratePps,proto3" json:"rate_pps,omitempty"`
	BurstPackets uint32 `protobuf:"varint,2,opt,name=burst_packets,json=burstPackets,proto3" json:"burst_packets,omitempty"`
}

func (m *TofinoConfig_PacketShape) Reset()         { *m = TofinoConfig_PacketShape{} }
func (m *TofinoConfig_PacketShape) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_PacketShape) ProtoMessage()    {}
func (*TofinoConfig_PacketShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 0}
}
func (m *TofinoConfig_PacketShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_PacketShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_PacketShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_PacketShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_PacketShape.Merge(m, src)
}
func (m *TofinoConfig_PacketShape) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_PacketShape) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_PacketShape.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_PacketShape proto.InternalMessageInfo

func (m *TofinoConfig_PacketShape) GetRatePps() uint64 {
	if m != nil {
		return m.RatePps
	}
	return 0
}

func (m *TofinoConfig_PacketShape) GetBurstPackets() uint32 {
	if m != nil {
		return m.BurstPackets
	}
	return 0
}

type TofinoConfig_ByteShape struct {
	RateBps    uint64 `protobuf:"varint,1,opt,name=rate_bps,json=rateBps,proto3" json:"rate_bps,omitempty"`
	BurstBytes uint32 `protobuf:"varint,2,opt,name=burst_bytes,json=burstBytes,proto3" json:"burst_bytes,omitempty"`
}

func (m *TofinoConfig_ByteShape) Reset()         { *m = TofinoConfig_ByteShape{} }
func (m *TofinoConfig_ByteShape) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_ByteShape) ProtoMessage()    {}
func (*TofinoConfig_ByteShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 1}
}
func (m *TofinoConfig_ByteShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_ByteShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_ByteShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_ByteShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_ByteShape.Merge(m, src)
}
func (m *TofinoConfig_ByteShape) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_ByteShape) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_ByteShape.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_ByteShape proto.InternalMessageInfo

func (m *TofinoConfig_ByteShape) GetRateBps() uint64 {
	if m != nil {
		return m.RateBps
	}
	return 0
}

func (m *TofinoConfig_ByteShape) GetBurstBytes() uint32 {
	if m != nil {
		return m.BurstBytes
	}
	return 0
}

type TofinoConfig_BfPortShapingConfig struct {
	// Map from port id to its shaping config given by BfPerPortShapingConfig.
	PerPortShapingConfigs map[uint32]*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig `protobuf:"bytes,1,rep,name=per_port_shaping_configs,json=perPortShapingConfigs,proto3" json:"per_port_shaping_configs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TofinoConfig_BfPortShapingConfig) Reset()         { *m = TofinoConfig_BfPortShapingConfig{} }
func (m *TofinoConfig_BfPortShapingConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_BfPortShapingConfig) ProtoMessage()    {}
func (*TofinoConfig_BfPortShapingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 2}
}
func (m *TofinoConfig_BfPortShapingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_BfPortShapingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_BfPortShapingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_BfPortShapingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_BfPortShapingConfig.Merge(m, src)
}
func (m *TofinoConfig_BfPortShapingConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_BfPortShapingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_BfPortShapingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_BfPortShapingConfig proto.InternalMessageInfo

func (m *TofinoConfig_BfPortShapingConfig) GetPerPortShapingConfigs() map[uint32]*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig {
	if m != nil {
		return m.PerPortShapingConfigs
	}
	return nil
}

type TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig struct {
	// Types that are valid to be assigned to Shaping:
	//	*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping
	//	*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping
	Shaping isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping `protobuf_oneof:"shaping"`
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) Reset() {
	*m = TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig{}
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) String() string {
	return proto.CompactTextString(m)
}
func (*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) ProtoMessage() {}
func (*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 2, 0}
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig.Merge(m, src)
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig proto.InternalMessageInfo

type isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping interface {
	isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping struct {
	PacketShaping *TofinoConfig_PacketShape `protobuf:"bytes,1,opt,name=packet_shaping,json=packetShaping,proto3,oneof" json:"packet_shaping,omitempty"`
}
type TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping struct {
	ByteShaping *TofinoConfig_ByteShape `protobuf:"bytes,2,opt,name=byte_shaping,json=byteShaping,proto3,oneof" json:"byte_shaping,omitempty"`
}

func (*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping) isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping() {
}
func (*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping) isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping() {
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) GetShaping() isTofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_Shaping {
	if m != nil {
		return m.Shaping
	}
	return nil
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) GetPacketShaping() *TofinoConfig_PacketShape {
	if x, ok := m.GetShaping().(*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping); ok {
		return x.PacketShaping
	}
	return nil
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) GetByteShaping() *TofinoConfig_ByteShape {
	if x, ok := m.GetShaping().(*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping); ok {
		return x.ByteShaping
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping)(nil),
		(*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping)(nil),
	}
}

// DeflectOnPacketDropConfig specifies the port and queue where dropped
// packets will be deflected to.
type TofinoConfig_DeflectOnPacketDropConfig struct {
	DropTargets []*TofinoConfig_DeflectOnPacketDropConfig_DropTarget `protobuf:"bytes,1,rep,name=drop_targets,json=dropTargets,proto3" json:"drop_targets,omitempty"`
}

func (m *TofinoConfig_DeflectOnPacketDropConfig) Reset() {
	*m = TofinoConfig_DeflectOnPacketDropConfig{}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_DeflectOnPacketDropConfig) ProtoMessage()    {}
func (*TofinoConfig_DeflectOnPacketDropConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 3}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig.Merge(m, src)
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig proto.InternalMessageInfo

func (m *TofinoConfig_DeflectOnPacketDropConfig) GetDropTargets() []*TofinoConfig_DeflectOnPacketDropConfig_DropTarget {
	if m != nil {
		return m.DropTargets
	}
	return nil
}

type TofinoConfig_DeflectOnPacketDropConfig_DropTarget struct {
	// Types that are valid to be assigned to PortType:
	//	*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port
	//	*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort
	PortType isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType `protobuf_oneof:"port_type"`
	Queue    uint32                                                       `protobuf:"varint,3,opt,name=queue,proto3" json:"queue,omitempty"`
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) Reset() {
	*m = TofinoConfig_DeflectOnPacketDropConfig_DropTarget{}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) String() string {
	return proto.CompactTextString(m)
}
func (*TofinoConfig_DeflectOnPacketDropConfig_DropTarget) ProtoMessage() {}
func (*TofinoConfig_DeflectOnPacketDropConfig_DropTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 3, 0}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig_DropTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig_DropTarget.Merge(m, src)
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig_DropTarget.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_DeflectOnPacketDropConfig_DropTarget proto.InternalMessageInfo

type isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType interface {
	isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort struct {
	SdkPort uint32 `protobuf:"varint,2,opt,name=sdk_port,json=sdkPort,proto3,oneof" json:"sdk_port,omitempty"`
}

func (*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port) isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType() {
}
func (*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort) isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType() {
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) GetPortType() isTofinoConfig_DeflectOnPacketDropConfig_DropTarget_PortType {
	if m != nil {
		return m.PortType
	}
	return nil
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) GetPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port); ok {
		return x.Port
	}
	return 0
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) GetSdkPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort); ok {
		return x.SdkPort
	}
	return 0
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) GetQueue() uint32 {
	if m != nil {
		return m.Queue
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TofinoConfig_DeflectOnPacketDropConfig_DropTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port)(nil),
		(*TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort)(nil),
	}
}

// QoS configuration for the traffic manager.
type TofinoConfig_TofinoQosConfig struct {
	PoolConfigs                   []*TofinoConfig_TofinoQosConfig_PoolConfig  `protobuf:"bytes,1,rep,name=pool_configs,json=poolConfigs,proto3" json:"pool_configs,omitempty"`
	PoolColorDropHysteresisGreen  uint32                                      `protobuf:"varint,2,opt,name=pool_color_drop_hysteresis_green,json=poolColorDropHysteresisGreen,proto3" json:"pool_color_drop_hysteresis_green,omitempty"`
	PoolColorDropHysteresisYellow uint32                                      `protobuf:"varint,3,opt,name=pool_color_drop_hysteresis_yellow,json=poolColorDropHysteresisYellow,proto3" json:"pool_color_drop_hysteresis_yellow,omitempty"`
	PoolColorDropHysteresisRed    uint32                                      `protobuf:"varint,4,opt,name=pool_color_drop_hysteresis_red,json=poolColorDropHysteresisRed,proto3" json:"pool_color_drop_hysteresis_red,omitempty"`
	PpgConfigs                    []*TofinoConfig_TofinoQosConfig_PpgConfig   `protobuf:"bytes,5,rep,name=ppg_configs,json=ppgConfigs,proto3" json:"ppg_configs,omitempty"`
	QueueConfigs                  []*TofinoConfig_TofinoQosConfig_QueueConfig `protobuf:"bytes,6,rep,name=queue_configs,json=queueConfigs,proto3" json:"queue_configs,omitempty"`
}

func (m *TofinoConfig_TofinoQosConfig) Reset()         { *m = TofinoConfig_TofinoQosConfig{} }
func (m *TofinoConfig_TofinoQosConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_TofinoQosConfig) ProtoMessage()    {}
func (*TofinoConfig_TofinoQosConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4}
}
func (m *TofinoConfig_TofinoQosConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_TofinoQosConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_TofinoQosConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_TofinoQosConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig.Merge(m, src)
}
func (m *TofinoConfig_TofinoQosConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_TofinoQosConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_TofinoQosConfig proto.InternalMessageInfo

func (m *TofinoConfig_TofinoQosConfig) GetPoolConfigs() []*TofinoConfig_TofinoQosConfig_PoolConfig {
	if m != nil {
		return m.PoolConfigs
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig) GetPoolColorDropHysteresisGreen() uint32 {
	if m != nil {
		return m.PoolColorDropHysteresisGreen
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig) GetPoolColorDropHysteresisYellow() uint32 {
	if m != nil {
		return m.PoolColorDropHysteresisYellow
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig) GetPoolColorDropHysteresisRed() uint32 {
	if m != nil {
		return m.PoolColorDropHysteresisRed
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig) GetPpgConfigs() []*TofinoConfig_TofinoQosConfig_PpgConfig {
	if m != nil {
		return m.PpgConfigs
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig) GetQueueConfigs() []*TofinoConfig_TofinoQosConfig_QueueConfig {
	if m != nil {
		return m.QueueConfigs
	}
	return nil
}

type TofinoConfig_TofinoQosConfig_PoolConfig struct {
	Pool                 TofinoConfig_TofinoQosConfig_ApplicationPool `protobuf:"varint,1,opt,name=pool,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_ApplicationPool" json:"pool,omitempty"`
	PoolSize             uint32                                       `protobuf:"varint,2,opt,name=pool_size,json=poolSize,proto3" json:"pool_size,omitempty"`
	EnableColorDrop      bool                                         `protobuf:"varint,3,opt,name=enable_color_drop,json=enableColorDrop,proto3" json:"enable_color_drop,omitempty"`
	ColorDropLimitGreen  uint32                                       `protobuf:"varint,4,opt,name=color_drop_limit_green,json=colorDropLimitGreen,proto3" json:"color_drop_limit_green,omitempty"`
	ColorDropLimitYellow uint32                                       `protobuf:"varint,5,opt,name=color_drop_limit_yellow,json=colorDropLimitYellow,proto3" json:"color_drop_limit_yellow,omitempty"`
	ColorDropLimitRed    uint32                                       `protobuf:"varint,6,opt,name=color_drop_limit_red,json=colorDropLimitRed,proto3" json:"color_drop_limit_red,omitempty"`
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) Reset() {
	*m = TofinoConfig_TofinoQosConfig_PoolConfig{}
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_TofinoQosConfig_PoolConfig) ProtoMessage()    {}
func (*TofinoConfig_TofinoQosConfig_PoolConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 0}
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_TofinoQosConfig_PoolConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_PoolConfig.Merge(m, src)
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_PoolConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_TofinoQosConfig_PoolConfig proto.InternalMessageInfo

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetPool() TofinoConfig_TofinoQosConfig_ApplicationPool {
	if m != nil {
		return m.Pool
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_APP_POOL
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetPoolSize() uint32 {
	if m != nil {
		return m.PoolSize
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetEnableColorDrop() bool {
	if m != nil {
		return m.EnableColorDrop
	}
	return false
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetColorDropLimitGreen() uint32 {
	if m != nil {
		return m.ColorDropLimitGreen
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetColorDropLimitYellow() uint32 {
	if m != nil {
		return m.ColorDropLimitYellow
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) GetColorDropLimitRed() uint32 {
	if m != nil {
		return m.ColorDropLimitRed
	}
	return 0
}

type TofinoConfig_TofinoQosConfig_PpgConfig struct {
	// Types that are valid to be assigned to PortType:
	//	*TofinoConfig_TofinoQosConfig_PpgConfig_Port
	//	*TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort
	PortType               isTofinoConfig_TofinoQosConfig_PpgConfig_PortType `protobuf_oneof:"port_type"`
	IsDefaultPpg           bool                                              `protobuf:"varint,9,opt,name=is_default_ppg,json=isDefaultPpg,proto3" json:"is_default_ppg,omitempty"`
	MinimumGuaranteedCells uint32                                            `protobuf:"varint,2,opt,name=minimum_guaranteed_cells,json=minimumGuaranteedCells,proto3" json:"minimum_guaranteed_cells,omitempty"`
	Pool                   TofinoConfig_TofinoQosConfig_ApplicationPool      `protobuf:"varint,3,opt,name=pool,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_ApplicationPool" json:"pool,omitempty"`
	BaseUseLimit           uint32                                            `protobuf:"varint,4,opt,name=base_use_limit,json=baseUseLimit,proto3" json:"base_use_limit,omitempty"`
	Baf                    TofinoConfig_TofinoQosConfig_Baf                  `protobuf:"varint,5,opt,name=baf,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_Baf" json:"baf,omitempty"`
	Hysteresis             uint32                                            `protobuf:"varint,6,opt,name=hysteresis,proto3" json:"hysteresis,omitempty"`
	IngressDropLimit       uint32                                            `protobuf:"varint,7,opt,name=ingress_drop_limit,json=ingressDropLimit,proto3" json:"ingress_drop_limit,omitempty"`
	IcosBitmap             uint32                                            `protobuf:"varint,8,opt,name=icos_bitmap,json=icosBitmap,proto3" json:"icos_bitmap,omitempty"`
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) Reset() {
	*m = TofinoConfig_TofinoQosConfig_PpgConfig{}
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_TofinoQosConfig_PpgConfig) ProtoMessage()    {}
func (*TofinoConfig_TofinoQosConfig_PpgConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 1}
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_TofinoQosConfig_PpgConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_PpgConfig.Merge(m, src)
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_PpgConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_TofinoQosConfig_PpgConfig proto.InternalMessageInfo

type isTofinoConfig_TofinoQosConfig_PpgConfig_PortType interface {
	isTofinoConfig_TofinoQosConfig_PpgConfig_PortType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TofinoConfig_TofinoQosConfig_PpgConfig_Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort struct {
	SdkPort uint32 `protobuf:"varint,10,opt,name=sdk_port,json=sdkPort,proto3,oneof" json:"sdk_port,omitempty"`
}

func (*TofinoConfig_TofinoQosConfig_PpgConfig_Port) isTofinoConfig_TofinoQosConfig_PpgConfig_PortType() {
}
func (*TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort) isTofinoConfig_TofinoQosConfig_PpgConfig_PortType() {
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetPortType() isTofinoConfig_TofinoQosConfig_PpgConfig_PortType {
	if m != nil {
		return m.PortType
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_TofinoQosConfig_PpgConfig_Port); ok {
		return x.Port
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetSdkPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort); ok {
		return x.SdkPort
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetIsDefaultPpg() bool {
	if m != nil {
		return m.IsDefaultPpg
	}
	return false
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetMinimumGuaranteedCells() uint32 {
	if m != nil {
		return m.MinimumGuaranteedCells
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetPool() TofinoConfig_TofinoQosConfig_ApplicationPool {
	if m != nil {
		return m.Pool
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_APP_POOL
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetBaseUseLimit() uint32 {
	if m != nil {
		return m.BaseUseLimit
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetBaf() TofinoConfig_TofinoQosConfig_Baf {
	if m != nil {
		return m.Baf
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_BAF
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetHysteresis() uint32 {
	if m != nil {
		return m.Hysteresis
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetIngressDropLimit() uint32 {
	if m != nil {
		return m.IngressDropLimit
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) GetIcosBitmap() uint32 {
	if m != nil {
		return m.IcosBitmap
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TofinoConfig_TofinoQosConfig_PpgConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TofinoConfig_TofinoQosConfig_PpgConfig_Port)(nil),
		(*TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort)(nil),
	}
}

type TofinoConfig_TofinoQosConfig_QueueConfig struct {
	// Types that are valid to be assigned to PortType:
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_Port
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort
	PortType     isTofinoConfig_TofinoQosConfig_QueueConfig_PortType      `protobuf_oneof:"port_type"`
	QueueMapping []*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping `protobuf:"bytes,3,rep,name=queue_mapping,json=queueMapping,proto3" json:"queue_mapping,omitempty"`
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) Reset() {
	*m = TofinoConfig_TofinoQosConfig_QueueConfig{}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) String() string { return proto.CompactTextString(m) }
func (*TofinoConfig_TofinoQosConfig_QueueConfig) ProtoMessage()    {}
func (*TofinoConfig_TofinoQosConfig_QueueConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 2}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig.Merge(m, src)
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig proto.InternalMessageInfo

type isTofinoConfig_TofinoQosConfig_QueueConfig_PortType interface {
	isTofinoConfig_TofinoQosConfig_QueueConfig_PortType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TofinoConfig_TofinoQosConfig_QueueConfig_Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort struct {
	SdkPort uint32 `protobuf:"varint,2,opt,name=sdk_port,json=sdkPort,proto3,oneof" json:"sdk_port,omitempty"`
}

func (*TofinoConfig_TofinoQosConfig_QueueConfig_Port) isTofinoConfig_TofinoQosConfig_QueueConfig_PortType() {
}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort) isTofinoConfig_TofinoQosConfig_QueueConfig_PortType() {
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) GetPortType() isTofinoConfig_TofinoQosConfig_QueueConfig_PortType {
	if m != nil {
		return m.PortType
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) GetPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_TofinoQosConfig_QueueConfig_Port); ok {
		return x.Port
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) GetSdkPort() uint32 {
	if x, ok := m.GetPortType().(*TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort); ok {
		return x.SdkPort
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) GetQueueMapping() []*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping {
	if m != nil {
		return m.QueueMapping
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TofinoConfig_TofinoQosConfig_QueueConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TofinoConfig_TofinoQosConfig_QueueConfig_Port)(nil),
		(*TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort)(nil),
	}
}

type TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping struct {
	QueueId                int32                                           `protobuf:"varint,1,opt,name=queue_id,json=queueId,proto3" json:"queue_id,omitempty"`
	Priority               TofinoConfig_TofinoQosConfig_SchedulingPriority `protobuf:"varint,2,opt,name=priority,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_SchedulingPriority" json:"priority,omitempty"`
	Weight                 uint32                                          `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	MinimumGuaranteedCells uint32                                          `protobuf:"varint,4,opt,name=minimum_guaranteed_cells,json=minimumGuaranteedCells,proto3" json:"minimum_guaranteed_cells,omitempty"`
	Pool                   TofinoConfig_TofinoQosConfig_ApplicationPool    `protobuf:"varint,5,opt,name=pool,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_ApplicationPool" json:"pool,omitempty"`
	BaseUseLimit           uint32                                          `protobuf:"varint,6,opt,name=base_use_limit,json=baseUseLimit,proto3" json:"base_use_limit,omitempty"`
	Baf                    TofinoConfig_TofinoQosConfig_Baf                `protobuf:"varint,7,opt,name=baf,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_Baf" json:"baf,omitempty"`
	Hysteresis             uint32                                          `protobuf:"varint,8,opt,name=hysteresis,proto3" json:"hysteresis,omitempty"`
	// Types that are valid to be assigned to MaxRate:
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes
	MaxRate isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate `protobuf_oneof:"max_rate"`
	// Types that are valid to be assigned to MinRate:
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets
	//	*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes
	MinRate              isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate `protobuf_oneof:"min_rate"`
	EnableColorDrop      bool                                                            `protobuf:"varint,13,opt,name=enable_color_drop,json=enableColorDrop,proto3" json:"enable_color_drop,omitempty"`
	ColorDropLimitYellow TofinoConfig_TofinoQosConfig_QueueColorLimit                    `protobuf:"varint,14,opt,name=color_drop_limit_yellow,json=colorDropLimitYellow,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_QueueColorLimit" json:"color_drop_limit_yellow,omitempty"`
	ColorDropLimitRed    TofinoConfig_TofinoQosConfig_QueueColorLimit                    `protobuf:"varint,15,opt,name=color_drop_limit_red,json=colorDropLimitRed,proto3,enum=stratum.hal.TofinoConfig_TofinoQosConfig_QueueColorLimit" json:"color_drop_limit_red,omitempty"`
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) Reset() {
	*m = TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping{}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) String() string {
	return proto.CompactTextString(m)
}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) ProtoMessage() {}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{12, 4, 2, 0}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping.Merge(m, src)
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_Size() int {
	return m.Size()
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping proto.InternalMessageInfo

type isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate interface {
	isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate interface {
	isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets struct {
	MaxRatePackets *TofinoConfig_PacketShape `protobuf:"bytes,9,opt,name=max_rate_packets,json=maxRatePackets,proto3,oneof" json:"max_rate_packets,omitempty"`
}
type TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes struct {
	MaxRateBytes *TofinoConfig_ByteShape `protobuf:"bytes,10,opt,name=max_rate_bytes,json=maxRateBytes,proto3,oneof" json:"max_rate_bytes,omitempty"`
}
type TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets struct {
	MinRatePackets *TofinoConfig_PacketShape `protobuf:"bytes,11,opt,name=min_rate_packets,json=minRatePackets,proto3,oneof" json:"min_rate_packets,omitempty"`
}
type TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes struct {
	MinRateBytes *TofinoConfig_ByteShape `protobuf:"bytes,12,opt,name=min_rate_bytes,json=minRateBytes,proto3,oneof" json:"min_rate_bytes,omitempty"`
}

func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets) isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate() {
}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes) isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate() {
}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets) isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate() {
}
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes) isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate() {
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMaxRate() isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRate {
	if m != nil {
		return m.MaxRate
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMinRate() isTofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRate {
	if m != nil {
		return m.MinRate
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetQueueId() int32 {
	if m != nil {
		return m.QueueId
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetPriority() TofinoConfig_TofinoQosConfig_SchedulingPriority {
	if m != nil {
		return m.Priority
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_PRIO
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMinimumGuaranteedCells() uint32 {
	if m != nil {
		return m.MinimumGuaranteedCells
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetPool() TofinoConfig_TofinoQosConfig_ApplicationPool {
	if m != nil {
		return m.Pool
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_APP_POOL
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetBaseUseLimit() uint32 {
	if m != nil {
		return m.BaseUseLimit
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetBaf() TofinoConfig_TofinoQosConfig_Baf {
	if m != nil {
		return m.Baf
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_BAF
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetHysteresis() uint32 {
	if m != nil {
		return m.Hysteresis
	}
	return 0
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMaxRatePackets() *TofinoConfig_PacketShape {
	if x, ok := m.GetMaxRate().(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets); ok {
		return x.MaxRatePackets
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMaxRateBytes() *TofinoConfig_ByteShape {
	if x, ok := m.GetMaxRate().(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes); ok {
		return x.MaxRateBytes
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMinRatePackets() *TofinoConfig_PacketShape {
	if x, ok := m.GetMinRate().(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets); ok {
		return x.MinRatePackets
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetMinRateBytes() *TofinoConfig_ByteShape {
	if x, ok := m.GetMinRate().(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes); ok {
		return x.MinRateBytes
	}
	return nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetEnableColorDrop() bool {
	if m != nil {
		return m.EnableColorDrop
	}
	return false
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetColorDropLimitYellow() TofinoConfig_TofinoQosConfig_QueueColorLimit {
	if m != nil {
		return m.ColorDropLimitYellow
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_LIMIT
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) GetColorDropLimitRed() TofinoConfig_TofinoQosConfig_QueueColorLimit {
	if m != nil {
		return m.ColorDropLimitRed
	}
	return TofinoConfig_TofinoQosConfig_UNKNOWN_LIMIT
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets)(nil),
		(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes)(nil),
		(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets)(nil),
		(*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes)(nil),
	}
}

type VendorConfig struct {
	GoogleConfig *GoogleConfig `protobuf:"bytes,1,opt,name=google_config,json=googleConfig,proto3" json:"google_config,omitempty"`
	TofinoConfig *TofinoConfig `protobuf:"bytes,2,opt,name=tofino_config,json=tofinoConfig,proto3" json:"tofino_config,omitempty"`
}

func (m *VendorConfig) Reset()         { *m = VendorConfig{} }
func (m *VendorConfig) String() string { return proto.CompactTextString(m) }
func (*VendorConfig) ProtoMessage()    {}
func (*VendorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{13}
}
func (m *VendorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VendorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VendorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VendorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VendorConfig.Merge(m, src)
}
func (m *VendorConfig) XXX_Size() int {
	return m.Size()
}
func (m *VendorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VendorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VendorConfig proto.InternalMessageInfo

func (m *VendorConfig) GetGoogleConfig() *GoogleConfig {
	if m != nil {
		return m.GoogleConfig
	}
	return nil
}

func (m *VendorConfig) GetTofinoConfig() *TofinoConfig {
	if m != nil {
		return m.TofinoConfig
	}
	return nil
}

// ChassisConfig is the internal data structure that encapsulates the so called
// "config" pushed to the entire chassis. The term "chassis" refers to the a
// switching box with one or more switching nodes managed by a mgmt interface.
// The proto includes all the not-so-frequent settings that are required before
// the switch can accept flow programming requests from the controller.
// NOTE: In Stratum the external interface for pushing config is gNMI. The
// proto realization of the YANG models for the config is internally converted
// to a ChassisConfig before it is consumed by the internal stack components.
type ChassisConfig struct {
	Description              string                     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Chassis                  *Chassis                   `protobuf:"bytes,2,opt,name=chassis,proto3" json:"chassis,omitempty"`
	Nodes                    []*Node                    `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	SingletonPorts           []*SingletonPort           `protobuf:"bytes,4,rep,name=singleton_ports,json=singletonPorts,proto3" json:"singleton_ports,omitempty"`
	TrunkPorts               []*TrunkPort               `protobuf:"bytes,5,rep,name=trunk_ports,json=trunkPorts,proto3" json:"trunk_ports,omitempty"`
	PortGroups               []*PortGroup               `protobuf:"bytes,6,rep,name=port_groups,json=portGroups,proto3" json:"port_groups,omitempty"`
	VendorConfig             *VendorConfig              `protobuf:"bytes,7,opt,name=vendor_config,json=vendorConfig,proto3" json:"vendor_config,omitempty"`
	OpticalNetworkInterfaces []*OpticalNetworkInterface `protobuf:"bytes,8,rep,name=optical_network_interfaces,json=opticalNetworkInterfaces,proto3" json:"optical_network_interfaces,omitempty"`
}

func (m *ChassisConfig) Reset()         { *m = ChassisConfig{} }
func (m *ChassisConfig) String() string { return proto.CompactTextString(m) }
func (*ChassisConfig) ProtoMessage()    {}
func (*ChassisConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{14}
}
func (m *ChassisConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChassisConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChassisConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChassisConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChassisConfig.Merge(m, src)
}
func (m *ChassisConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChassisConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChassisConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChassisConfig proto.InternalMessageInfo

func (m *ChassisConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ChassisConfig) GetChassis() *Chassis {
	if m != nil {
		return m.Chassis
	}
	return nil
}

func (m *ChassisConfig) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ChassisConfig) GetSingletonPorts() []*SingletonPort {
	if m != nil {
		return m.SingletonPorts
	}
	return nil
}

func (m *ChassisConfig) GetTrunkPorts() []*TrunkPort {
	if m != nil {
		return m.TrunkPorts
	}
	return nil
}

func (m *ChassisConfig) GetPortGroups() []*PortGroup {
	if m != nil {
		return m.PortGroups
	}
	return nil
}

func (m *ChassisConfig) GetVendorConfig() *VendorConfig {
	if m != nil {
		return m.VendorConfig
	}
	return nil
}

func (m *ChassisConfig) GetOpticalNetworkInterfaces() []*OpticalNetworkInterface {
	if m != nil {
		return m.OpticalNetworkInterfaces
	}
	return nil
}

// The module speed capability for a frontpanel port.
// note: currently maps to sff_module_caps_t defined in sff.h
type SfpModuleCaps struct {
	F_100  bool `protobuf:"varint,1,opt,name=f_100,json=f100,proto3" json:"f_100,omitempty"`
	F_1G   bool `protobuf:"varint,2,opt,name=f_1g,json=f1g,proto3" json:"f_1g,omitempty"`
	F_10G  bool `protobuf:"varint,3,opt,name=f_10g,json=f10g,proto3" json:"f_10g,omitempty"`
	F_40G  bool `protobuf:"varint,4,opt,name=f_40g,json=f40g,proto3" json:"f_40g,omitempty"`
	F_100G bool `protobuf:"varint,5,opt,name=f_100g,json=f100g,proto3" json:"f_100g,omitempty"`
}

func (m *SfpModuleCaps) Reset()         { *m = SfpModuleCaps{} }
func (m *SfpModuleCaps) String() string { return proto.CompactTextString(m) }
func (*SfpModuleCaps) ProtoMessage()    {}
func (*SfpModuleCaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{15}
}
func (m *SfpModuleCaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SfpModuleCaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SfpModuleCaps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SfpModuleCaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SfpModuleCaps.Merge(m, src)
}
func (m *SfpModuleCaps) XXX_Size() int {
	return m.Size()
}
func (m *SfpModuleCaps) XXX_DiscardUnknown() {
	xxx_messageInfo_SfpModuleCaps.DiscardUnknown(m)
}

var xxx_messageInfo_SfpModuleCaps proto.InternalMessageInfo

func (m *SfpModuleCaps) GetF_100() bool {
	if m != nil {
		return m.F_100
	}
	return false
}

func (m *SfpModuleCaps) GetF_1G() bool {
	if m != nil {
		return m.F_1G
	}
	return false
}

func (m *SfpModuleCaps) GetF_10G() bool {
	if m != nil {
		return m.F_10G
	}
	return false
}

func (m *SfpModuleCaps) GetF_40G() bool {
	if m != nil {
		return m.F_40G
	}
	return false
}

func (m *SfpModuleCaps) GetF_100G() bool {
	if m != nil {
		return m.F_100G
	}
	return false
}

// Possible capabilities for a fan module.
// currently maps to onlp_fan_info_t defined in fan.h
type FanCaps struct {
	SetDir        bool `protobuf:"varint,1,opt,name=set_dir,json=setDir,proto3" json:"set_dir,omitempty"`
	GetDir        bool `protobuf:"varint,2,opt,name=get_dir,json=getDir,proto3" json:"get_dir,omitempty"`
	SetRpm        bool `protobuf:"varint,3,opt,name=set_rpm,json=setRpm,proto3" json:"set_rpm,omitempty"`
	SetPercentage bool `protobuf:"varint,4,opt,name=set_percentage,json=setPercentage,proto3" json:"set_percentage,omitempty"`
	GetRpm        bool `protobuf:"varint,5,opt,name=get_rpm,json=getRpm,proto3" json:"get_rpm,omitempty"`
	GetPercentage bool `protobuf:"varint,6,opt,name=get_percentage,json=getPercentage,proto3" json:"get_percentage,omitempty"`
}

func (m *FanCaps) Reset()         { *m = FanCaps{} }
func (m *FanCaps) String() string { return proto.CompactTextString(m) }
func (*FanCaps) ProtoMessage()    {}
func (*FanCaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{16}
}
func (m *FanCaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FanCaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FanCaps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FanCaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FanCaps.Merge(m, src)
}
func (m *FanCaps) XXX_Size() int {
	return m.Size()
}
func (m *FanCaps) XXX_DiscardUnknown() {
	xxx_messageInfo_FanCaps.DiscardUnknown(m)
}

var xxx_messageInfo_FanCaps proto.InternalMessageInfo

func (m *FanCaps) GetSetDir() bool {
	if m != nil {
		return m.SetDir
	}
	return false
}

func (m *FanCaps) GetGetDir() bool {
	if m != nil {
		return m.GetDir
	}
	return false
}

func (m *FanCaps) GetSetRpm() bool {
	if m != nil {
		return m.SetRpm
	}
	return false
}

func (m *FanCaps) GetSetPercentage() bool {
	if m != nil {
		return m.SetPercentage
	}
	return false
}

func (m *FanCaps) GetGetRpm() bool {
	if m != nil {
		return m.GetRpm
	}
	return false
}

func (m *FanCaps) GetGetPercentage() bool {
	if m != nil {
		return m.GetPercentage
	}
	return false
}

// Possible Capabilities for a PSU.
// currently maps to onlp_psu_caps_t defined in psu.h
type PsuCaps struct {
	GetType bool `protobuf:"varint,1,opt,name=get_type,json=getType,proto3" json:"get_type,omitempty"`
	GetVin  bool `protobuf:"varint,2,opt,name=get_vin,json=getVin,proto3" json:"get_vin,omitempty"`
	GetVout bool `protobuf:"varint,3,opt,name=get_vout,json=getVout,proto3" json:"get_vout,omitempty"`
	GetIin  bool `protobuf:"varint,4,opt,name=get_iin,json=getIin,proto3" json:"get_iin,omitempty"`
	GetIout bool `protobuf:"varint,5,opt,name=get_iout,json=getIout,proto3" json:"get_iout,omitempty"`
	GetPin  bool `protobuf:"varint,6,opt,name=get_pin,json=getPin,proto3" json:"get_pin,omitempty"`
	GetPout bool `protobuf:"varint,7,opt,name=get_pout,json=getPout,proto3" json:"get_pout,omitempty"`
}

func (m *PsuCaps) Reset()         { *m = PsuCaps{} }
func (m *PsuCaps) String() string { return proto.CompactTextString(m) }
func (*PsuCaps) ProtoMessage()    {}
func (*PsuCaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{17}
}
func (m *PsuCaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PsuCaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PsuCaps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PsuCaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PsuCaps.Merge(m, src)
}
func (m *PsuCaps) XXX_Size() int {
	return m.Size()
}
func (m *PsuCaps) XXX_DiscardUnknown() {
	xxx_messageInfo_PsuCaps.DiscardUnknown(m)
}

var xxx_messageInfo_PsuCaps proto.InternalMessageInfo

func (m *PsuCaps) GetGetType() bool {
	if m != nil {
		return m.GetType
	}
	return false
}

func (m *PsuCaps) GetGetVin() bool {
	if m != nil {
		return m.GetVin
	}
	return false
}

func (m *PsuCaps) GetGetVout() bool {
	if m != nil {
		return m.GetVout
	}
	return false
}

func (m *PsuCaps) GetGetIin() bool {
	if m != nil {
		return m.GetIin
	}
	return false
}

func (m *PsuCaps) GetGetIout() bool {
	if m != nil {
		return m.GetIout
	}
	return false
}

func (m *PsuCaps) GetGetPin() bool {
	if m != nil {
		return m.GetPin
	}
	return false
}

func (m *PsuCaps) GetGetPout() bool {
	if m != nil {
		return m.GetPout
	}
	return false
}

// Possible capabilities for a thermal sensor module.
// currently maps to onlp_thermal_info_t defined in thermal.h
type ThermalCaps struct {
	GetTemperature       bool `protobuf:"varint,1,opt,name=get_temperature,json=getTemperature,proto3" json:"get_temperature,omitempty"`
	GetWarningThreshold  bool `protobuf:"varint,2,opt,name=get_warning_threshold,json=getWarningThreshold,proto3" json:"get_warning_threshold,omitempty"`
	GetErrorThreshold    bool `protobuf:"varint,3,opt,name=get_error_threshold,json=getErrorThreshold,proto3" json:"get_error_threshold,omitempty"`
	GetShutdownThreshold bool `protobuf:"varint,4,opt,name=get_shutdown_threshold,json=getShutdownThreshold,proto3" json:"get_shutdown_threshold,omitempty"`
}

func (m *ThermalCaps) Reset()         { *m = ThermalCaps{} }
func (m *ThermalCaps) String() string { return proto.CompactTextString(m) }
func (*ThermalCaps) ProtoMessage()    {}
func (*ThermalCaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{18}
}
func (m *ThermalCaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThermalCaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThermalCaps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThermalCaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThermalCaps.Merge(m, src)
}
func (m *ThermalCaps) XXX_Size() int {
	return m.Size()
}
func (m *ThermalCaps) XXX_DiscardUnknown() {
	xxx_messageInfo_ThermalCaps.DiscardUnknown(m)
}

var xxx_messageInfo_ThermalCaps proto.InternalMessageInfo

func (m *ThermalCaps) GetGetTemperature() bool {
	if m != nil {
		return m.GetTemperature
	}
	return false
}

func (m *ThermalCaps) GetGetWarningThreshold() bool {
	if m != nil {
		return m.GetWarningThreshold
	}
	return false
}

func (m *ThermalCaps) GetGetErrorThreshold() bool {
	if m != nil {
		return m.GetErrorThreshold
	}
	return false
}

func (m *ThermalCaps) GetGetShutdownThreshold() bool {
	if m != nil {
		return m.GetShutdownThreshold
	}
	return false
}

// Possible capabilities for a LED module.
// currently maps to onlp_led_info_t defined in led.h
type LedCaps struct {
	Off            bool `protobuf:"varint,1,opt,name=off,proto3" json:"off,omitempty"`
	Auto           bool `protobuf:"varint,2,opt,name=auto,proto3" json:"auto,omitempty"`
	AutoBlinking   bool `protobuf:"varint,3,opt,name=auto_blinking,json=autoBlinking,proto3" json:"auto_blinking,omitempty"`
	Char           bool `protobuf:"varint,4,opt,name=char,proto3" json:"char,omitempty"`
	Red            bool `protobuf:"varint,5,opt,name=red,proto3" json:"red,omitempty"`
	RedBlinking    bool `protobuf:"varint,6,opt,name=red_blinking,json=redBlinking,proto3" json:"red_blinking,omitempty"`
	Orange         bool `protobuf:"varint,7,opt,name=orange,proto3" json:"orange,omitempty"`
	OrangeBlinking bool `protobuf:"varint,8,opt,name=orange_blinking,json=orangeBlinking,proto3" json:"orange_blinking,omitempty"`
	Yellow         bool `protobuf:"varint,9,opt,name=yellow,proto3" json:"yellow,omitempty"`
	YellowBlinking bool `protobuf:"varint,10,opt,name=yellow_blinking,json=yellowBlinking,proto3" json:"yellow_blinking,omitempty"`
	Green          bool `protobuf:"varint,11,opt,name=green,proto3" json:"green,omitempty"`
	GreenBlinking  bool `protobuf:"varint,12,opt,name=green_blinking,json=greenBlinking,proto3" json:"green_blinking,omitempty"`
	Blue           bool `protobuf:"varint,13,opt,name=blue,proto3" json:"blue,omitempty"`
	BlueBlinking   bool `protobuf:"varint,14,opt,name=blue_blinking,json=blueBlinking,proto3" json:"blue_blinking,omitempty"`
	Purple         bool `protobuf:"varint,15,opt,name=purple,proto3" json:"purple,omitempty"`
	PurpleBlinking bool `protobuf:"varint,16,opt,name=purple_blinking,json=purpleBlinking,proto3" json:"purple_blinking,omitempty"`
}

func (m *LedCaps) Reset()         { *m = LedCaps{} }
func (m *LedCaps) String() string { return proto.CompactTextString(m) }
func (*LedCaps) ProtoMessage()    {}
func (*LedCaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{19}
}
func (m *LedCaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedCaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedCaps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedCaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedCaps.Merge(m, src)
}
func (m *LedCaps) XXX_Size() int {
	return m.Size()
}
func (m *LedCaps) XXX_DiscardUnknown() {
	xxx_messageInfo_LedCaps.DiscardUnknown(m)
}

var xxx_messageInfo_LedCaps proto.InternalMessageInfo

func (m *LedCaps) GetOff() bool {
	if m != nil {
		return m.Off
	}
	return false
}

func (m *LedCaps) GetAuto() bool {
	if m != nil {
		return m.Auto
	}
	return false
}

func (m *LedCaps) GetAutoBlinking() bool {
	if m != nil {
		return m.AutoBlinking
	}
	return false
}

func (m *LedCaps) GetChar() bool {
	if m != nil {
		return m.Char
	}
	return false
}

func (m *LedCaps) GetRed() bool {
	if m != nil {
		return m.Red
	}
	return false
}

func (m *LedCaps) GetRedBlinking() bool {
	if m != nil {
		return m.RedBlinking
	}
	return false
}

func (m *LedCaps) GetOrange() bool {
	if m != nil {
		return m.Orange
	}
	return false
}

func (m *LedCaps) GetOrangeBlinking() bool {
	if m != nil {
		return m.OrangeBlinking
	}
	return false
}

func (m *LedCaps) GetYellow() bool {
	if m != nil {
		return m.Yellow
	}
	return false
}

func (m *LedCaps) GetYellowBlinking() bool {
	if m != nil {
		return m.YellowBlinking
	}
	return false
}

func (m *LedCaps) GetGreen() bool {
	if m != nil {
		return m.Green
	}
	return false
}

func (m *LedCaps) GetGreenBlinking() bool {
	if m != nil {
		return m.GreenBlinking
	}
	return false
}

func (m *LedCaps) GetBlue() bool {
	if m != nil {
		return m.Blue
	}
	return false
}

func (m *LedCaps) GetBlueBlinking() bool {
	if m != nil {
		return m.BlueBlinking
	}
	return false
}

func (m *LedCaps) GetPurple() bool {
	if m != nil {
		return m.Purple
	}
	return false
}

func (m *LedCaps) GetPurpleBlinking() bool {
	if m != nil {
		return m.PurpleBlinking
	}
	return false
}

// Frontpanel port info. Refers to properties of the module (e.g. QSFP module)
// used for a frontpanel port.
type FrontPanelPortInfo struct {
	PhysicalPortType PhysicalPortType `protobuf:"varint,1,opt,name=physical_port_type,json=physicalPortType,proto3,enum=stratum.hal.PhysicalPortType" json:"physical_port_type,omitempty"`
	MediaType        MediaType        `protobuf:"varint,2,opt,name=media_type,json=mediaType,proto3,enum=stratum.hal.MediaType" json:"media_type,omitempty"`
	VendorName       string           `protobuf:"bytes,3,opt,name=vendor_name,json=vendorName,proto3" json:"vendor_name,omitempty"`
	PartNumber       string           `protobuf:"bytes,4,opt,name=part_number,json=partNumber,proto3" json:"part_number,omitempty"`
	SerialNumber     string           `protobuf:"bytes,5,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	HwState          HwState          `protobuf:"varint,6,opt,name=hw_state,json=hwState,proto3,enum=stratum.hal.HwState" json:"hw_state,omitempty"`
}

func (m *FrontPanelPortInfo) Reset()         { *m = FrontPanelPortInfo{} }
func (m *FrontPanelPortInfo) String() string { return proto.CompactTextString(m) }
func (*FrontPanelPortInfo) ProtoMessage()    {}
func (*FrontPanelPortInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{20}
}
func (m *FrontPanelPortInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrontPanelPortInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrontPanelPortInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrontPanelPortInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrontPanelPortInfo.Merge(m, src)
}
func (m *FrontPanelPortInfo) XXX_Size() int {
	return m.Size()
}
func (m *FrontPanelPortInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FrontPanelPortInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FrontPanelPortInfo proto.InternalMessageInfo

func (m *FrontPanelPortInfo) GetPhysicalPortType() PhysicalPortType {
	if m != nil {
		return m.PhysicalPortType
	}
	return PhysicalPortType_PHYSICAL_PORT_TYPE_UNKNOWN
}

func (m *FrontPanelPortInfo) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaType_MEDIA_TYPE_UNKNOWN
}

func (m *FrontPanelPortInfo) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *FrontPanelPortInfo) GetPartNumber() string {
	if m != nil {
		return m.PartNumber
	}
	return ""
}

func (m *FrontPanelPortInfo) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *FrontPanelPortInfo) GetHwState() HwState {
	if m != nil {
		return m.HwState
	}
	return HwState_HW_STATE_UNKNOWN
}

// Optical channel state and configuration.
type OpticalTransceiverInfo struct {
	// Optical channel frequency in Hz.
	Frequency uint64 `protobuf:"varint,1,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// The input/output optical power of this port in units of 0.01
	// decibel-milliwatt. If the port is an aggregate of multiple physical
	// channels, this attribute is the total power or sum of all channels.
	InputPower  *OpticalTransceiverInfo_Power `protobuf:"bytes,2,opt,name=input_power,json=inputPower,proto3" json:"input_power,omitempty"`
	OutputPower *OpticalTransceiverInfo_Power `protobuf:"bytes,3,opt,name=output_power,json=outputPower,proto3" json:"output_power,omitempty"`
	// Target output optical power level of the optical channel, expressed in
	// increments of 0.01 decibel-milliwats.
	TargetOutputPower float64 `protobuf:"fixed64,4,opt,name=target_output_power,json=targetOutputPower,proto3" json:"target_output_power,omitempty"`
	// Vendor-specific optical channel operational mode.
	OperationalMode uint64 `protobuf:"varint,5,opt,name=operational_mode,json=operationalMode,proto3" json:"operational_mode,omitempty"`
}

func (m *OpticalTransceiverInfo) Reset()         { *m = OpticalTransceiverInfo{} }
func (m *OpticalTransceiverInfo) String() string { return proto.CompactTextString(m) }
func (*OpticalTransceiverInfo) ProtoMessage()    {}
func (*OpticalTransceiverInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{21}
}
func (m *OpticalTransceiverInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticalTransceiverInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticalTransceiverInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticalTransceiverInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticalTransceiverInfo.Merge(m, src)
}
func (m *OpticalTransceiverInfo) XXX_Size() int {
	return m.Size()
}
func (m *OpticalTransceiverInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticalTransceiverInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OpticalTransceiverInfo proto.InternalMessageInfo

func (m *OpticalTransceiverInfo) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *OpticalTransceiverInfo) GetInputPower() *OpticalTransceiverInfo_Power {
	if m != nil {
		return m.InputPower
	}
	return nil
}

func (m *OpticalTransceiverInfo) GetOutputPower() *OpticalTransceiverInfo_Power {
	if m != nil {
		return m.OutputPower
	}
	return nil
}

func (m *OpticalTransceiverInfo) GetTargetOutputPower() float64 {
	if m != nil {
		return m.TargetOutputPower
	}
	return 0
}

func (m *OpticalTransceiverInfo) GetOperationalMode() uint64 {
	if m != nil {
		return m.OperationalMode
	}
	return 0
}

type OpticalTransceiverInfo_Power struct {
	// The instantaneous value of the statistic.
	Instant float64 `protobuf:"fixed64,1,opt,name=instant,proto3" json:"instant,omitempty"`
	// The arithmetic mean value of the statistic over the time interval.
	Avg float64 `protobuf:"fixed64,2,opt,name=avg,proto3" json:"avg,omitempty"`
	// The time interval over which the statistics are computed.
	Interval uint64 `protobuf:"varint,3,opt,name=interval,proto3" json:"interval,omitempty"`
	// The maximum value of the statistic over the time interval.
	Max float64 `protobuf:"fixed64,4,opt,name=max,proto3" json:"max,omitempty"`
	// The absolute time at which the maximum value occurred.
	MaxTime uint64 `protobuf:"varint,5,opt,name=max_time,json=maxTime,proto3" json:"max_time,omitempty"`
	// The minimum value of the statistic over the time interval.
	Min float64 `protobuf:"fixed64,6,opt,name=min,proto3" json:"min,omitempty"`
	// The absolute time at which the minimum value occurred.
	MinTime uint64 `protobuf:"varint,7,opt,name=min_time,json=minTime,proto3" json:"min_time,omitempty"`
}

func (m *OpticalTransceiverInfo_Power) Reset()         { *m = OpticalTransceiverInfo_Power{} }
func (m *OpticalTransceiverInfo_Power) String() string { return proto.CompactTextString(m) }
func (*OpticalTransceiverInfo_Power) ProtoMessage()    {}
func (*OpticalTransceiverInfo_Power) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{21, 0}
}
func (m *OpticalTransceiverInfo_Power) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticalTransceiverInfo_Power) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticalTransceiverInfo_Power.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticalTransceiverInfo_Power) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticalTransceiverInfo_Power.Merge(m, src)
}
func (m *OpticalTransceiverInfo_Power) XXX_Size() int {
	return m.Size()
}
func (m *OpticalTransceiverInfo_Power) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticalTransceiverInfo_Power.DiscardUnknown(m)
}

var xxx_messageInfo_OpticalTransceiverInfo_Power proto.InternalMessageInfo

func (m *OpticalTransceiverInfo_Power) GetInstant() float64 {
	if m != nil {
		return m.Instant
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetAvg() float64 {
	if m != nil {
		return m.Avg
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetMaxTime() uint64 {
	if m != nil {
		return m.MaxTime
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *OpticalTransceiverInfo_Power) GetMinTime() uint64 {
	if m != nil {
		return m.MinTime
	}
	return 0
}

// Wrapper around oper state of a port.
type OperStatus struct {
	State           PortState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.PortState" json:"state,omitempty"`
	TimeLastChanged uint64    `protobuf:"varint,2,opt,name=time_last_changed,json=timeLastChanged,proto3" json:"time_last_changed,omitempty"`
}

func (m *OperStatus) Reset()         { *m = OperStatus{} }
func (m *OperStatus) String() string { return proto.CompactTextString(m) }
func (*OperStatus) ProtoMessage()    {}
func (*OperStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{22}
}
func (m *OperStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperStatus.Merge(m, src)
}
func (m *OperStatus) XXX_Size() int {
	return m.Size()
}
func (m *OperStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OperStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OperStatus proto.InternalMessageInfo

func (m *OperStatus) GetState() PortState {
	if m != nil {
		return m.State
	}
	return PortState_PORT_STATE_UNKNOWN
}

func (m *OperStatus) GetTimeLastChanged() uint64 {
	if m != nil {
		return m.TimeLastChanged
	}
	return 0
}

// Wrapper around loopback state of a port.
type LoopbackStatus struct {
	State LoopbackState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.LoopbackState" json:"state,omitempty"`
}

func (m *LoopbackStatus) Reset()         { *m = LoopbackStatus{} }
func (m *LoopbackStatus) String() string { return proto.CompactTextString(m) }
func (*LoopbackStatus) ProtoMessage()    {}
func (*LoopbackStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{23}
}
func (m *LoopbackStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoopbackStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoopbackStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoopbackStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopbackStatus.Merge(m, src)
}
func (m *LoopbackStatus) XXX_Size() int {
	return m.Size()
}
func (m *LoopbackStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopbackStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LoopbackStatus proto.InternalMessageInfo

func (m *LoopbackStatus) GetState() LoopbackState {
	if m != nil {
		return m.State
	}
	return LoopbackState_LOOPBACK_STATE_UNKNOWN
}

// Wrapper around admin state of a HW component.
type AdminStatus struct {
	State AdminState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.AdminState" json:"state,omitempty"`
}

func (m *AdminStatus) Reset()         { *m = AdminStatus{} }
func (m *AdminStatus) String() string { return proto.CompactTextString(m) }
func (*AdminStatus) ProtoMessage()    {}
func (*AdminStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{24}
}
func (m *AdminStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminStatus.Merge(m, src)
}
func (m *AdminStatus) XXX_Size() int {
	return m.Size()
}
func (m *AdminStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AdminStatus proto.InternalMessageInfo

func (m *AdminStatus) GetState() AdminState {
	if m != nil {
		return m.State
	}
	return AdminState_ADMIN_STATE_UNKNOWN
}

// Wrapper around mac address (for example LACP router MAC).
type MacAddress struct {
	// A mac address stored on 6 least-siginificant bytes.
	MacAddress uint64 `protobuf:"varint,1,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (m *MacAddress) Reset()         { *m = MacAddress{} }
func (m *MacAddress) String() string { return proto.CompactTextString(m) }
func (*MacAddress) ProtoMessage()    {}
func (*MacAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{25}
}
func (m *MacAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MacAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MacAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MacAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MacAddress.Merge(m, src)
}
func (m *MacAddress) XXX_Size() int {
	return m.Size()
}
func (m *MacAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MacAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MacAddress proto.InternalMessageInfo

func (m *MacAddress) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

// Wrapper around port speed of the port.
type PortSpeed struct {
	SpeedBps uint64 `protobuf:"varint,1,opt,name=speed_bps,json=speedBps,proto3" json:"speed_bps,omitempty"`
}

func (m *PortSpeed) Reset()         { *m = PortSpeed{} }
func (m *PortSpeed) String() string { return proto.CompactTextString(m) }
func (*PortSpeed) ProtoMessage()    {}
func (*PortSpeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{26}
}
func (m *PortSpeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortSpeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortSpeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortSpeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortSpeed.Merge(m, src)
}
func (m *PortSpeed) XXX_Size() int {
	return m.Size()
}
func (m *PortSpeed) XXX_DiscardUnknown() {
	xxx_messageInfo_PortSpeed.DiscardUnknown(m)
}

var xxx_messageInfo_PortSpeed proto.InternalMessageInfo

func (m *PortSpeed) GetSpeedBps() uint64 {
	if m != nil {
		return m.SpeedBps
	}
	return 0
}

// Wrapper around LACP system priority.
type SystemPriority struct {
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *SystemPriority) Reset()         { *m = SystemPriority{} }
func (m *SystemPriority) String() string { return proto.CompactTextString(m) }
func (*SystemPriority) ProtoMessage()    {}
func (*SystemPriority) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{27}
}
func (m *SystemPriority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemPriority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemPriority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemPriority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemPriority.Merge(m, src)
}
func (m *SystemPriority) XXX_Size() int {
	return m.Size()
}
func (m *SystemPriority) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemPriority.DiscardUnknown(m)
}

var xxx_messageInfo_SystemPriority proto.InternalMessageInfo

func (m *SystemPriority) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Wrapper around all the per port counters.
type PortCounters struct {
	InOctets         uint64 `protobuf:"varint,1,opt,name=in_octets,json=inOctets,proto3" json:"in_octets,omitempty"`
	InUnicastPkts    uint64 `protobuf:"varint,2,opt,name=in_unicast_pkts,json=inUnicastPkts,proto3" json:"in_unicast_pkts,omitempty"`
	InBroadcastPkts  uint64 `protobuf:"varint,3,opt,name=in_broadcast_pkts,json=inBroadcastPkts,proto3" json:"in_broadcast_pkts,omitempty"`
	InMulticastPkts  uint64 `protobuf:"varint,4,opt,name=in_multicast_pkts,json=inMulticastPkts,proto3" json:"in_multicast_pkts,omitempty"`
	InDiscards       uint64 `protobuf:"varint,5,opt,name=in_discards,json=inDiscards,proto3" json:"in_discards,omitempty"`
	InErrors         uint64 `protobuf:"varint,6,opt,name=in_errors,json=inErrors,proto3" json:"in_errors,omitempty"`
	InUnknownProtos  uint64 `protobuf:"varint,7,opt,name=in_unknown_protos,json=inUnknownProtos,proto3" json:"in_unknown_protos,omitempty"`
	OutOctets        uint64 `protobuf:"varint,8,opt,name=out_octets,json=outOctets,proto3" json:"out_octets,omitempty"`
	OutUnicastPkts   uint64 `protobuf:"varint,9,opt,name=out_unicast_pkts,json=outUnicastPkts,proto3" json:"out_unicast_pkts,omitempty"`
	OutBroadcastPkts uint64 `protobuf:"varint,10,opt,name=out_broadcast_pkts,json=outBroadcastPkts,proto3" json:"out_broadcast_pkts,omitempty"`
	OutMulticastPkts uint64 `protobuf:"varint,11,opt,name=out_multicast_pkts,json=outMulticastPkts,proto3" json:"out_multicast_pkts,omitempty"`
	OutDiscards      uint64 `protobuf:"varint,12,opt,name=out_discards,json=outDiscards,proto3" json:"out_discards,omitempty"`
	OutErrors        uint64 `protobuf:"varint,13,opt,name=out_errors,json=outErrors,proto3" json:"out_errors,omitempty"`
	InFcsErrors      uint64 `protobuf:"varint,14,opt,name=in_fcs_errors,json=inFcsErrors,proto3" json:"in_fcs_errors,omitempty"`
}

func (m *PortCounters) Reset()         { *m = PortCounters{} }
func (m *PortCounters) String() string { return proto.CompactTextString(m) }
func (*PortCounters) ProtoMessage()    {}
func (*PortCounters) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{28}
}
func (m *PortCounters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortCounters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortCounters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortCounters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortCounters.Merge(m, src)
}
func (m *PortCounters) XXX_Size() int {
	return m.Size()
}
func (m *PortCounters) XXX_DiscardUnknown() {
	xxx_messageInfo_PortCounters.DiscardUnknown(m)
}

var xxx_messageInfo_PortCounters proto.InternalMessageInfo

func (m *PortCounters) GetInOctets() uint64 {
	if m != nil {
		return m.InOctets
	}
	return 0
}

func (m *PortCounters) GetInUnicastPkts() uint64 {
	if m != nil {
		return m.InUnicastPkts
	}
	return 0
}

func (m *PortCounters) GetInBroadcastPkts() uint64 {
	if m != nil {
		return m.InBroadcastPkts
	}
	return 0
}

func (m *PortCounters) GetInMulticastPkts() uint64 {
	if m != nil {
		return m.InMulticastPkts
	}
	return 0
}

func (m *PortCounters) GetInDiscards() uint64 {
	if m != nil {
		return m.InDiscards
	}
	return 0
}

func (m *PortCounters) GetInErrors() uint64 {
	if m != nil {
		return m.InErrors
	}
	return 0
}

func (m *PortCounters) GetInUnknownProtos() uint64 {
	if m != nil {
		return m.InUnknownProtos
	}
	return 0
}

func (m *PortCounters) GetOutOctets() uint64 {
	if m != nil {
		return m.OutOctets
	}
	return 0
}

func (m *PortCounters) GetOutUnicastPkts() uint64 {
	if m != nil {
		return m.OutUnicastPkts
	}
	return 0
}

func (m *PortCounters) GetOutBroadcastPkts() uint64 {
	if m != nil {
		return m.OutBroadcastPkts
	}
	return 0
}

func (m *PortCounters) GetOutMulticastPkts() uint64 {
	if m != nil {
		return m.OutMulticastPkts
	}
	return 0
}

func (m *PortCounters) GetOutDiscards() uint64 {
	if m != nil {
		return m.OutDiscards
	}
	return 0
}

func (m *PortCounters) GetOutErrors() uint64 {
	if m != nil {
		return m.OutErrors
	}
	return 0
}

func (m *PortCounters) GetInFcsErrors() uint64 {
	if m != nil {
		return m.InFcsErrors
	}
	return 0
}

// Wrapper around per port per queue counters.
type PortQosCounters struct {
	QueueId        uint32 `protobuf:"varint,1,opt,name=queue_id,json=queueId,proto3" json:"queue_id,omitempty"`
	OutOctets      uint64 `protobuf:"varint,2,opt,name=out_octets,json=outOctets,proto3" json:"out_octets,omitempty"`
	OutPkts        uint64 `protobuf:"varint,3,opt,name=out_pkts,json=outPkts,proto3" json:"out_pkts,omitempty"`
	OutDroppedPkts uint64 `protobuf:"varint,4,opt,name=out_dropped_pkts,json=outDroppedPkts,proto3" json:"out_dropped_pkts,omitempty"`
}

func (m *PortQosCounters) Reset()         { *m = PortQosCounters{} }
func (m *PortQosCounters) String() string { return proto.CompactTextString(m) }
func (*PortQosCounters) ProtoMessage()    {}
func (*PortQosCounters) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{29}
}
func (m *PortQosCounters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortQosCounters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortQosCounters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortQosCounters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortQosCounters.Merge(m, src)
}
func (m *PortQosCounters) XXX_Size() int {
	return m.Size()
}
func (m *PortQosCounters) XXX_DiscardUnknown() {
	xxx_messageInfo_PortQosCounters.DiscardUnknown(m)
}

var xxx_messageInfo_PortQosCounters proto.InternalMessageInfo

func (m *PortQosCounters) GetQueueId() uint32 {
	if m != nil {
		return m.QueueId
	}
	return 0
}

func (m *PortQosCounters) GetOutOctets() uint64 {
	if m != nil {
		return m.OutOctets
	}
	return 0
}

func (m *PortQosCounters) GetOutPkts() uint64 {
	if m != nil {
		return m.OutPkts
	}
	return 0
}

func (m *PortQosCounters) GetOutDroppedPkts() uint64 {
	if m != nil {
		return m.OutDroppedPkts
	}
	return 0
}

// Wrapper around all the alarm related data.
type Alarm struct {
	TimeCreated uint64         `protobuf:"varint,1,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	Description string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Severity    Alarm_Severity `protobuf:"varint,3,opt,name=severity,proto3,enum=stratum.hal.Alarm_Severity" json:"severity,omitempty"`
	Status      bool           `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Alarm) Reset()         { *m = Alarm{} }
func (m *Alarm) String() string { return proto.CompactTextString(m) }
func (*Alarm) ProtoMessage()    {}
func (*Alarm) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{30}
}
func (m *Alarm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alarm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alarm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alarm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alarm.Merge(m, src)
}
func (m *Alarm) XXX_Size() int {
	return m.Size()
}
func (m *Alarm) XXX_DiscardUnknown() {
	xxx_messageInfo_Alarm.DiscardUnknown(m)
}

var xxx_messageInfo_Alarm proto.InternalMessageInfo

func (m *Alarm) GetTimeCreated() uint64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *Alarm) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Alarm) GetSeverity() Alarm_Severity {
	if m != nil {
		return m.Severity
	}
	return Alarm_UNKNOWN
}

func (m *Alarm) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

// Wrapper around the optional node info.
type NodeInfo struct {
	VendorName string `protobuf:"bytes,1,opt,name=vendor_name,json=vendorName,proto3" json:"vendor_name,omitempty"`
	ChipName   string `protobuf:"bytes,2,opt,name=chip_name,json=chipName,proto3" json:"chip_name,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{31}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *NodeInfo) GetChipName() string {
	if m != nil {
		return m.ChipName
	}
	return ""
}

// Wrapper around an optional debug info for a node/chip.
type NodeDebugInfo struct {
	DebugString string `protobuf:"bytes,1,opt,name=debug_string,json=debugString,proto3" json:"debug_string,omitempty"`
}

func (m *NodeDebugInfo) Reset()         { *m = NodeDebugInfo{} }
func (m *NodeDebugInfo) String() string { return proto.CompactTextString(m) }
func (*NodeDebugInfo) ProtoMessage()    {}
func (*NodeDebugInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{32}
}
func (m *NodeDebugInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeDebugInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeDebugInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeDebugInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeDebugInfo.Merge(m, src)
}
func (m *NodeDebugInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeDebugInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeDebugInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeDebugInfo proto.InternalMessageInfo

func (m *NodeDebugInfo) GetDebugString() string {
	if m != nil {
		return m.DebugString
	}
	return ""
}

// Wrapper around the forwarding viability of a trunk member. It is used for
// trunk pruning.
type ForwardingViability struct {
	State TrunkMemberBlockState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.TrunkMemberBlockState" json:"state,omitempty"`
}

func (m *ForwardingViability) Reset()         { *m = ForwardingViability{} }
func (m *ForwardingViability) String() string { return proto.CompactTextString(m) }
func (*ForwardingViability) ProtoMessage()    {}
func (*ForwardingViability) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{33}
}
func (m *ForwardingViability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardingViability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardingViability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardingViability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardingViability.Merge(m, src)
}
func (m *ForwardingViability) XXX_Size() int {
	return m.Size()
}
func (m *ForwardingViability) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardingViability.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardingViability proto.InternalMessageInfo

func (m *ForwardingViability) GetState() TrunkMemberBlockState {
	if m != nil {
		return m.State
	}
	return TrunkMemberBlockState_TRUNK_MEMBER_BLOCK_STATE_UNKNOWN
}

// Wrapper around the health indicator (usally translated to LED state) of a
// port.
type HealthIndicator struct {
	State HealthState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.HealthState" json:"state,omitempty"`
}

func (m *HealthIndicator) Reset()         { *m = HealthIndicator{} }
func (m *HealthIndicator) String() string { return proto.CompactTextString(m) }
func (*HealthIndicator) ProtoMessage()    {}
func (*HealthIndicator) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{34}
}
func (m *HealthIndicator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthIndicator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthIndicator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthIndicator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthIndicator.Merge(m, src)
}
func (m *HealthIndicator) XXX_Size() int {
	return m.Size()
}
func (m *HealthIndicator) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthIndicator.DiscardUnknown(m)
}

var xxx_messageInfo_HealthIndicator proto.InternalMessageInfo

func (m *HealthIndicator) GetState() HealthState {
	if m != nil {
		return m.State
	}
	return HealthState_HEALTH_STATE_UNKNOWN
}

// Wrapper around the autoneg status of a port.
type AutonegotiationStatus struct {
	State TriState `protobuf:"varint,1,opt,name=state,proto3,enum=stratum.hal.TriState" json:"state,omitempty"`
}

func (m *AutonegotiationStatus) Reset()         { *m = AutonegotiationStatus{} }
func (m *AutonegotiationStatus) String() string { return proto.CompactTextString(m) }
func (*AutonegotiationStatus) ProtoMessage()    {}
func (*AutonegotiationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{35}
}
func (m *AutonegotiationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutonegotiationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutonegotiationStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutonegotiationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutonegotiationStatus.Merge(m, src)
}
func (m *AutonegotiationStatus) XXX_Size() int {
	return m.Size()
}
func (m *AutonegotiationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AutonegotiationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AutonegotiationStatus proto.InternalMessageInfo

func (m *AutonegotiationStatus) GetState() TriState {
	if m != nil {
		return m.State
	}
	return TriState_TRI_STATE_UNKNOWN
}

// Wrapper around the FEC mode.
type FecStatus struct {
	Mode FecMode `protobuf:"varint,1,opt,name=mode,proto3,enum=stratum.hal.FecMode" json:"mode,omitempty"`
}

func (m *FecStatus) Reset()         { *m = FecStatus{} }
func (m *FecStatus) String() string { return proto.CompactTextString(m) }
func (*FecStatus) ProtoMessage()    {}
func (*FecStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{36}
}
func (m *FecStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FecStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FecStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FecStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FecStatus.Merge(m, src)
}
func (m *FecStatus) XXX_Size() int {
	return m.Size()
}
func (m *FecStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FecStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FecStatus proto.InternalMessageInfo

func (m *FecStatus) GetMode() FecMode {
	if m != nil {
		return m.Mode
	}
	return FecMode_FEC_MODE_UNKNOWN
}

// Wrapper around the SDN port ID.
// The target is expected to accept requests from the controller
// using the ID assigned by the SDN management system. If the target
// cannot accept requests using the provided ID, it can provide
// an alterate ID that should be used by the controller to address
// the interface.
type SdnPortId struct {
	PortId uint32 `protobuf:"varint,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
}

func (m *SdnPortId) Reset()         { *m = SdnPortId{} }
func (m *SdnPortId) String() string { return proto.CompactTextString(m) }
func (*SdnPortId) ProtoMessage()    {}
func (*SdnPortId) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{37}
}
func (m *SdnPortId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SdnPortId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SdnPortId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SdnPortId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SdnPortId.Merge(m, src)
}
func (m *SdnPortId) XXX_Size() int {
	return m.Size()
}
func (m *SdnPortId) XXX_DiscardUnknown() {
	xxx_messageInfo_SdnPortId.DiscardUnknown(m)
}

var xxx_messageInfo_SdnPortId proto.InternalMessageInfo

func (m *SdnPortId) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

// DataRequest is a message used internally to request data about a component
// or a set of components through SwitchInterface. It is specifically used in
// ConfigMonitoringService, as part of gNMI Get/Subscribe RPC implementation.
type DataRequest struct {
	Requests []*DataRequest_Request `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
}

func (m *DataRequest) Reset()         { *m = DataRequest{} }
func (m *DataRequest) String() string { return proto.CompactTextString(m) }
func (*DataRequest) ProtoMessage()    {}
func (*DataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38}
}
func (m *DataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest.Merge(m, src)
}
func (m *DataRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest proto.InternalMessageInfo

func (m *DataRequest) GetRequests() []*DataRequest_Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

type DataRequest_Request struct {
	// Types that are valid to be assigned to Request:
	//	*DataRequest_Request_OperStatus
	//	*DataRequest_Request_AdminStatus
	//	*DataRequest_Request_MacAddress
	//	*DataRequest_Request_PortSpeed
	//	*DataRequest_Request_NegotiatedPortSpeed
	//	*DataRequest_Request_LacpRouterMac
	//	*DataRequest_Request_LacpSystemPriority
	//	*DataRequest_Request_PortCounters
	//	*DataRequest_Request_MemoryErrorAlarm
	//	*DataRequest_Request_FlowProgrammingExceptionAlarm
	//	*DataRequest_Request_PortQosCounters
	//	*DataRequest_Request_NodePacketioDebugInfo
	//	*DataRequest_Request_ForwardingViability
	//	*DataRequest_Request_HealthIndicator
	//	*DataRequest_Request_AutonegStatus
	//	*DataRequest_Request_FrontPanelPortInfo
	//	*DataRequest_Request_FecStatus
	//	*DataRequest_Request_OpticalTransceiverInfo
	//	*DataRequest_Request_LoopbackStatus
	//	*DataRequest_Request_NodeInfo
	//	*DataRequest_Request_SdnPortId
	Request isDataRequest_Request_Request `protobuf_oneof:"request"`
}

func (m *DataRequest_Request) Reset()         { *m = DataRequest_Request{} }
func (m *DataRequest_Request) String() string { return proto.CompactTextString(m) }
func (*DataRequest_Request) ProtoMessage()    {}
func (*DataRequest_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0}
}
func (m *DataRequest_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request.Merge(m, src)
}
func (m *DataRequest_Request) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request proto.InternalMessageInfo

type isDataRequest_Request_Request interface {
	isDataRequest_Request_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DataRequest_Request_OperStatus struct {
	OperStatus *DataRequest_Request_Port `protobuf:"bytes,1,opt,name=oper_status,json=operStatus,proto3,oneof" json:"oper_status,omitempty"`
}
type DataRequest_Request_AdminStatus struct {
	AdminStatus *DataRequest_Request_Port `protobuf:"bytes,2,opt,name=admin_status,json=adminStatus,proto3,oneof" json:"admin_status,omitempty"`
}
type DataRequest_Request_MacAddress struct {
	MacAddress *DataRequest_Request_Port `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3,oneof" json:"mac_address,omitempty"`
}
type DataRequest_Request_PortSpeed struct {
	PortSpeed *DataRequest_Request_Port `protobuf:"bytes,4,opt,name=port_speed,json=portSpeed,proto3,oneof" json:"port_speed,omitempty"`
}
type DataRequest_Request_NegotiatedPortSpeed struct {
	NegotiatedPortSpeed *DataRequest_Request_Port `protobuf:"bytes,5,opt,name=negotiated_port_speed,json=negotiatedPortSpeed,proto3,oneof" json:"negotiated_port_speed,omitempty"`
}
type DataRequest_Request_LacpRouterMac struct {
	LacpRouterMac *DataRequest_Request_Port `protobuf:"bytes,6,opt,name=lacp_router_mac,json=lacpRouterMac,proto3,oneof" json:"lacp_router_mac,omitempty"`
}
type DataRequest_Request_LacpSystemPriority struct {
	LacpSystemPriority *DataRequest_Request_Port `protobuf:"bytes,7,opt,name=lacp_system_priority,json=lacpSystemPriority,proto3,oneof" json:"lacp_system_priority,omitempty"`
}
type DataRequest_Request_PortCounters struct {
	PortCounters *DataRequest_Request_Port `protobuf:"bytes,8,opt,name=port_counters,json=portCounters,proto3,oneof" json:"port_counters,omitempty"`
}
type DataRequest_Request_MemoryErrorAlarm struct {
	MemoryErrorAlarm *DataRequest_Request_Chassis `protobuf:"bytes,9,opt,name=memory_error_alarm,json=memoryErrorAlarm,proto3,oneof" json:"memory_error_alarm,omitempty"`
}
type DataRequest_Request_FlowProgrammingExceptionAlarm struct {
	FlowProgrammingExceptionAlarm *DataRequest_Request_Chassis `protobuf:"bytes,10,opt,name=flow_programming_exception_alarm,json=flowProgrammingExceptionAlarm,proto3,oneof" json:"flow_programming_exception_alarm,omitempty"`
}
type DataRequest_Request_PortQosCounters struct {
	PortQosCounters *DataRequest_Request_PortQueue `protobuf:"bytes,11,opt,name=port_qos_counters,json=portQosCounters,proto3,oneof" json:"port_qos_counters,omitempty"`
}
type DataRequest_Request_NodePacketioDebugInfo struct {
	NodePacketioDebugInfo *DataRequest_Request_Node `protobuf:"bytes,12,opt,name=node_packetio_debug_info,json=nodePacketioDebugInfo,proto3,oneof" json:"node_packetio_debug_info,omitempty"`
}
type DataRequest_Request_ForwardingViability struct {
	ForwardingViability *DataRequest_Request_Port `protobuf:"bytes,13,opt,name=forwarding_viability,json=forwardingViability,proto3,oneof" json:"forwarding_viability,omitempty"`
}
type DataRequest_Request_HealthIndicator struct {
	HealthIndicator *DataRequest_Request_Port `protobuf:"bytes,14,opt,name=health_indicator,json=healthIndicator,proto3,oneof" json:"health_indicator,omitempty"`
}
type DataRequest_Request_AutonegStatus struct {
	AutonegStatus *DataRequest_Request_Port `protobuf:"bytes,15,opt,name=autoneg_status,json=autonegStatus,proto3,oneof" json:"autoneg_status,omitempty"`
}
type DataRequest_Request_FrontPanelPortInfo struct {
	FrontPanelPortInfo *DataRequest_Request_Port `protobuf:"bytes,16,opt,name=front_panel_port_info,json=frontPanelPortInfo,proto3,oneof" json:"front_panel_port_info,omitempty"`
}
type DataRequest_Request_FecStatus struct {
	FecStatus *DataRequest_Request_Port `protobuf:"bytes,18,opt,name=fec_status,json=fecStatus,proto3,oneof" json:"fec_status,omitempty"`
}
type DataRequest_Request_OpticalTransceiverInfo struct {
	OpticalTransceiverInfo *DataRequest_Request_OpticalNetworkInterface `protobuf:"bytes,19,opt,name=optical_transceiver_info,json=opticalTransceiverInfo,proto3,oneof" json:"optical_transceiver_info,omitempty"`
}
type DataRequest_Request_LoopbackStatus struct {
	LoopbackStatus *DataRequest_Request_Port `protobuf:"bytes,20,opt,name=loopback_status,json=loopbackStatus,proto3,oneof" json:"loopback_status,omitempty"`
}
type DataRequest_Request_NodeInfo struct {
	NodeInfo *DataRequest_Request_Node `protobuf:"bytes,21,opt,name=node_info,json=nodeInfo,proto3,oneof" json:"node_info,omitempty"`
}
type DataRequest_Request_SdnPortId struct {
	SdnPortId *DataRequest_Request_Port `protobuf:"bytes,22,opt,name=sdn_port_id,json=sdnPortId,proto3,oneof" json:"sdn_port_id,omitempty"`
}

func (*DataRequest_Request_OperStatus) isDataRequest_Request_Request()                    {}
func (*DataRequest_Request_AdminStatus) isDataRequest_Request_Request()                   {}
func (*DataRequest_Request_MacAddress) isDataRequest_Request_Request()                    {}
func (*DataRequest_Request_PortSpeed) isDataRequest_Request_Request()                     {}
func (*DataRequest_Request_NegotiatedPortSpeed) isDataRequest_Request_Request()           {}
func (*DataRequest_Request_LacpRouterMac) isDataRequest_Request_Request()                 {}
func (*DataRequest_Request_LacpSystemPriority) isDataRequest_Request_Request()            {}
func (*DataRequest_Request_PortCounters) isDataRequest_Request_Request()                  {}
func (*DataRequest_Request_MemoryErrorAlarm) isDataRequest_Request_Request()              {}
func (*DataRequest_Request_FlowProgrammingExceptionAlarm) isDataRequest_Request_Request() {}
func (*DataRequest_Request_PortQosCounters) isDataRequest_Request_Request()               {}
func (*DataRequest_Request_NodePacketioDebugInfo) isDataRequest_Request_Request()         {}
func (*DataRequest_Request_ForwardingViability) isDataRequest_Request_Request()           {}
func (*DataRequest_Request_HealthIndicator) isDataRequest_Request_Request()               {}
func (*DataRequest_Request_AutonegStatus) isDataRequest_Request_Request()                 {}
func (*DataRequest_Request_FrontPanelPortInfo) isDataRequest_Request_Request()            {}
func (*DataRequest_Request_FecStatus) isDataRequest_Request_Request()                     {}
func (*DataRequest_Request_OpticalTransceiverInfo) isDataRequest_Request_Request()        {}
func (*DataRequest_Request_LoopbackStatus) isDataRequest_Request_Request()                {}
func (*DataRequest_Request_NodeInfo) isDataRequest_Request_Request()                      {}
func (*DataRequest_Request_SdnPortId) isDataRequest_Request_Request()                     {}

func (m *DataRequest_Request) GetRequest() isDataRequest_Request_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DataRequest_Request) GetOperStatus() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_OperStatus); ok {
		return x.OperStatus
	}
	return nil
}

func (m *DataRequest_Request) GetAdminStatus() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_AdminStatus); ok {
		return x.AdminStatus
	}
	return nil
}

func (m *DataRequest_Request) GetMacAddress() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_MacAddress); ok {
		return x.MacAddress
	}
	return nil
}

func (m *DataRequest_Request) GetPortSpeed() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_PortSpeed); ok {
		return x.PortSpeed
	}
	return nil
}

func (m *DataRequest_Request) GetNegotiatedPortSpeed() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_NegotiatedPortSpeed); ok {
		return x.NegotiatedPortSpeed
	}
	return nil
}

func (m *DataRequest_Request) GetLacpRouterMac() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_LacpRouterMac); ok {
		return x.LacpRouterMac
	}
	return nil
}

func (m *DataRequest_Request) GetLacpSystemPriority() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_LacpSystemPriority); ok {
		return x.LacpSystemPriority
	}
	return nil
}

func (m *DataRequest_Request) GetPortCounters() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_PortCounters); ok {
		return x.PortCounters
	}
	return nil
}

func (m *DataRequest_Request) GetMemoryErrorAlarm() *DataRequest_Request_Chassis {
	if x, ok := m.GetRequest().(*DataRequest_Request_MemoryErrorAlarm); ok {
		return x.MemoryErrorAlarm
	}
	return nil
}

func (m *DataRequest_Request) GetFlowProgrammingExceptionAlarm() *DataRequest_Request_Chassis {
	if x, ok := m.GetRequest().(*DataRequest_Request_FlowProgrammingExceptionAlarm); ok {
		return x.FlowProgrammingExceptionAlarm
	}
	return nil
}

func (m *DataRequest_Request) GetPortQosCounters() *DataRequest_Request_PortQueue {
	if x, ok := m.GetRequest().(*DataRequest_Request_PortQosCounters); ok {
		return x.PortQosCounters
	}
	return nil
}

func (m *DataRequest_Request) GetNodePacketioDebugInfo() *DataRequest_Request_Node {
	if x, ok := m.GetRequest().(*DataRequest_Request_NodePacketioDebugInfo); ok {
		return x.NodePacketioDebugInfo
	}
	return nil
}

func (m *DataRequest_Request) GetForwardingViability() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_ForwardingViability); ok {
		return x.ForwardingViability
	}
	return nil
}

func (m *DataRequest_Request) GetHealthIndicator() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_HealthIndicator); ok {
		return x.HealthIndicator
	}
	return nil
}

func (m *DataRequest_Request) GetAutonegStatus() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_AutonegStatus); ok {
		return x.AutonegStatus
	}
	return nil
}

func (m *DataRequest_Request) GetFrontPanelPortInfo() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_FrontPanelPortInfo); ok {
		return x.FrontPanelPortInfo
	}
	return nil
}

func (m *DataRequest_Request) GetFecStatus() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_FecStatus); ok {
		return x.FecStatus
	}
	return nil
}

func (m *DataRequest_Request) GetOpticalTransceiverInfo() *DataRequest_Request_OpticalNetworkInterface {
	if x, ok := m.GetRequest().(*DataRequest_Request_OpticalTransceiverInfo); ok {
		return x.OpticalTransceiverInfo
	}
	return nil
}

func (m *DataRequest_Request) GetLoopbackStatus() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_LoopbackStatus); ok {
		return x.LoopbackStatus
	}
	return nil
}

func (m *DataRequest_Request) GetNodeInfo() *DataRequest_Request_Node {
	if x, ok := m.GetRequest().(*DataRequest_Request_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (m *DataRequest_Request) GetSdnPortId() *DataRequest_Request_Port {
	if x, ok := m.GetRequest().(*DataRequest_Request_SdnPortId); ok {
		return x.SdnPortId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataRequest_Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataRequest_Request_OperStatus)(nil),
		(*DataRequest_Request_AdminStatus)(nil),
		(*DataRequest_Request_MacAddress)(nil),
		(*DataRequest_Request_PortSpeed)(nil),
		(*DataRequest_Request_NegotiatedPortSpeed)(nil),
		(*DataRequest_Request_LacpRouterMac)(nil),
		(*DataRequest_Request_LacpSystemPriority)(nil),
		(*DataRequest_Request_PortCounters)(nil),
		(*DataRequest_Request_MemoryErrorAlarm)(nil),
		(*DataRequest_Request_FlowProgrammingExceptionAlarm)(nil),
		(*DataRequest_Request_PortQosCounters)(nil),
		(*DataRequest_Request_NodePacketioDebugInfo)(nil),
		(*DataRequest_Request_ForwardingViability)(nil),
		(*DataRequest_Request_HealthIndicator)(nil),
		(*DataRequest_Request_AutonegStatus)(nil),
		(*DataRequest_Request_FrontPanelPortInfo)(nil),
		(*DataRequest_Request_FecStatus)(nil),
		(*DataRequest_Request_OpticalTransceiverInfo)(nil),
		(*DataRequest_Request_LoopbackStatus)(nil),
		(*DataRequest_Request_NodeInfo)(nil),
		(*DataRequest_Request_SdnPortId)(nil),
	}
}

// Defines the data required to get a data for a port.
type DataRequest_Request_Port struct {
	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	PortId uint32 `protobuf:"varint,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
}

func (m *DataRequest_Request_Port) Reset()         { *m = DataRequest_Request_Port{} }
func (m *DataRequest_Request_Port) String() string { return proto.CompactTextString(m) }
func (*DataRequest_Request_Port) ProtoMessage()    {}
func (*DataRequest_Request_Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0, 0}
}
func (m *DataRequest_Request_Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request_Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request_Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request_Port.Merge(m, src)
}
func (m *DataRequest_Request_Port) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request_Port) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request_Port.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request_Port proto.InternalMessageInfo

func (m *DataRequest_Request_Port) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DataRequest_Request_Port) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

// Defines the data required to get a data for a node.
type DataRequest_Request_Node struct {
	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *DataRequest_Request_Node) Reset()         { *m = DataRequest_Request_Node{} }
func (m *DataRequest_Request_Node) String() string { return proto.CompactTextString(m) }
func (*DataRequest_Request_Node) ProtoMessage()    {}
func (*DataRequest_Request_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0, 1}
}
func (m *DataRequest_Request_Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request_Node.Merge(m, src)
}
func (m *DataRequest_Request_Node) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request_Node.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request_Node proto.InternalMessageInfo

func (m *DataRequest_Request_Node) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

// Defined the data required to get a data for a chassis.
type DataRequest_Request_Chassis struct {
}

func (m *DataRequest_Request_Chassis) Reset()         { *m = DataRequest_Request_Chassis{} }
func (m *DataRequest_Request_Chassis) String() string { return proto.CompactTextString(m) }
func (*DataRequest_Request_Chassis) ProtoMessage()    {}
func (*DataRequest_Request_Chassis) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0, 2}
}
func (m *DataRequest_Request_Chassis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request_Chassis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request_Chassis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request_Chassis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request_Chassis.Merge(m, src)
}
func (m *DataRequest_Request_Chassis) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request_Chassis) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request_Chassis.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request_Chassis proto.InternalMessageInfo

// Defined the data required to get a data for a queue of a port.
type DataRequest_Request_PortQueue struct {
	NodeId  uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	PortId  uint32 `protobuf:"varint,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	QueueId uint32 `protobuf:"varint,3,opt,name=queue_id,json=queueId,proto3" json:"queue_id,omitempty"`
}

func (m *DataRequest_Request_PortQueue) Reset()         { *m = DataRequest_Request_PortQueue{} }
func (m *DataRequest_Request_PortQueue) String() string { return proto.CompactTextString(m) }
func (*DataRequest_Request_PortQueue) ProtoMessage()    {}
func (*DataRequest_Request_PortQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0, 3}
}
func (m *DataRequest_Request_PortQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request_PortQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request_PortQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request_PortQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request_PortQueue.Merge(m, src)
}
func (m *DataRequest_Request_PortQueue) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request_PortQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request_PortQueue.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request_PortQueue proto.InternalMessageInfo

func (m *DataRequest_Request_PortQueue) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DataRequest_Request_PortQueue) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *DataRequest_Request_PortQueue) GetQueueId() uint32 {
	if m != nil {
		return m.QueueId
	}
	return 0
}

// Data required to set info for a specific optical network interface.
type DataRequest_Request_OpticalNetworkInterface struct {
	Module           int32 `protobuf:"varint,1,opt,name=module,proto3" json:"module,omitempty"`
	NetworkInterface int32 `protobuf:"varint,2,opt,name=network_interface,json=networkInterface,proto3" json:"network_interface,omitempty"`
}

func (m *DataRequest_Request_OpticalNetworkInterface) Reset() {
	*m = DataRequest_Request_OpticalNetworkInterface{}
}
func (m *DataRequest_Request_OpticalNetworkInterface) String() string {
	return proto.CompactTextString(m)
}
func (*DataRequest_Request_OpticalNetworkInterface) ProtoMessage() {}
func (*DataRequest_Request_OpticalNetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{38, 0, 4}
}
func (m *DataRequest_Request_OpticalNetworkInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRequest_Request_OpticalNetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRequest_Request_OpticalNetworkInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRequest_Request_OpticalNetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRequest_Request_OpticalNetworkInterface.Merge(m, src)
}
func (m *DataRequest_Request_OpticalNetworkInterface) XXX_Size() int {
	return m.Size()
}
func (m *DataRequest_Request_OpticalNetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRequest_Request_OpticalNetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_DataRequest_Request_OpticalNetworkInterface proto.InternalMessageInfo

func (m *DataRequest_Request_OpticalNetworkInterface) GetModule() int32 {
	if m != nil {
		return m.Module
	}
	return 0
}

func (m *DataRequest_Request_OpticalNetworkInterface) GetNetworkInterface() int32 {
	if m != nil {
		return m.NetworkInterface
	}
	return 0
}

// DataResponse is a message used internally to return data about a component
// or a set of components, requested by DataRequest through SwitchInterface, to
// It is specifically used in ConfigMonitoringService. It is used in the gNMI
// Get/Subscribe RPC implementation.
type DataResponse struct {
	// Types that are valid to be assigned to Response:
	//	*DataResponse_OperStatus
	//	*DataResponse_AdminStatus
	//	*DataResponse_MacAddress
	//	*DataResponse_PortSpeed
	//	*DataResponse_NegotiatedPortSpeed
	//	*DataResponse_LacpRouterMac
	//	*DataResponse_LacpSystemPriority
	//	*DataResponse_PortCounters
	//	*DataResponse_MemoryErrorAlarm
	//	*DataResponse_FlowProgrammingExceptionAlarm
	//	*DataResponse_PortQosCounters
	//	*DataResponse_NodePacketioDebugInfo
	//	*DataResponse_ForwardingViability
	//	*DataResponse_HealthIndicator
	//	*DataResponse_AutonegStatus
	//	*DataResponse_FrontPanelPortInfo
	//	*DataResponse_FecStatus
	//	*DataResponse_OpticalTransceiverInfo
	//	*DataResponse_LoopbackStatus
	//	*DataResponse_NodeInfo
	//	*DataResponse_SdnPortId
	Response isDataResponse_Response `protobuf_oneof:"response"`
}

func (m *DataResponse) Reset()         { *m = DataResponse{} }
func (m *DataResponse) String() string { return proto.CompactTextString(m) }
func (*DataResponse) ProtoMessage()    {}
func (*DataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{39}
}
func (m *DataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataResponse.Merge(m, src)
}
func (m *DataResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataResponse proto.InternalMessageInfo

type isDataResponse_Response interface {
	isDataResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DataResponse_OperStatus struct {
	OperStatus *OperStatus `protobuf:"bytes,1,opt,name=oper_status,json=operStatus,proto3,oneof" json:"oper_status,omitempty"`
}
type DataResponse_AdminStatus struct {
	AdminStatus *AdminStatus `protobuf:"bytes,2,opt,name=admin_status,json=adminStatus,proto3,oneof" json:"admin_status,omitempty"`
}
type DataResponse_MacAddress struct {
	MacAddress *MacAddress `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3,oneof" json:"mac_address,omitempty"`
}
type DataResponse_PortSpeed struct {
	PortSpeed *PortSpeed `protobuf:"bytes,4,opt,name=port_speed,json=portSpeed,proto3,oneof" json:"port_speed,omitempty"`
}
type DataResponse_NegotiatedPortSpeed struct {
	NegotiatedPortSpeed *PortSpeed `protobuf:"bytes,5,opt,name=negotiated_port_speed,json=negotiatedPortSpeed,proto3,oneof" json:"negotiated_port_speed,omitempty"`
}
type DataResponse_LacpRouterMac struct {
	LacpRouterMac *MacAddress `protobuf:"bytes,6,opt,name=lacp_router_mac,json=lacpRouterMac,proto3,oneof" json:"lacp_router_mac,omitempty"`
}
type DataResponse_LacpSystemPriority struct {
	LacpSystemPriority *SystemPriority `protobuf:"bytes,7,opt,name=lacp_system_priority,json=lacpSystemPriority,proto3,oneof" json:"lacp_system_priority,omitempty"`
}
type DataResponse_PortCounters struct {
	PortCounters *PortCounters `protobuf:"bytes,8,opt,name=port_counters,json=portCounters,proto3,oneof" json:"port_counters,omitempty"`
}
type DataResponse_MemoryErrorAlarm struct {
	MemoryErrorAlarm *Alarm `protobuf:"bytes,9,opt,name=memory_error_alarm,json=memoryErrorAlarm,proto3,oneof" json:"memory_error_alarm,omitempty"`
}
type DataResponse_FlowProgrammingExceptionAlarm struct {
	FlowProgrammingExceptionAlarm *Alarm `protobuf:"bytes,10,opt,name=flow_programming_exception_alarm,json=flowProgrammingExceptionAlarm,proto3,oneof" json:"flow_programming_exception_alarm,omitempty"`
}
type DataResponse_PortQosCounters struct {
	PortQosCounters *PortQosCounters `protobuf:"bytes,11,opt,name=port_qos_counters,json=portQosCounters,proto3,oneof" json:"port_qos_counters,omitempty"`
}
type DataResponse_NodePacketioDebugInfo struct {
	NodePacketioDebugInfo *NodeDebugInfo `protobuf:"bytes,12,opt,name=node_packetio_debug_info,json=nodePacketioDebugInfo,proto3,oneof" json:"node_packetio_debug_info,omitempty"`
}
type DataResponse_ForwardingViability struct {
	ForwardingViability *ForwardingViability `protobuf:"bytes,13,opt,name=forwarding_viability,json=forwardingViability,proto3,oneof" json:"forwarding_viability,omitempty"`
}
type DataResponse_HealthIndicator struct {
	HealthIndicator *HealthIndicator `protobuf:"bytes,14,opt,name=health_indicator,json=healthIndicator,proto3,oneof" json:"health_indicator,omitempty"`
}
type DataResponse_AutonegStatus struct {
	AutonegStatus *AutonegotiationStatus `protobuf:"bytes,15,opt,name=autoneg_status,json=autonegStatus,proto3,oneof" json:"autoneg_status,omitempty"`
}
type DataResponse_FrontPanelPortInfo struct {
	FrontPanelPortInfo *FrontPanelPortInfo `protobuf:"bytes,16,opt,name=front_panel_port_info,json=frontPanelPortInfo,proto3,oneof" json:"front_panel_port_info,omitempty"`
}
type DataResponse_FecStatus struct {
	FecStatus *FecStatus `protobuf:"bytes,18,opt,name=fec_status,json=fecStatus,proto3,oneof" json:"fec_status,omitempty"`
}
type DataResponse_OpticalTransceiverInfo struct {
	OpticalTransceiverInfo *OpticalTransceiverInfo `protobuf:"bytes,19,opt,name=optical_transceiver_info,json=opticalTransceiverInfo,proto3,oneof" json:"optical_transceiver_info,omitempty"`
}
type DataResponse_LoopbackStatus struct {
	LoopbackStatus *LoopbackStatus `protobuf:"bytes,20,opt,name=loopback_status,json=loopbackStatus,proto3,oneof" json:"loopback_status,omitempty"`
}
type DataResponse_NodeInfo struct {
	NodeInfo *NodeInfo `protobuf:"bytes,21,opt,name=node_info,json=nodeInfo,proto3,oneof" json:"node_info,omitempty"`
}
type DataResponse_SdnPortId struct {
	SdnPortId *SdnPortId `protobuf:"bytes,22,opt,name=sdn_port_id,json=sdnPortId,proto3,oneof" json:"sdn_port_id,omitempty"`
}

func (*DataResponse_OperStatus) isDataResponse_Response()                    {}
func (*DataResponse_AdminStatus) isDataResponse_Response()                   {}
func (*DataResponse_MacAddress) isDataResponse_Response()                    {}
func (*DataResponse_PortSpeed) isDataResponse_Response()                     {}
func (*DataResponse_NegotiatedPortSpeed) isDataResponse_Response()           {}
func (*DataResponse_LacpRouterMac) isDataResponse_Response()                 {}
func (*DataResponse_LacpSystemPriority) isDataResponse_Response()            {}
func (*DataResponse_PortCounters) isDataResponse_Response()                  {}
func (*DataResponse_MemoryErrorAlarm) isDataResponse_Response()              {}
func (*DataResponse_FlowProgrammingExceptionAlarm) isDataResponse_Response() {}
func (*DataResponse_PortQosCounters) isDataResponse_Response()               {}
func (*DataResponse_NodePacketioDebugInfo) isDataResponse_Response()         {}
func (*DataResponse_ForwardingViability) isDataResponse_Response()           {}
func (*DataResponse_HealthIndicator) isDataResponse_Response()               {}
func (*DataResponse_AutonegStatus) isDataResponse_Response()                 {}
func (*DataResponse_FrontPanelPortInfo) isDataResponse_Response()            {}
func (*DataResponse_FecStatus) isDataResponse_Response()                     {}
func (*DataResponse_OpticalTransceiverInfo) isDataResponse_Response()        {}
func (*DataResponse_LoopbackStatus) isDataResponse_Response()                {}
func (*DataResponse_NodeInfo) isDataResponse_Response()                      {}
func (*DataResponse_SdnPortId) isDataResponse_Response()                     {}

func (m *DataResponse) GetResponse() isDataResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DataResponse) GetOperStatus() *OperStatus {
	if x, ok := m.GetResponse().(*DataResponse_OperStatus); ok {
		return x.OperStatus
	}
	return nil
}

func (m *DataResponse) GetAdminStatus() *AdminStatus {
	if x, ok := m.GetResponse().(*DataResponse_AdminStatus); ok {
		return x.AdminStatus
	}
	return nil
}

func (m *DataResponse) GetMacAddress() *MacAddress {
	if x, ok := m.GetResponse().(*DataResponse_MacAddress); ok {
		return x.MacAddress
	}
	return nil
}

func (m *DataResponse) GetPortSpeed() *PortSpeed {
	if x, ok := m.GetResponse().(*DataResponse_PortSpeed); ok {
		return x.PortSpeed
	}
	return nil
}

func (m *DataResponse) GetNegotiatedPortSpeed() *PortSpeed {
	if x, ok := m.GetResponse().(*DataResponse_NegotiatedPortSpeed); ok {
		return x.NegotiatedPortSpeed
	}
	return nil
}

func (m *DataResponse) GetLacpRouterMac() *MacAddress {
	if x, ok := m.GetResponse().(*DataResponse_LacpRouterMac); ok {
		return x.LacpRouterMac
	}
	return nil
}

func (m *DataResponse) GetLacpSystemPriority() *SystemPriority {
	if x, ok := m.GetResponse().(*DataResponse_LacpSystemPriority); ok {
		return x.LacpSystemPriority
	}
	return nil
}

func (m *DataResponse) GetPortCounters() *PortCounters {
	if x, ok := m.GetResponse().(*DataResponse_PortCounters); ok {
		return x.PortCounters
	}
	return nil
}

func (m *DataResponse) GetMemoryErrorAlarm() *Alarm {
	if x, ok := m.GetResponse().(*DataResponse_MemoryErrorAlarm); ok {
		return x.MemoryErrorAlarm
	}
	return nil
}

func (m *DataResponse) GetFlowProgrammingExceptionAlarm() *Alarm {
	if x, ok := m.GetResponse().(*DataResponse_FlowProgrammingExceptionAlarm); ok {
		return x.FlowProgrammingExceptionAlarm
	}
	return nil
}

func (m *DataResponse) GetPortQosCounters() *PortQosCounters {
	if x, ok := m.GetResponse().(*DataResponse_PortQosCounters); ok {
		return x.PortQosCounters
	}
	return nil
}

func (m *DataResponse) GetNodePacketioDebugInfo() *NodeDebugInfo {
	if x, ok := m.GetResponse().(*DataResponse_NodePacketioDebugInfo); ok {
		return x.NodePacketioDebugInfo
	}
	return nil
}

func (m *DataResponse) GetForwardingViability() *ForwardingViability {
	if x, ok := m.GetResponse().(*DataResponse_ForwardingViability); ok {
		return x.ForwardingViability
	}
	return nil
}

func (m *DataResponse) GetHealthIndicator() *HealthIndicator {
	if x, ok := m.GetResponse().(*DataResponse_HealthIndicator); ok {
		return x.HealthIndicator
	}
	return nil
}

func (m *DataResponse) GetAutonegStatus() *AutonegotiationStatus {
	if x, ok := m.GetResponse().(*DataResponse_AutonegStatus); ok {
		return x.AutonegStatus
	}
	return nil
}

func (m *DataResponse) GetFrontPanelPortInfo() *FrontPanelPortInfo {
	if x, ok := m.GetResponse().(*DataResponse_FrontPanelPortInfo); ok {
		return x.FrontPanelPortInfo
	}
	return nil
}

func (m *DataResponse) GetFecStatus() *FecStatus {
	if x, ok := m.GetResponse().(*DataResponse_FecStatus); ok {
		return x.FecStatus
	}
	return nil
}

func (m *DataResponse) GetOpticalTransceiverInfo() *OpticalTransceiverInfo {
	if x, ok := m.GetResponse().(*DataResponse_OpticalTransceiverInfo); ok {
		return x.OpticalTransceiverInfo
	}
	return nil
}

func (m *DataResponse) GetLoopbackStatus() *LoopbackStatus {
	if x, ok := m.GetResponse().(*DataResponse_LoopbackStatus); ok {
		return x.LoopbackStatus
	}
	return nil
}

func (m *DataResponse) GetNodeInfo() *NodeInfo {
	if x, ok := m.GetResponse().(*DataResponse_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (m *DataResponse) GetSdnPortId() *SdnPortId {
	if x, ok := m.GetResponse().(*DataResponse_SdnPortId); ok {
		return x.SdnPortId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataResponse_OperStatus)(nil),
		(*DataResponse_AdminStatus)(nil),
		(*DataResponse_MacAddress)(nil),
		(*DataResponse_PortSpeed)(nil),
		(*DataResponse_NegotiatedPortSpeed)(nil),
		(*DataResponse_LacpRouterMac)(nil),
		(*DataResponse_LacpSystemPriority)(nil),
		(*DataResponse_PortCounters)(nil),
		(*DataResponse_MemoryErrorAlarm)(nil),
		(*DataResponse_FlowProgrammingExceptionAlarm)(nil),
		(*DataResponse_PortQosCounters)(nil),
		(*DataResponse_NodePacketioDebugInfo)(nil),
		(*DataResponse_ForwardingViability)(nil),
		(*DataResponse_HealthIndicator)(nil),
		(*DataResponse_AutonegStatus)(nil),
		(*DataResponse_FrontPanelPortInfo)(nil),
		(*DataResponse_FecStatus)(nil),
		(*DataResponse_OpticalTransceiverInfo)(nil),
		(*DataResponse_LoopbackStatus)(nil),
		(*DataResponse_NodeInfo)(nil),
		(*DataResponse_SdnPortId)(nil),
	}
}

// A message requesting changing configuration parameters inside the HAL.
type SetRequest struct {
	Requests []*SetRequest_Request `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
}

func (m *SetRequest) Reset()         { *m = SetRequest{} }
func (m *SetRequest) String() string { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()    {}
func (*SetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40}
}
func (m *SetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest.Merge(m, src)
}
func (m *SetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest proto.InternalMessageInfo

func (m *SetRequest) GetRequests() []*SetRequest_Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

type SetRequest_Request struct {
	// Types that are valid to be assigned to Request:
	//	*SetRequest_Request_Port_
	//	*SetRequest_Request_Node_
	//	*SetRequest_Request_Chassis_
	//	*SetRequest_Request_OpticalNetworkInterface_
	Request isSetRequest_Request_Request `protobuf_oneof:"request"`
}

func (m *SetRequest_Request) Reset()         { *m = SetRequest_Request{} }
func (m *SetRequest_Request) String() string { return proto.CompactTextString(m) }
func (*SetRequest_Request) ProtoMessage()    {}
func (*SetRequest_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40, 0}
}
func (m *SetRequest_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest_Request.Merge(m, src)
}
func (m *SetRequest_Request) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest_Request.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest_Request proto.InternalMessageInfo

type isSetRequest_Request_Request interface {
	isSetRequest_Request_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SetRequest_Request_Port_ struct {
	Port *SetRequest_Request_Port `protobuf:"bytes,1,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type SetRequest_Request_Node_ struct {
	Node *SetRequest_Request_Node `protobuf:"bytes,2,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type SetRequest_Request_Chassis_ struct {
	Chassis *SetRequest_Request_Chassis `protobuf:"bytes,3,opt,name=chassis,proto3,oneof" json:"chassis,omitempty"`
}
type SetRequest_Request_OpticalNetworkInterface_ struct {
	OpticalNetworkInterface *SetRequest_Request_OpticalNetworkInterface `protobuf:"bytes,4,opt,name=optical_network_interface,json=opticalNetworkInterface,proto3,oneof" json:"optical_network_interface,omitempty"`
}

func (*SetRequest_Request_Port_) isSetRequest_Request_Request()                    {}
func (*SetRequest_Request_Node_) isSetRequest_Request_Request()                    {}
func (*SetRequest_Request_Chassis_) isSetRequest_Request_Request()                 {}
func (*SetRequest_Request_OpticalNetworkInterface_) isSetRequest_Request_Request() {}

func (m *SetRequest_Request) GetRequest() isSetRequest_Request_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SetRequest_Request) GetPort() *SetRequest_Request_Port {
	if x, ok := m.GetRequest().(*SetRequest_Request_Port_); ok {
		return x.Port
	}
	return nil
}

func (m *SetRequest_Request) GetNode() *SetRequest_Request_Node {
	if x, ok := m.GetRequest().(*SetRequest_Request_Node_); ok {
		return x.Node
	}
	return nil
}

func (m *SetRequest_Request) GetChassis() *SetRequest_Request_Chassis {
	if x, ok := m.GetRequest().(*SetRequest_Request_Chassis_); ok {
		return x.Chassis
	}
	return nil
}

func (m *SetRequest_Request) GetOpticalNetworkInterface() *SetRequest_Request_OpticalNetworkInterface {
	if x, ok := m.GetRequest().(*SetRequest_Request_OpticalNetworkInterface_); ok {
		return x.OpticalNetworkInterface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SetRequest_Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SetRequest_Request_Port_)(nil),
		(*SetRequest_Request_Node_)(nil),
		(*SetRequest_Request_Chassis_)(nil),
		(*SetRequest_Request_OpticalNetworkInterface_)(nil),
	}
}

// Data required to set info for a specific port.
type SetRequest_Request_Port struct {
	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	PortId uint32 `protobuf:"varint,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*SetRequest_Request_Port_AdminStatus
	//	*SetRequest_Request_Port_MacAddress
	//	*SetRequest_Request_Port_PortSpeed
	//	*SetRequest_Request_Port_LacpRouterMac
	//	*SetRequest_Request_Port_LacpSystemPriority
	//	*SetRequest_Request_Port_HealthIndicator
	//	*SetRequest_Request_Port_AutonegStatus
	//	*SetRequest_Request_Port_ForwardingViability
	//	*SetRequest_Request_Port_LoopbackStatus
	Value isSetRequest_Request_Port_Value `protobuf_oneof:"value"`
}

func (m *SetRequest_Request_Port) Reset()         { *m = SetRequest_Request_Port{} }
func (m *SetRequest_Request_Port) String() string { return proto.CompactTextString(m) }
func (*SetRequest_Request_Port) ProtoMessage()    {}
func (*SetRequest_Request_Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40, 0, 0}
}
func (m *SetRequest_Request_Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest_Request_Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest_Request_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest_Request_Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest_Request_Port.Merge(m, src)
}
func (m *SetRequest_Request_Port) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest_Request_Port) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest_Request_Port.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest_Request_Port proto.InternalMessageInfo

type isSetRequest_Request_Port_Value interface {
	isSetRequest_Request_Port_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SetRequest_Request_Port_AdminStatus struct {
	AdminStatus *AdminStatus `protobuf:"bytes,3,opt,name=admin_status,json=adminStatus,proto3,oneof" json:"admin_status,omitempty"`
}
type SetRequest_Request_Port_MacAddress struct {
	MacAddress *MacAddress `protobuf:"bytes,4,opt,name=mac_address,json=macAddress,proto3,oneof" json:"mac_address,omitempty"`
}
type SetRequest_Request_Port_PortSpeed struct {
	PortSpeed *PortSpeed `protobuf:"bytes,5,opt,name=port_speed,json=portSpeed,proto3,oneof" json:"port_speed,omitempty"`
}
type SetRequest_Request_Port_LacpRouterMac struct {
	LacpRouterMac *MacAddress `protobuf:"bytes,6,opt,name=lacp_router_mac,json=lacpRouterMac,proto3,oneof" json:"lacp_router_mac,omitempty"`
}
type SetRequest_Request_Port_LacpSystemPriority struct {
	LacpSystemPriority *SystemPriority `protobuf:"bytes,7,opt,name=lacp_system_priority,json=lacpSystemPriority,proto3,oneof" json:"lacp_system_priority,omitempty"`
}
type SetRequest_Request_Port_HealthIndicator struct {
	HealthIndicator *HealthIndicator `protobuf:"bytes,8,opt,name=health_indicator,json=healthIndicator,proto3,oneof" json:"health_indicator,omitempty"`
}
type SetRequest_Request_Port_AutonegStatus struct {
	AutonegStatus *AutonegotiationStatus `protobuf:"bytes,9,opt,name=autoneg_status,json=autonegStatus,proto3,oneof" json:"autoneg_status,omitempty"`
}
type SetRequest_Request_Port_ForwardingViability struct {
	ForwardingViability *ForwardingViability `protobuf:"bytes,10,opt,name=forwarding_viability,json=forwardingViability,proto3,oneof" json:"forwarding_viability,omitempty"`
}
type SetRequest_Request_Port_LoopbackStatus struct {
	LoopbackStatus *LoopbackStatus `protobuf:"bytes,11,opt,name=loopback_status,json=loopbackStatus,proto3,oneof" json:"loopback_status,omitempty"`
}

func (*SetRequest_Request_Port_AdminStatus) isSetRequest_Request_Port_Value()         {}
func (*SetRequest_Request_Port_MacAddress) isSetRequest_Request_Port_Value()          {}
func (*SetRequest_Request_Port_PortSpeed) isSetRequest_Request_Port_Value()           {}
func (*SetRequest_Request_Port_LacpRouterMac) isSetRequest_Request_Port_Value()       {}
func (*SetRequest_Request_Port_LacpSystemPriority) isSetRequest_Request_Port_Value()  {}
func (*SetRequest_Request_Port_HealthIndicator) isSetRequest_Request_Port_Value()     {}
func (*SetRequest_Request_Port_AutonegStatus) isSetRequest_Request_Port_Value()       {}
func (*SetRequest_Request_Port_ForwardingViability) isSetRequest_Request_Port_Value() {}
func (*SetRequest_Request_Port_LoopbackStatus) isSetRequest_Request_Port_Value()      {}

func (m *SetRequest_Request_Port) GetValue() isSetRequest_Request_Port_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetRequest_Request_Port) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SetRequest_Request_Port) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *SetRequest_Request_Port) GetAdminStatus() *AdminStatus {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_AdminStatus); ok {
		return x.AdminStatus
	}
	return nil
}

func (m *SetRequest_Request_Port) GetMacAddress() *MacAddress {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_MacAddress); ok {
		return x.MacAddress
	}
	return nil
}

func (m *SetRequest_Request_Port) GetPortSpeed() *PortSpeed {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_PortSpeed); ok {
		return x.PortSpeed
	}
	return nil
}

func (m *SetRequest_Request_Port) GetLacpRouterMac() *MacAddress {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_LacpRouterMac); ok {
		return x.LacpRouterMac
	}
	return nil
}

func (m *SetRequest_Request_Port) GetLacpSystemPriority() *SystemPriority {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_LacpSystemPriority); ok {
		return x.LacpSystemPriority
	}
	return nil
}

func (m *SetRequest_Request_Port) GetHealthIndicator() *HealthIndicator {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_HealthIndicator); ok {
		return x.HealthIndicator
	}
	return nil
}

func (m *SetRequest_Request_Port) GetAutonegStatus() *AutonegotiationStatus {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_AutonegStatus); ok {
		return x.AutonegStatus
	}
	return nil
}

func (m *SetRequest_Request_Port) GetForwardingViability() *ForwardingViability {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_ForwardingViability); ok {
		return x.ForwardingViability
	}
	return nil
}

func (m *SetRequest_Request_Port) GetLoopbackStatus() *LoopbackStatus {
	if x, ok := m.GetValue().(*SetRequest_Request_Port_LoopbackStatus); ok {
		return x.LoopbackStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SetRequest_Request_Port) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SetRequest_Request_Port_AdminStatus)(nil),
		(*SetRequest_Request_Port_MacAddress)(nil),
		(*SetRequest_Request_Port_PortSpeed)(nil),
		(*SetRequest_Request_Port_LacpRouterMac)(nil),
		(*SetRequest_Request_Port_LacpSystemPriority)(nil),
		(*SetRequest_Request_Port_HealthIndicator)(nil),
		(*SetRequest_Request_Port_AutonegStatus)(nil),
		(*SetRequest_Request_Port_ForwardingViability)(nil),
		(*SetRequest_Request_Port_LoopbackStatus)(nil),
	}
}

// Data required to set info for a specific node.
type SetRequest_Request_Node struct {
}

func (m *SetRequest_Request_Node) Reset()         { *m = SetRequest_Request_Node{} }
func (m *SetRequest_Request_Node) String() string { return proto.CompactTextString(m) }
func (*SetRequest_Request_Node) ProtoMessage()    {}
func (*SetRequest_Request_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40, 0, 1}
}
func (m *SetRequest_Request_Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest_Request_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest_Request_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest_Request_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest_Request_Node.Merge(m, src)
}
func (m *SetRequest_Request_Node) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest_Request_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest_Request_Node.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest_Request_Node proto.InternalMessageInfo

// Data required to set info for a specific chassis.
type SetRequest_Request_Chassis struct {
}

func (m *SetRequest_Request_Chassis) Reset()         { *m = SetRequest_Request_Chassis{} }
func (m *SetRequest_Request_Chassis) String() string { return proto.CompactTextString(m) }
func (*SetRequest_Request_Chassis) ProtoMessage()    {}
func (*SetRequest_Request_Chassis) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40, 0, 2}
}
func (m *SetRequest_Request_Chassis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest_Request_Chassis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest_Request_Chassis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest_Request_Chassis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest_Request_Chassis.Merge(m, src)
}
func (m *SetRequest_Request_Chassis) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest_Request_Chassis) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest_Request_Chassis.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest_Request_Chassis proto.InternalMessageInfo

// Data required to set info for a specific optical network interface.
type SetRequest_Request_OpticalNetworkInterface struct {
	Module           int32 `protobuf:"varint,1,opt,name=module,proto3" json:"module,omitempty"`
	NetworkInterface int32 `protobuf:"varint,2,opt,name=network_interface,json=networkInterface,proto3" json:"network_interface,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo
	Value isSetRequest_Request_OpticalNetworkInterface_Value `protobuf_oneof:"value"`
}

func (m *SetRequest_Request_OpticalNetworkInterface) Reset() {
	*m = SetRequest_Request_OpticalNetworkInterface{}
}
func (m *SetRequest_Request_OpticalNetworkInterface) String() string {
	return proto.CompactTextString(m)
}
func (*SetRequest_Request_OpticalNetworkInterface) ProtoMessage() {}
func (*SetRequest_Request_OpticalNetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_13ce95ac99e1ae19, []int{40, 0, 3}
}
func (m *SetRequest_Request_OpticalNetworkInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest_Request_OpticalNetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest_Request_OpticalNetworkInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest_Request_OpticalNetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest_Request_OpticalNetworkInterface.Merge(m, src)
}
func (m *SetRequest_Request_OpticalNetworkInterface) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest_Request_OpticalNetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest_Request_OpticalNetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest_Request_OpticalNetworkInterface proto.InternalMessageInfo

type isSetRequest_Request_OpticalNetworkInterface_Value interface {
	isSetRequest_Request_OpticalNetworkInterface_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo struct {
	OpticalTransceiverInfo *OpticalTransceiverInfo `protobuf:"bytes,3,opt,name=optical_transceiver_info,json=opticalTransceiverInfo,proto3,oneof" json:"optical_transceiver_info,omitempty"`
}

func (*SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo) isSetRequest_Request_OpticalNetworkInterface_Value() {
}

func (m *SetRequest_Request_OpticalNetworkInterface) GetValue() isSetRequest_Request_OpticalNetworkInterface_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetRequest_Request_OpticalNetworkInterface) GetModule() int32 {
	if m != nil {
		return m.Module
	}
	return 0
}

func (m *SetRequest_Request_OpticalNetworkInterface) GetNetworkInterface() int32 {
	if m != nil {
		return m.NetworkInterface
	}
	return 0
}

func (m *SetRequest_Request_OpticalNetworkInterface) GetOpticalTransceiverInfo() *OpticalTransceiverInfo {
	if x, ok := m.GetValue().(*SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo); ok {
		return x.OpticalTransceiverInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SetRequest_Request_OpticalNetworkInterface) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo)(nil),
	}
}

func init() {
	proto.RegisterEnum("stratum.hal.OperationMode", OperationMode_name, OperationMode_value)
	proto.RegisterEnum("stratum.hal.TriState", TriState_name, TriState_value)
	proto.RegisterEnum("stratum.hal.Platform", Platform_name, Platform_value)
	proto.RegisterEnum("stratum.hal.TrafficClass", TrafficClass_name, TrafficClass_value)
	proto.RegisterEnum("stratum.hal.FecMode", FecMode_name, FecMode_value)
	proto.RegisterEnum("stratum.hal.PortState", PortState_name, PortState_value)
	proto.RegisterEnum("stratum.hal.TrunkState", TrunkState_name, TrunkState_value)
	proto.RegisterEnum("stratum.hal.TrunkMemberBlockState", TrunkMemberBlockState_name, TrunkMemberBlockState_value)
	proto.RegisterEnum("stratum.hal.LoopbackState", LoopbackState_name, LoopbackState_value)
	proto.RegisterEnum("stratum.hal.AdminState", AdminState_name, AdminState_value)
	proto.RegisterEnum("stratum.hal.HwState", HwState_name, HwState_value)
	proto.RegisterEnum("stratum.hal.HealthState", HealthState_name, HealthState_value)
	proto.RegisterEnum("stratum.hal.LedState", LedState_name, LedState_value)
	proto.RegisterEnum("stratum.hal.LedType", LedType_name, LedType_value)
	proto.RegisterEnum("stratum.hal.LedColor", LedColor_name, LedColor_value)
	proto.RegisterEnum("stratum.hal.PhysicalPortType", PhysicalPortType_name, PhysicalPortType_value)
	proto.RegisterEnum("stratum.hal.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("stratum.hal.SfpType", SfpType_name, SfpType_value)
	proto.RegisterEnum("stratum.hal.SfpModuleType", SfpModuleType_name, SfpModuleType_value)
	proto.RegisterEnum("stratum.hal.FanDir", FanDir_name, FanDir_value)
	proto.RegisterEnum("stratum.hal.PsuType", PsuType_name, PsuType_value)
	proto.RegisterEnum("stratum.hal.LedMode", LedMode_name, LedMode_value)
	proto.RegisterEnum("stratum.hal.ChassisConfigParams_TuntapConfig_Mode", ChassisConfigParams_TuntapConfig_Mode_name, ChassisConfigParams_TuntapConfig_Mode_value)
	proto.RegisterEnum("stratum.hal.NodeConfigParams_QosConfig_SchedulingMode", NodeConfigParams_QosConfig_SchedulingMode_name, NodeConfigParams_QosConfig_SchedulingMode_value)
	proto.RegisterEnum("stratum.hal.PortConfigParams_ModulationType", PortConfigParams_ModulationType_name, PortConfigParams_ModulationType_value)
	proto.RegisterEnum("stratum.hal.TrunkPort_TrunkType", TrunkPort_TrunkType_name, TrunkPort_TrunkType_value)
	proto.RegisterEnum("stratum.hal.GoogleConfig_BcmKnetIntfPurpose", GoogleConfig_BcmKnetIntfPurpose_name, GoogleConfig_BcmKnetIntfPurpose_value)
	proto.RegisterEnum("stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashField", GoogleConfig_BcmRtag7HashConfig_HashField_name, GoogleConfig_BcmRtag7HashConfig_HashField_value)
	proto.RegisterEnum("stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashBlock", GoogleConfig_BcmRtag7HashConfig_HashBlock_name, GoogleConfig_BcmRtag7HashConfig_HashBlock_value)
	proto.RegisterEnum("stratum.hal.GoogleConfig_BcmRtag7HashConfig_HashSubBlock", GoogleConfig_BcmRtag7HashConfig_HashSubBlock_name, GoogleConfig_BcmRtag7HashConfig_HashSubBlock_value)
	proto.RegisterEnum("stratum.hal.GoogleConfig_BcmRtag7HashConfig_Polynomial", GoogleConfig_BcmRtag7HashConfig_Polynomial_name, GoogleConfig_BcmRtag7HashConfig_Polynomial_value)
	proto.RegisterEnum("stratum.hal.TofinoConfig_TofinoQosConfig_ApplicationPool", TofinoConfig_TofinoQosConfig_ApplicationPool_name, TofinoConfig_TofinoQosConfig_ApplicationPool_value)
	proto.RegisterEnum("stratum.hal.TofinoConfig_TofinoQosConfig_Baf", TofinoConfig_TofinoQosConfig_Baf_name, TofinoConfig_TofinoQosConfig_Baf_value)
	proto.RegisterEnum("stratum.hal.TofinoConfig_TofinoQosConfig_SchedulingPriority", TofinoConfig_TofinoQosConfig_SchedulingPriority_name, TofinoConfig_TofinoQosConfig_SchedulingPriority_value)
	proto.RegisterEnum("stratum.hal.TofinoConfig_TofinoQosConfig_QueueColorLimit", TofinoConfig_TofinoQosConfig_QueueColorLimit_name, TofinoConfig_TofinoQosConfig_QueueColorLimit_value)
	proto.RegisterEnum("stratum.hal.Alarm_Severity", Alarm_Severity_name, Alarm_Severity_value)
	proto.RegisterType((*ChassisConfigParams)(nil), "stratum.hal.ChassisConfigParams")
	proto.RegisterType((*ChassisConfigParams_LacpConfig)(nil), "stratum.hal.ChassisConfigParams.LacpConfig")
	proto.RegisterType((*ChassisConfigParams_NtpConfig)(nil), "stratum.hal.ChassisConfigParams.NtpConfig")
	proto.RegisterType((*ChassisConfigParams_PowerConfig)(nil), "stratum.hal.ChassisConfigParams.PowerConfig")
	proto.RegisterType((*ChassisConfigParams_FanConfig)(nil), "stratum.hal.ChassisConfigParams.FanConfig")
	proto.RegisterType((*ChassisConfigParams_TuntapConfig)(nil), "stratum.hal.ChassisConfigParams.TuntapConfig")
	proto.RegisterType((*NodeFlowParams)(nil), "stratum.hal.NodeFlowParams")
	proto.RegisterType((*NodeConfigParams)(nil), "stratum.hal.NodeConfigParams")
	proto.RegisterType((*NodeConfigParams_VlanConfig)(nil), "stratum.hal.NodeConfigParams.VlanConfig")
	proto.RegisterType((*NodeConfigParams_L2Config)(nil), "stratum.hal.NodeConfigParams.L2Config")
	proto.RegisterType((*NodeConfigParams_QosConfig)(nil), "stratum.hal.NodeConfigParams.QosConfig")
	proto.RegisterType((*NodeConfigParams_QosConfig_SchedulerConfig)(nil), "stratum.hal.NodeConfigParams.QosConfig.SchedulerConfig")
	proto.RegisterType((*NodeConfigParams_QosConfig_Dot1PMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.Dot1pMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_DscpMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.DscpMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_TrafficClassMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.TrafficClassMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_PriorityGroupMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.PriorityGroupMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_CosqMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.CosqMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_IngressServicePoolMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.IngressServicePoolMapping")
	proto.RegisterType((*NodeConfigParams_QosConfig_EgressServicePoolMapping)(nil), "stratum.hal.NodeConfigParams.QosConfig.EgressServicePoolMapping")
	proto.RegisterType((*PortFlowParams)(nil), "stratum.hal.PortFlowParams")
	proto.RegisterType((*PortConfigParams)(nil), "stratum.hal.PortConfigParams")
	proto.RegisterType((*PortConfigParams_HashConfig)(nil), "stratum.hal.PortConfigParams.HashConfig")
	proto.RegisterType((*Chassis)(nil), "stratum.hal.Chassis")
	proto.RegisterType((*Node)(nil), "stratum.hal.Node")
	proto.RegisterType((*SingletonPort)(nil), "stratum.hal.SingletonPort")
	proto.RegisterType((*OpticalNetworkInterface)(nil), "stratum.hal.OpticalNetworkInterface")
	proto.RegisterType((*TrunkPort)(nil), "stratum.hal.TrunkPort")
	proto.RegisterType((*PortGroup)(nil), "stratum.hal.PortGroup")
	proto.RegisterType((*PortGroup_PortGroupMember)(nil), "stratum.hal.PortGroup.PortGroupMember")
	proto.RegisterType((*GoogleConfig)(nil), "stratum.hal.GoogleConfig")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmBufferConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToBufferConfigEntry")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmKnetConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToKnetConfigEntry")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmRateLimitConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToRateLimitConfigEntry")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmRtag7HashConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToRtag7HashConfigEntry")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmRxConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToRxConfigEntry")
	proto.RegisterMapType((map[uint64]*GoogleConfig_BcmTxConfig)(nil), "stratum.hal.GoogleConfig.NodeIdToTxConfigEntry")
	proto.RegisterType((*GoogleConfig_BcmKnetConfig)(nil), "stratum.hal.GoogleConfig.BcmKnetConfig")
	proto.RegisterType((*GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig)(nil), "stratum.hal.GoogleConfig.BcmKnetConfig.BcmKnetIntfConfig")
	proto.RegisterType((*GoogleConfig_BcmRxConfig)(nil), "stratum.hal.GoogleConfig.BcmRxConfig")
	proto.RegisterMapType((map[int32]*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig)(nil), "stratum.hal.GoogleConfig.BcmRxConfig.DmaChannelConfigsEntry")
	proto.RegisterType((*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig)(nil), "stratum.hal.GoogleConfig.BcmRxConfig.BcmDmaChannelConfig")
	proto.RegisterType((*GoogleConfig_BcmTxConfig)(nil), "stratum.hal.GoogleConfig.BcmTxConfig")
	proto.RegisterType((*GoogleConfig_BcmRateLimitConfig)(nil), "stratum.hal.GoogleConfig.BcmRateLimitConfig")
	proto.RegisterMapType((map[int32]*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig)(nil), "stratum.hal.GoogleConfig.BcmRateLimitConfig.PerCosRateLimitConfigsEntry")
	proto.RegisterType((*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig)(nil), "stratum.hal.GoogleConfig.BcmRateLimitConfig.BcmPerCosRateLimitConfig")
	proto.RegisterType((*GoogleConfig_BcmBufferConfig)(nil), "stratum.hal.GoogleConfig.BcmBufferConfig")
	proto.RegisterType((*GoogleConfig_BcmBufferConfig_ServicePoolConfig)(nil), "stratum.hal.GoogleConfig.BcmBufferConfig.ServicePoolConfig")
	proto.RegisterType((*GoogleConfig_BcmBufferConfig_PriorityGroupConig)(nil), "stratum.hal.GoogleConfig.BcmBufferConfig.PriorityGroupConig")
	proto.RegisterType((*GoogleConfig_BcmBufferConfig_CosqConfig)(nil), "stratum.hal.GoogleConfig.BcmBufferConfig.CosqConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig.HashFunctionConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig.MacroFlowHashConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig.MacroFlowHashConfig.TableConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig.PerTypeHashConfig")
	proto.RegisterType((*GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig)(nil), "stratum.hal.GoogleConfig.BcmRtag7HashConfig.PerTypeHashConfig.TableConfig")
	proto.RegisterType((*TofinoConfig)(nil), "stratum.hal.TofinoConfig")
	proto.RegisterMapType((map[uint64]*TofinoConfig_DeflectOnPacketDropConfig)(nil), "stratum.hal.TofinoConfig.NodeIdToDeflectOnDropConfigsEntry")
	proto.RegisterMapType((map[uint64]*TofinoConfig_BfPortShapingConfig)(nil), "stratum.hal.TofinoConfig.NodeIdToPortShapingConfigEntry")
	proto.RegisterMapType((map[uint64]*TofinoConfig_TofinoQosConfig)(nil), "stratum.hal.TofinoConfig.NodeIdToQosConfigEntry")
	proto.RegisterType((*TofinoConfig_PacketShape)(nil), "stratum.hal.TofinoConfig.PacketShape")
	proto.RegisterType((*TofinoConfig_ByteShape)(nil), "stratum.hal.TofinoConfig.ByteShape")
	proto.RegisterType((*TofinoConfig_BfPortShapingConfig)(nil), "stratum.hal.TofinoConfig.BfPortShapingConfig")
	proto.RegisterMapType((map[uint32]*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig)(nil), "stratum.hal.TofinoConfig.BfPortShapingConfig.PerPortShapingConfigsEntry")
	proto.RegisterType((*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig)(nil), "stratum.hal.TofinoConfig.BfPortShapingConfig.BfPerPortShapingConfig")
	proto.RegisterType((*TofinoConfig_DeflectOnPacketDropConfig)(nil), "stratum.hal.TofinoConfig.DeflectOnPacketDropConfig")
	proto.RegisterType((*TofinoConfig_DeflectOnPacketDropConfig_DropTarget)(nil), "stratum.hal.TofinoConfig.DeflectOnPacketDropConfig.DropTarget")
	proto.RegisterType((*TofinoConfig_TofinoQosConfig)(nil), "stratum.hal.TofinoConfig.TofinoQosConfig")
	proto.RegisterType((*TofinoConfig_TofinoQosConfig_PoolConfig)(nil), "stratum.hal.TofinoConfig.TofinoQosConfig.PoolConfig")
	proto.RegisterType((*TofinoConfig_TofinoQosConfig_PpgConfig)(nil), "stratum.hal.TofinoConfig.TofinoQosConfig.PpgConfig")
	proto.RegisterType((*TofinoConfig_TofinoQosConfig_QueueConfig)(nil), "stratum.hal.TofinoConfig.TofinoQosConfig.QueueConfig")
	proto.RegisterType((*TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping)(nil), "stratum.hal.TofinoConfig.TofinoQosConfig.QueueConfig.QueueMapping")
	proto.RegisterType((*VendorConfig)(nil), "stratum.hal.VendorConfig")
	proto.RegisterType((*ChassisConfig)(nil), "stratum.hal.ChassisConfig")
	proto.RegisterType((*SfpModuleCaps)(nil), "stratum.hal.SfpModuleCaps")
	proto.RegisterType((*FanCaps)(nil), "stratum.hal.FanCaps")
	proto.RegisterType((*PsuCaps)(nil), "stratum.hal.PsuCaps")
	proto.RegisterType((*ThermalCaps)(nil), "stratum.hal.ThermalCaps")
	proto.RegisterType((*LedCaps)(nil), "stratum.hal.LedCaps")
	proto.RegisterType((*FrontPanelPortInfo)(nil), "stratum.hal.FrontPanelPortInfo")
	proto.RegisterType((*OpticalTransceiverInfo)(nil), "stratum.hal.OpticalTransceiverInfo")
	proto.RegisterType((*OpticalTransceiverInfo_Power)(nil), "stratum.hal.OpticalTransceiverInfo.Power")
	proto.RegisterType((*OperStatus)(nil), "stratum.hal.OperStatus")
	proto.RegisterType((*LoopbackStatus)(nil), "stratum.hal.LoopbackStatus")
	proto.RegisterType((*AdminStatus)(nil), "stratum.hal.AdminStatus")
	proto.RegisterType((*MacAddress)(nil), "stratum.hal.MacAddress")
	proto.RegisterType((*PortSpeed)(nil), "stratum.hal.PortSpeed")
	proto.RegisterType((*SystemPriority)(nil), "stratum.hal.SystemPriority")
	proto.RegisterType((*PortCounters)(nil), "stratum.hal.PortCounters")
	proto.RegisterType((*PortQosCounters)(nil), "stratum.hal.PortQosCounters")
	proto.RegisterType((*Alarm)(nil), "stratum.hal.Alarm")
	proto.RegisterType((*NodeInfo)(nil), "stratum.hal.NodeInfo")
	proto.RegisterType((*NodeDebugInfo)(nil), "stratum.hal.NodeDebugInfo")
	proto.RegisterType((*ForwardingViability)(nil), "stratum.hal.ForwardingViability")
	proto.RegisterType((*HealthIndicator)(nil), "stratum.hal.HealthIndicator")
	proto.RegisterType((*AutonegotiationStatus)(nil), "stratum.hal.AutonegotiationStatus")
	proto.RegisterType((*FecStatus)(nil), "stratum.hal.FecStatus")
	proto.RegisterType((*SdnPortId)(nil), "stratum.hal.SdnPortId")
	proto.RegisterType((*DataRequest)(nil), "stratum.hal.DataRequest")
	proto.RegisterType((*DataRequest_Request)(nil), "stratum.hal.DataRequest.Request")
	proto.RegisterType((*DataRequest_Request_Port)(nil), "stratum.hal.DataRequest.Request.Port")
	proto.RegisterType((*DataRequest_Request_Node)(nil), "stratum.hal.DataRequest.Request.Node")
	proto.RegisterType((*DataRequest_Request_Chassis)(nil), "stratum.hal.DataRequest.Request.Chassis")
	proto.RegisterType((*DataRequest_Request_PortQueue)(nil), "stratum.hal.DataRequest.Request.PortQueue")
	proto.RegisterType((*DataRequest_Request_OpticalNetworkInterface)(nil), "stratum.hal.DataRequest.Request.OpticalNetworkInterface")
	proto.RegisterType((*DataResponse)(nil), "stratum.hal.DataResponse")
	proto.RegisterType((*SetRequest)(nil), "stratum.hal.SetRequest")
	proto.RegisterType((*SetRequest_Request)(nil), "stratum.hal.SetRequest.Request")
	proto.RegisterType((*SetRequest_Request_Port)(nil), "stratum.hal.SetRequest.Request.Port")
	proto.RegisterType((*SetRequest_Request_Node)(nil), "stratum.hal.SetRequest.Request.Node")
	proto.RegisterType((*SetRequest_Request_Chassis)(nil), "stratum.hal.SetRequest.Request.Chassis")
	proto.RegisterType((*SetRequest_Request_OpticalNetworkInterface)(nil), "stratum.hal.SetRequest.Request.OpticalNetworkInterface")
}

func init() {
	proto.RegisterFile("stratum/hal/lib/common/common.proto", fileDescriptor_13ce95ac99e1ae19)
}

var fileDescriptor_13ce95ac99e1ae19 = []byte{
	// 9373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x7d, 0x4b, 0x8c, 0x23, 0x49,
	0x76, 0x58, 0x27, 0x3f, 0x45, 0xf2, 0xf1, 0x97, 0x15, 0xf5, 0x67, 0x7f, 0xa6, 0x87, 0x33, 0x3b,
	0x33, 0x5b, 0x3b, 0xd3, 0x53, 0x55, 0x5d, 0xd3, 0xdd, 0x3b, 0xbb, 0xda, 0x19, 0x7e, 0xab, 0x38,
	0xcd, 0x22, 0x39, 0x49, 0x56, 0xf7, 0xf4, 0x08, 0x56, 0x2a, 0x49, 0x26, 0x59, 0xa9, 0x22, 0x33,
	0xb3, 0x32, 0x93, 0xdd, 0x55, 0x2b, 0x40, 0xb2, 0xe5, 0x95, 0x7d, 0xb0, 0xb5, 0xd8, 0x9b, 0x2c,
	0xc0, 0x10, 0x7c, 0xb4, 0x01, 0x03, 0xf2, 0x45, 0x30, 0x2c, 0xd9, 0xc0, 0xfa, 0x60, 0x43, 0x80,
	0x2f, 0x6b, 0x1f, 0x24, 0x43, 0x17, 0x0b, 0xbb, 0x30, 0x0c, 0xf9, 0x2e, 0xc1, 0xf0, 0xc1, 0x30,
	0xe2, 0x93, 0x5f, 0x26, 0xab, 0x8b, 0x33, 0xb3, 0x80, 0x4e, 0x8c, 0x7c, 0x2f, 0xde, 0x7b, 0x11,
	0x2f, 0x23, 0xde, 0x7b, 0xf1, 0x32, 0x22, 0x08, 0x6f, 0x99, 0x96, 0x21, 0x59, 0xb3, 0xe9, 0x87,
	0x67, 0xd2, 0xe4, 0xc3, 0x89, 0xd2, 0xff, 0x70, 0xa0, 0x4d, 0xa7, 0x9a, 0xca, 0x7e, 0x1e, 0xe8,
	0x86, 0x66, 0x69, 0x28, 0xcd, 0x2a, 0x3d, 0x38, 0x93, 0x26, 0xc5, 0x3f, 0x48, 0xc2, 0x5a, 0xe5,
	0x4c, 0x32, 0x4d, 0xc5, 0xac, 0x68, 0xea, 0x48, 0x19, 0x77, 0x24, 0x43, 0x9a, 0x9a, 0xa8, 0x09,
	0xe9, 0x89, 0x34, 0xd0, 0xc5, 0x01, 0x01, 0x6e, 0x73, 0xf7, 0xb9, 0xf7, 0xd2, 0x07, 0xdf, 0x79,
	0xe0, 0x21, 0x7d, 0x10, 0x42, 0xf6, 0xa0, 0x29, 0x0d, 0x74, 0x0a, 0x10, 0x60, 0xe2, 0x94, 0x51,
	0x03, 0x40, 0x95, 0x2d, 0x9b, 0x59, 0x84, 0x30, 0xdb, 0x7d, 0x2d, 0xb3, 0x96, 0x65, 0xf3, 0x4a,
	0xa9, 0xb2, 0xc5, 0x58, 0xb5, 0x21, 0xa3, 0x6b, 0xaf, 0x64, 0xc3, 0x66, 0x16, 0x25, 0xcc, 0xde,
	0x7f, 0x2d, 0xb3, 0x0e, 0x26, 0x62, 0xec, 0xd2, 0xba, 0xfb, 0x80, 0x9e, 0x42, 0x7a, 0x24, 0xa9,
	0x8c, 0x9d, 0xb9, 0x1d, 0xbb, 0x1f, 0xbd, 0x51, 0xe3, 0xea, 0x92, 0x6a, 0x77, 0x74, 0x64, 0x17,
	0x4d, 0xd4, 0x83, 0x9c, 0x35, 0x53, 0x2d, 0x49, 0x77, 0xf8, 0xc5, 0x09, 0xbf, 0x0f, 0x5e, 0xcb,
	0xaf, 0x47, 0xc8, 0x18, 0xcb, 0xac, 0xe5, 0x79, 0x32, 0x0b, 0x23, 0x00, 0x57, 0xb1, 0xe8, 0x1d,
	0xc8, 0x93, 0x57, 0x63, 0x68, 0x33, 0x4b, 0x36, 0xc4, 0xa9, 0x34, 0x20, 0xaf, 0x27, 0x26, 0x64,
	0x31, 0x58, 0x20, 0xd0, 0x13, 0x69, 0x80, 0xf6, 0x60, 0x9d, 0xd4, 0x33, 0xaf, 0x4c, 0x4b, 0x9e,
	0x8a, 0xba, 0xa1, 0x68, 0x86, 0x62, 0x5d, 0x11, 0xf5, 0x67, 0x05, 0x84, 0x71, 0x5d, 0x82, 0xea,
	0x30, 0x4c, 0x21, 0x0d, 0x29, 0x47, 0xe7, 0x85, 0x2c, 0xa4, 0x3d, 0x3a, 0x2b, 0xfc, 0x88, 0x83,
	0x94, 0xd3, 0x67, 0x94, 0x83, 0x88, 0x32, 0x24, 0x62, 0xb3, 0x42, 0x44, 0x19, 0xa2, 0x6f, 0x03,
	0x6f, 0xea, 0xb2, 0x3c, 0x14, 0x75, 0xd9, 0x18, 0xc8, 0xaa, 0x25, 0x8d, 0x65, 0x26, 0x27, 0x4f,
	0xe0, 0x1d, 0x07, 0x8c, 0xbe, 0x0f, 0x05, 0x4b, 0x32, 0xc6, 0xb2, 0x25, 0x5a, 0xf2, 0x54, 0x97,
	0xb1, 0x56, 0x0c, 0x59, 0x1c, 0xc8, 0x13, 0x53, 0x99, 0x99, 0xe4, 0x75, 0x66, 0x85, 0x6d, 0x5a,
	0xa3, 0xe7, 0x56, 0xa8, 0x50, 0x7c, 0xe1, 0xaf, 0x23, 0x90, 0xf1, 0xaa, 0x0a, 0x21, 0x88, 0xa9,
	0xd2, 0x54, 0x26, 0x6d, 0x49, 0x09, 0xa4, 0x8c, 0xea, 0x10, 0x9b, 0x6a, 0x43, 0xda, 0x82, 0xdc,
	0xc1, 0xc1, 0x52, 0xba, 0x7f, 0x70, 0xa2, 0x0d, 0x65, 0x81, 0xd0, 0xa3, 0x37, 0x21, 0xa3, 0xe8,
	0x2f, 0x0f, 0x45, 0x69, 0x38, 0x34, 0x64, 0x93, 0x36, 0x2e, 0x25, 0xa4, 0x31, 0xac, 0x44, 0x41,
	0xe8, 0x5b, 0x90, 0x23, 0x55, 0x74, 0x43, 0x1e, 0x29, 0x97, 0x13, 0x59, 0xdd, 0x8e, 0x91, 0x1e,
	0x64, 0x31, 0xb4, 0x63, 0x03, 0x19, 0xa7, 0x47, 0x0e, 0xa7, 0xb8, 0xc3, 0xe9, 0x91, 0x9f, 0xd3,
	0x23, 0x0f, 0xa7, 0x15, 0x87, 0xd3, 0x23, 0x97, 0xd3, 0xb7, 0x20, 0x37, 0x94, 0x47, 0xd2, 0x6c,
	0x62, 0x89, 0xaa, 0x6c, 0x0d, 0xe5, 0x97, 0xdb, 0x89, 0xfb, 0xdc, 0x7b, 0x49, 0x21, 0xcb, 0xa0,
	0x2d, 0x02, 0x2c, 0x96, 0x21, 0x86, 0x3b, 0x82, 0xd2, 0x90, 0x38, 0x6d, 0x3d, 0x6d, 0xb5, 0x9f,
	0xb7, 0xf8, 0x5b, 0x28, 0x03, 0xc9, 0x6a, 0xa3, 0x5b, 0x2a, 0x37, 0x6b, 0x55, 0x9e, 0x43, 0x59,
	0x48, 0x95, 0xdb, 0xed, 0x5e, 0xb7, 0x27, 0x94, 0x3a, 0x7c, 0x04, 0xf1, 0x90, 0x69, 0xb6, 0x4b,
	0x55, 0xb1, 0x5c, 0x6a, 0x96, 0x5a, 0x95, 0x1a, 0x1f, 0x2d, 0xf2, 0x90, 0x6b, 0x69, 0x43, 0xb9,
	0x3e, 0xd1, 0x5e, 0x51, 0x45, 0x15, 0xff, 0xef, 0x1a, 0xf0, 0x18, 0xe4, 0x33, 0x15, 0x4f, 0x21,
	0xf3, 0x72, 0xe2, 0x99, 0x41, 0x1c, 0x19, 0xf1, 0xef, 0xf9, 0xb4, 0x1e, 0x24, 0x7a, 0xf0, 0x6c,
	0xe2, 0xcc, 0x9f, 0xf4, 0xcb, 0x89, 0x3b, 0x81, 0x2a, 0x90, 0x9a, 0x1c, 0xf8, 0x0d, 0xc5, 0x3b,
	0xd7, 0x73, 0x6a, 0x1e, 0x30, 0x3e, 0xc9, 0x09, 0x2b, 0xa1, 0x3a, 0xc0, 0x85, 0x66, 0xfa, 0x2d,
	0xc4, 0xbb, 0xd7, 0x73, 0xf9, 0x5c, 0x33, 0x6d, 0x5b, 0x73, 0x61, 0x17, 0x0b, 0x7f, 0x18, 0x01,
	0x70, 0x1b, 0x8a, 0xb6, 0x20, 0x41, 0x3a, 0xca, 0x46, 0x7e, 0x5c, 0x58, 0xc1, 0x8f, 0x8d, 0x21,
	0x7a, 0x17, 0xf2, 0xfd, 0x89, 0x36, 0x38, 0x17, 0xfb, 0x86, 0x26, 0x0d, 0x07, 0x92, 0x69, 0x91,
	0xa6, 0x27, 0x85, 0x1c, 0x01, 0x97, 0x6d, 0x28, 0x3a, 0x80, 0x0d, 0x5a, 0xf1, 0x5c, 0xd5, 0x5e,
	0xa9, 0xe2, 0x74, 0x36, 0xb1, 0x14, 0x52, 0x3d, 0x4a, 0xaa, 0xaf, 0x11, 0xe4, 0x53, 0x8c, 0x3b,
	0xb1, 0x51, 0xe8, 0x11, 0x6c, 0x51, 0x9a, 0x99, 0x1a, 0xa4, 0x8a, 0x11, 0x2a, 0xca, 0xf2, 0x94,
	0x62, 0x5d, 0x3a, 0x47, 0x96, 0x4d, 0x37, 0x53, 0x29, 0x55, 0xdc, 0x23, 0x8b, 0x51, 0x9d, 0x52,
	0x14, 0x7a, 0x00, 0x6b, 0x43, 0xc5, 0x94, 0xfa, 0x13, 0x59, 0x9c, 0x1c, 0x88, 0x13, 0x59, 0x32,
	0x54, 0x45, 0x1d, 0x93, 0x81, 0x98, 0x14, 0x56, 0x19, 0xaa, 0x79, 0xd0, 0x64, 0x88, 0xc2, 0x77,
	0x21, 0x69, 0xab, 0x1f, 0x7d, 0x00, 0x6b, 0x93, 0x03, 0x51, 0x1a, 0xcb, 0xe2, 0x70, 0x66, 0x48,
	0x96, 0xa2, 0xa9, 0xa2, 0x29, 0x0f, 0x98, 0xa6, 0xf8, 0xc9, 0x41, 0x69, 0x2c, 0x57, 0x19, 0xa2,
	0x2b, 0x0f, 0x0a, 0x7f, 0x94, 0x87, 0x94, 0xa3, 0x74, 0x24, 0x42, 0xde, 0x1c, 0x9c, 0xc9, 0xc3,
	0xd9, 0x44, 0x51, 0xc7, 0x22, 0x99, 0xbc, 0x1c, 0x99, 0xbc, 0x8f, 0x6e, 0xf8, 0xda, 0x1e, 0x74,
	0x1d, 0x72, 0x32, 0x81, 0x73, 0xa6, 0xef, 0x19, 0x0d, 0x61, 0xd5, 0x23, 0xc0, 0x19, 0x5f, 0x78,
	0xa4, 0x3e, 0x5e, 0x52, 0x84, 0xe3, 0x46, 0x78, 0x97, 0x23, 0xeb, 0xc6, 0x0b, 0xc8, 0x0e, 0x35,
	0x6b, 0x5f, 0x17, 0xa7, 0x92, 0xae, 0x63, 0xcd, 0x45, 0x89, 0x84, 0xc3, 0x9b, 0x4a, 0xa8, 0x62,
	0xe2, 0x13, 0x4a, 0x2b, 0x64, 0x86, 0x9e, 0x27, 0xf4, 0x0c, 0x32, 0x43, 0x73, 0xe0, 0x72, 0xa6,
	0x7e, 0xea, 0xe1, 0x8d, 0x39, 0x9b, 0x03, 0x87, 0x71, 0x7a, 0xe8, 0x3e, 0x20, 0x0d, 0x36, 0x2c,
	0x43, 0x1a, 0x8d, 0x94, 0x81, 0x38, 0x98, 0x48, 0xa6, 0xe9, 0x08, 0xa0, 0x8e, 0xeb, 0x7b, 0x37,
	0x15, 0xd0, 0xa3, 0x4c, 0x2a, 0x98, 0x87, 0x2d, 0x68, 0xcd, 0x9a, 0x07, 0xe2, 0x8e, 0x0c, 0x34,
	0xf3, 0xc2, 0x91, 0xb3, 0xb2, 0x5c, 0x47, 0x2a, 0x9a, 0x79, 0xe1, 0x74, 0x64, 0xe0, 0x3e, 0x20,
	0x03, 0x36, 0x6d, 0x17, 0x27, 0x8e, 0x0d, 0x6d, 0xe6, 0xaa, 0x2a, 0x41, 0x24, 0x7c, 0xff, 0xa6,
	0x12, 0x6c, 0x77, 0x78, 0x84, 0x99, 0xd8, 0xa2, 0xd6, 0xf5, 0x10, 0x28, 0xfa, 0x1d, 0x0e, 0xee,
	0x28, 0xea, 0x18, 0xdb, 0x6f, 0xd1, 0x94, 0x8d, 0x97, 0xca, 0x40, 0x16, 0x75, 0x4d, 0x9b, 0x38,
	0xa2, 0x93, 0x44, 0x74, 0xe9, 0xa6, 0xa2, 0x1b, 0x94, 0x57, 0x97, 0xb2, 0xea, 0x68, 0xda, 0xc4,
	0x96, 0xbf, 0xa3, 0x2c, 0x42, 0xa1, 0xdf, 0x86, 0xdb, 0xf2, 0x35, 0x4d, 0x48, 0x91, 0x26, 0x7c,
	0x7a, 0xd3, 0x26, 0xd4, 0x16, 0xb5, 0x60, 0x5b, 0x5e, 0x80, 0x29, 0xfc, 0x57, 0x0e, 0xf2, 0x81,
	0xb9, 0x81, 0xbe, 0x03, 0xab, 0x8a, 0x6a, 0xc9, 0x86, 0x2a, 0x4d, 0xdc, 0xc8, 0x83, 0xc6, 0x0b,
	0xbc, 0x8d, 0xb0, 0x15, 0x4d, 0xa2, 0x07, 0x9b, 0x5e, 0x7c, 0x25, 0x2b, 0xe3, 0x33, 0xcb, 0x89,
	0x1e, 0x6c, 0xf8, 0x73, 0x02, 0xc6, 0x56, 0x6d, 0xaa, 0xa8, 0x62, 0x5f, 0x52, 0x87, 0xaf, 0x94,
	0xa1, 0x75, 0x66, 0x07, 0x1c, 0x2c, 0x70, 0x58, 0x9b, 0x2a, 0x6a, 0xd9, 0xc6, 0xb1, 0xa0, 0x83,
	0xd0, 0x48, 0x97, 0x21, 0x34, 0x31, 0x46, 0x23, 0x5d, 0x06, 0x69, 0x0a, 0x7d, 0xc8, 0x78, 0x27,
	0x23, 0x71, 0xbb, 0x64, 0x66, 0x07, 0x3a, 0x43, 0xe7, 0xbb, 0xd3, 0x93, 0xd0, 0x6e, 0x47, 0xc2,
	0xbb, 0x5d, 0xb0, 0x20, 0xed, 0x99, 0x96, 0xe8, 0x2e, 0x00, 0x99, 0xe1, 0xa6, 0x25, 0x19, 0x16,
	0x63, 0x9f, 0xc2, 0x90, 0x2e, 0x06, 0xa0, 0x1d, 0x48, 0x12, 0xb4, 0xac, 0x0e, 0x19, 0xc7, 0x04,
	0x7e, 0xae, 0xa9, 0xc3, 0x70, 0xa9, 0xd1, 0x05, 0x52, 0x7f, 0x87, 0x83, 0xb5, 0x90, 0xc9, 0xba,
	0xdc, 0x1b, 0xfb, 0x01, 0x64, 0x7d, 0x56, 0x83, 0x85, 0x5a, 0x3b, 0xbe, 0x51, 0xe6, 0x95, 0x22,
	0x64, 0xbc, 0xb6, 0xa0, 0xf0, 0x25, 0xac, 0x87, 0x4d, 0xb3, 0xe5, 0x1a, 0xb1, 0x01, 0x2b, 0xfa,
	0x58, 0x54, 0x67, 0x53, 0xa6, 0x8f, 0xb8, 0x3e, 0x6e, 0xcd, 0xa6, 0x85, 0x36, 0xa4, 0x3d, 0x46,
	0x62, 0x39, 0x96, 0x6b, 0x10, 0xbf, 0xf0, 0x70, 0x8c, 0x5d, 0x60, 0x86, 0x0d, 0xd8, 0x59, 0x38,
	0x31, 0x3d, 0x8d, 0xe0, 0x3c, 0x8d, 0xc0, 0x60, 0x53, 0xf7, 0xb6, 0xcd, 0xd4, 0x31, 0xab, 0x3a,
	0x6c, 0x2f, 0x9a, 0x60, 0xae, 0x6c, 0xce, 0x95, 0xbd, 0x80, 0x4f, 0xd1, 0x80, 0x9c, 0xdf, 0xe1,
	0xa1, 0x0d, 0x58, 0xfd, 0xbc, 0xdd, 0x15, 0xbb, 0x95, 0xe3, 0x5a, 0x55, 0x74, 0x43, 0x3e, 0x1e,
	0x32, 0x2e, 0xb8, 0xdb, 0xe1, 0x39, 0x3f, 0x44, 0x10, 0xf8, 0x08, 0x5a, 0x85, 0xac, 0x0b, 0x79,
	0x2e, 0x08, 0x7c, 0x14, 0x21, 0xc8, 0x79, 0x40, 0x55, 0x41, 0xe0, 0x63, 0x38, 0x1c, 0xec, 0x68,
	0x86, 0xe5, 0x09, 0x07, 0xff, 0x38, 0x0e, 0x3c, 0x06, 0xf9, 0xc2, 0xc1, 0x27, 0x90, 0x96, 0x86,
	0x78, 0x8e, 0x9a, 0x96, 0x64, 0xd9, 0x6e, 0x7c, 0xcb, 0x37, 0x30, 0x4a, 0x18, 0xdf, 0xc5, 0x68,
	0x01, 0x24, 0xa7, 0x8c, 0x78, 0x88, 0x4e, 0xad, 0x19, 0xe9, 0x68, 0x5c, 0xc0, 0x45, 0xf4, 0x21,
	0x24, 0xa4, 0x99, 0xa5, 0xa9, 0x32, 0x8d, 0xe2, 0x72, 0x07, 0x1b, 0x81, 0x01, 0xa6, 0x50, 0x2e,
	0x76, 0x2d, 0xd4, 0x80, 0xf4, 0x99, 0x64, 0x9e, 0xd9, 0x0e, 0x3e, 0x46, 0x42, 0x3f, 0x7f, 0x28,
	0x1a, 0x6c, 0xf0, 0x83, 0x63, 0xc9, 0x3c, 0xb3, 0x97, 0x72, 0x67, 0x4e, 0x19, 0x9d, 0x42, 0x7e,
	0xaa, 0x0d, 0x67, 0x13, 0x1a, 0xca, 0x58, 0x57, 0xba, 0x4c, 0x22, 0xa7, 0x5c, 0x60, 0xad, 0x39,
	0xc7, 0xee, 0xc4, 0x21, 0xea, 0x5d, 0xe9, 0xb2, 0x90, 0x9b, 0xfa, 0x9e, 0xd1, 0x87, 0x90, 0x1c,
	0xc9, 0x03, 0x1a, 0xe2, 0xac, 0x10, 0x7e, 0xeb, 0x3e, 0x7e, 0x75, 0x79, 0x40, 0x02, 0x98, 0xc4,
	0x88, 0x16, 0xb0, 0x3e, 0xa7, 0xd2, 0xc0, 0x59, 0x39, 0x24, 0x48, 0x97, 0xfc, 0xfa, 0x3c, 0x91,
	0x06, 0x6c, 0x15, 0x21, 0xc0, 0xd4, 0x29, 0xa3, 0x4f, 0x20, 0x3b, 0xd1, 0x34, 0xbd, 0x2f, 0x0d,
	0xce, 0xa9, 0xbc, 0x24, 0x91, 0x57, 0xf0, 0xd1, 0x36, 0x59, 0x0d, 0xaa, 0xc8, 0x8c, 0x4d, 0x80,
	0x45, 0x17, 0x2c, 0x00, 0x57, 0x39, 0xe8, 0x21, 0x6c, 0x1a, 0x96, 0x34, 0x7e, 0x2c, 0xca, 0x83,
	0xa9, 0x2e, 0x12, 0x35, 0x9b, 0xf2, 0x44, 0x1e, 0x58, 0x2c, 0xc6, 0x5b, 0x23, 0xd8, 0xda, 0x60,
	0xaa, 0x63, 0xa2, 0x2e, 0x41, 0xa1, 0x7d, 0xd8, 0xa0, 0x44, 0x13, 0x69, 0xec, 0xa3, 0xa1, 0x6f,
	0x19, 0x11, 0x64, 0x53, 0x1a, 0xbb, 0x24, 0xc5, 0x5f, 0x87, 0x9c, 0x5f, 0x87, 0xe8, 0x36, 0x6c,
	0x75, 0xda, 0x42, 0x4f, 0x3c, 0x69, 0x57, 0x4f, 0x9b, 0xa5, 0x5e, 0xa3, 0xdd, 0xf2, 0x8c, 0xf0,
	0x2d, 0x58, 0x0b, 0x22, 0x5b, 0xc2, 0x97, 0x3c, 0x87, 0xb6, 0x61, 0x3d, 0x88, 0xe8, 0x94, 0x4e,
	0x0e, 0xf9, 0x48, 0xf1, 0xf7, 0x39, 0x48, 0xb0, 0x75, 0x20, 0xda, 0x87, 0xa4, 0x3e, 0x91, 0xac,
	0x91, 0x66, 0x4c, 0xd9, 0x58, 0xf5, 0x8f, 0xb1, 0x0e, 0x43, 0x0a, 0x4e, 0x35, 0x67, 0xc9, 0x19,
	0xf1, 0x2c, 0x39, 0x6b, 0x90, 0xa5, 0x63, 0x4e, 0xd4, 0xc9, 0x30, 0x60, 0xab, 0x8e, 0xfb, 0xaf,
	0x5b, 0x7b, 0x0a, 0x99, 0x81, 0xe7, 0xa9, 0xf8, 0xe7, 0x1c, 0xc4, 0xb0, 0x73, 0xf6, 0x2c, 0xb0,
	0x63, 0x64, 0x81, 0x1d, 0x26, 0x13, 0x41, 0xcc, 0x9c, 0x68, 0xd4, 0xf5, 0xc5, 0x05, 0x52, 0x46,
	0xeb, 0x10, 0x57, 0xd4, 0xa1, 0x7c, 0x49, 0x86, 0x7e, 0x5c, 0xa0, 0x0f, 0xe8, 0xfb, 0x90, 0x1e,
	0x4d, 0xb4, 0x57, 0x76, 0xdb, 0xe2, 0xa4, 0x6d, 0xb7, 0xe7, 0x42, 0x02, 0x77, 0x6a, 0x0b, 0x30,
	0x72, 0xca, 0xa8, 0x1c, 0xec, 0xdb, 0x0a, 0xa1, 0xbf, 0x7b, 0x6d, 0x48, 0x11, 0xe8, 0xd8, 0xbf,
	0x8c, 0x40, 0xb6, 0xab, 0xa8, 0xe3, 0x89, 0x6c, 0x69, 0x2a, 0x9e, 0x33, 0x73, 0x29, 0x84, 0x9b,
	0xf6, 0x10, 0x41, 0x4c, 0xd7, 0x0c, 0x8b, 0x75, 0x90, 0x94, 0xd1, 0x36, 0x24, 0x06, 0x67, 0x92,
	0xaa, 0xca, 0x13, 0xd2, 0xb7, 0xb8, 0x60, 0x3f, 0xa2, 0xdb, 0x90, 0xa2, 0x89, 0x89, 0xbe, 0x4e,
	0xdb, 0x1d, 0x13, 0x92, 0x04, 0x50, 0xd6, 0x4d, 0x22, 0x12, 0xcf, 0x8b, 0x14, 0x81, 0x93, 0x72,
	0x50, 0x55, 0x89, 0x10, 0x55, 0xf9, 0xad, 0xe0, 0xf5, 0xaa, 0x4a, 0x86, 0xa8, 0x2a, 0x68, 0x32,
	0x02, 0xaa, 0xfa, 0x67, 0x11, 0xd8, 0x6a, 0xeb, 0x78, 0x15, 0x37, 0x69, 0xc9, 0xd6, 0x2b, 0xcd,
	0x38, 0x6f, 0x60, 0x37, 0x35, 0x92, 0x06, 0xf2, 0x8d, 0x94, 0xb6, 0x09, 0x2b, 0xc4, 0xe6, 0xc8,
	0x4c, 0x6d, 0xec, 0x09, 0x3b, 0x42, 0x95, 0xf2, 0x13, 0x15, 0x9b, 0x21, 0xd3, 0x22, 0xaf, 0x06,
	0x05, 0xdd, 0x81, 0xd4, 0xc8, 0x90, 0x2f, 0x66, 0xb2, 0x3a, 0xb8, 0x22, 0x3a, 0x8d, 0x09, 0x2e,
	0x00, 0xaf, 0x13, 0x59, 0x0e, 0x47, 0x9b, 0x59, 0xfa, 0xcc, 0x12, 0x49, 0x42, 0x8d, 0xe8, 0x97,
	0x13, 0x56, 0x29, 0xaa, 0x4d, 0x30, 0x24, 0x85, 0x84, 0x03, 0x3c, 0x8d, 0x64, 0x72, 0x14, 0x0d,
	0xbb, 0x61, 0x62, 0x8c, 0x12, 0x84, 0x69, 0xde, 0x03, 0x27, 0xe6, 0xee, 0x36, 0xa4, 0x26, 0x8a,
	0x8a, 0x63, 0x58, 0xc3, 0x22, 0xda, 0x4b, 0x09, 0x49, 0x0c, 0xc0, 0x4a, 0x2b, 0xfe, 0x45, 0x04,
	0x52, 0x3d, 0x63, 0xa6, 0x9e, 0x2f, 0x33, 0x82, 0xc8, 0x2b, 0x8e, 0x7a, 0x5e, 0xf1, 0x21, 0xc4,
	0x88, 0x39, 0x8f, 0x91, 0xe9, 0x7e, 0x3f, 0xe0, 0x52, 0x18, 0x77, 0x5a, 0x22, 0x26, 0x9c, 0xd4,
	0xc6, 0x63, 0x6c, 0x2a, 0x4f, 0xfb, 0xb2, 0x41, 0x73, 0x7a, 0x59, 0xc1, 0x7e, 0x0c, 0x0e, 0x99,
	0x95, 0xaf, 0x39, 0x64, 0x12, 0xcb, 0x0f, 0x99, 0x4f, 0x99, 0x5a, 0x88, 0xb5, 0x5c, 0x85, 0x2c,
	0xb3, 0x8e, 0x62, 0x4f, 0x38, 0x6d, 0x3d, 0xa5, 0x51, 0x40, 0xb7, 0x57, 0xea, 0x35, 0x2a, 0x0c,
	0xc2, 0xa1, 0x1c, 0x40, 0xb3, 0x54, 0xe9, 0xb0, 0xe7, 0x48, 0xf1, 0x5f, 0x73, 0x90, 0xc2, 0x42,
	0x48, 0x34, 0x76, 0x23, 0xcd, 0x7e, 0xea, 0xea, 0x83, 0xae, 0x72, 0xdf, 0x99, 0x6b, 0x31, 0x61,
	0xe6, 0x96, 0x4e, 0x48, 0x75, 0x47, 0x6f, 0x85, 0xef, 0x42, 0x3e, 0x80, 0x9b, 0x13, 0xbc, 0x09,
	0x2b, 0x9e, 0xf5, 0x40, 0x5c, 0x60, 0x4f, 0xc5, 0xdf, 0xdb, 0x87, 0xcc, 0x91, 0xa6, 0x8d, 0x27,
	0xb2, 0xb3, 0xde, 0x40, 0xfd, 0xc1, 0x54, 0x1c, 0x50, 0x0b, 0x8b, 0x17, 0x3f, 0x76, 0x9a, 0x26,
	0x25, 0xe4, 0xfb, 0x83, 0x29, 0x33, 0xbd, 0x27, 0x92, 0xde, 0x18, 0x22, 0x19, 0x36, 0xf1, 0x40,
	0x10, 0x95, 0xa1, 0x68, 0x69, 0xe2, 0xb9, 0x2f, 0x35, 0x8d, 0x7b, 0xb2, 0xef, 0xeb, 0x89, 0x57,
	0x0e, 0x31, 0x73, 0x8d, 0x61, 0x4f, 0x7b, 0xea, 0x64, 0xa4, 0x6b, 0xaa, 0x65, 0x5c, 0x09, 0x48,
	0x9d, 0x43, 0x20, 0x11, 0xd6, 0x3d, 0x62, 0x8c, 0x4b, 0x37, 0x21, 0x85, 0x85, 0x7c, 0xf8, 0x7a,
	0x21, 0xc2, 0xa5, 0x57, 0x04, 0xaf, 0x06, 0xc0, 0x01, 0x01, 0xd6, 0xa5, 0x1b, 0xf6, 0xdc, 0x50,
	0x40, 0x2f, 0x5c, 0x80, 0x0d, 0x46, 0x33, 0xb8, 0xe3, 0xed, 0x81, 0x64, 0xc9, 0xe2, 0x44, 0x99,
	0x2a, 0x8e, 0xba, 0x68, 0x8e, 0xe0, 0xd1, 0x0d, 0x7a, 0x22, 0x59, 0x72, 0x13, 0x53, 0x7a, 0xe5,
	0x6d, 0xa9, 0xe1, 0x58, 0x74, 0x0e, 0xdb, 0x1e, 0xb1, 0xfd, 0xd9, 0x68, 0xe4, 0xe6, 0xfb, 0xc3,
	0xd2, 0x05, 0xa1, 0x22, 0xcb, 0x84, 0xcc, 0x2b, 0x6f, 0x5d, 0x0d, 0x41, 0x05, 0xfb, 0x48, 0x82,
	0x15, 0x6f, 0x0c, 0x99, 0xb8, 0x71, 0x1f, 0x31, 0xa9, 0x1b, 0x2f, 0x05, 0xfb, 0xe8, 0xc7, 0x16,
	0x7e, 0x3f, 0x02, 0xd9, 0xf2, 0x60, 0xea, 0x19, 0x2e, 0x32, 0xac, 0x92, 0xa1, 0xa8, 0xa8, 0xd6,
	0x28, 0x90, 0x4c, 0xfd, 0xee, 0x62, 0xe9, 0x3e, 0x1e, 0xf6, 0x53, 0x43, 0xb5, 0x46, 0x2c, 0xa4,
	0xcd, 0x9f, 0xfb, 0x9e, 0xcd, 0xc2, 0x1f, 0x72, 0xb0, 0x3a, 0x57, 0xcd, 0x8e, 0xbd, 0x39, 0x37,
	0xf6, 0xbe, 0x0d, 0xa9, 0x81, 0x3e, 0x13, 0x2f, 0x66, 0xf2, 0x4c, 0x66, 0xb3, 0x2f, 0x39, 0xd0,
	0x67, 0x9f, 0xe3, 0x67, 0x6c, 0x10, 0x5e, 0x4e, 0x24, 0xd5, 0x76, 0xcc, 0xb8, 0x8c, 0xea, 0x90,
	0xd0, 0x67, 0x86, 0xae, 0x99, 0xb6, 0x65, 0x7d, 0xff, 0xb5, 0xad, 0xc6, 0x0d, 0xe8, 0x50, 0x1a,
	0xc1, 0x26, 0x2e, 0xfc, 0x6d, 0x1c, 0xd2, 0xe5, 0xc1, 0xd4, 0x19, 0xe5, 0xdf, 0x86, 0x55, 0xe3,
	0x92, 0xe6, 0x34, 0xf4, 0x73, 0x3c, 0xf4, 0x66, 0xaa, 0x1d, 0x72, 0xe6, 0x8c, 0x4b, 0xbc, 0x82,
	0xea, 0x9c, 0x5b, 0x15, 0x0c, 0x45, 0x7b, 0xb0, 0x61, 0x57, 0xed, 0x5f, 0x59, 0xb2, 0x89, 0x57,
	0xfa, 0x98, 0x88, 0xb5, 0x7f, 0x95, 0x56, 0x2f, 0x63, 0x54, 0x47, 0x36, 0x3a, 0xe7, 0x16, 0xb6,
	0x1b, 0x53, 0xe9, 0x92, 0x30, 0x36, 0x95, 0x1f, 0xca, 0x94, 0x8c, 0x75, 0x2b, 0x3f, 0x95, 0x2e,
	0x3b, 0xe7, 0x56, 0x57, 0xf9, 0xa1, 0x4c, 0x48, 0xd0, 0xdb, 0x90, 0xd3, 0xcf, 0x2d, 0xca, 0x75,
	0x70, 0x26, 0x29, 0x2a, 0x73, 0x9f, 0x19, 0x0c, 0xed, 0xc8, 0x46, 0x05, 0xc3, 0xd0, 0x7d, 0xc8,
	0x60, 0x96, 0x64, 0xb6, 0xe8, 0xba, 0xc9, 0x22, 0x12, 0x98, 0x4a, 0x97, 0x78, 0x9c, 0x77, 0x74,
	0xc2, 0x87, 0x24, 0x24, 0x66, 0x86, 0x69, 0x61, 0xd1, 0xd4, 0x67, 0xc4, 0x05, 0x4c, 0x57, 0xc6,
	0xc0, 0xce, 0xb9, 0x65, 0xa2, 0xb7, 0x20, 0x3b, 0x33, 0x65, 0xea, 0xab, 0x8d, 0x99, 0x6e, 0xb1,
	0x44, 0x7f, 0x66, 0x66, 0xca, 0x0d, 0x1b, 0x86, 0x26, 0xb0, 0x36, 0x9c, 0x4a, 0x22, 0x0b, 0x77,
	0x9c, 0x61, 0x93, 0x0c, 0x49, 0x79, 0x05, 0x5f, 0x80, 0xad, 0xe0, 0x07, 0xd5, 0xa9, 0x54, 0xa1,
	0xf4, 0x6c, 0x8c, 0xd0, 0xa1, 0xbb, 0x3a, 0x0c, 0xc2, 0x0b, 0x7f, 0xc9, 0xc1, 0x5a, 0x79, 0x30,
	0x0d, 0x12, 0x60, 0x33, 0x4d, 0xf4, 0x61, 0xda, 0x89, 0x71, 0xfa, 0x44, 0xa2, 0x2f, 0xcb, 0x50,
	0x74, 0x71, 0x60, 0x0c, 0x58, 0x4a, 0x3c, 0x49, 0x00, 0x15, 0x63, 0x80, 0xee, 0x02, 0x50, 0xa4,
	0x33, 0x92, 0x92, 0x02, 0xad, 0xfe, 0x0c, 0x0f, 0xa7, 0x3d, 0x58, 0xd7, 0x5e, 0xca, 0x06, 0x7e,
	0x2b, 0x43, 0x51, 0x97, 0x06, 0xe7, 0xb2, 0x65, 0x8a, 0xda, 0x39, 0x4b, 0x7a, 0x23, 0x07, 0xd7,
	0xa1, 0xa8, 0xf6, 0x39, 0x56, 0xab, 0xaa, 0x91, 0x57, 0xa9, 0x4b, 0x86, 0x49, 0x73, 0x98, 0x44,
	0x63, 0xaa, 0xd6, 0x39, 0xb7, 0x3a, 0x14, 0x86, 0xb6, 0x20, 0x31, 0xd0, 0x4c, 0xd1, 0x94, 0x2d,
	0x62, 0x4b, 0x70, 0x63, 0x35, 0xb3, 0x2b, 0x5b, 0x85, 0xdf, 0x86, 0xcd, 0x70, 0x4d, 0xe0, 0xc9,
	0x71, 0x2e, 0x5f, 0xd9, 0x93, 0xe3, 0x5c, 0xbe, 0x42, 0x6d, 0x88, 0xbf, 0x94, 0x26, 0x6c, 0x62,
	0xbc, 0x6e, 0x7e, 0x3a, 0x8a, 0x0e, 0x51, 0x9d, 0x40, 0xf9, 0x7c, 0x1c, 0x79, 0xc2, 0x15, 0xb2,
	0x64, 0xdc, 0xdb, 0xc6, 0xb7, 0xf0, 0x97, 0x51, 0x40, 0x98, 0x3a, 0x60, 0x1c, 0x83, 0xc3, 0x8b,
	0xbb, 0xc1, 0xf0, 0x8a, 0x84, 0x0c, 0xaf, 0x1f, 0x71, 0x50, 0x20, 0x03, 0x59, 0x33, 0xe7, 0x2d,
	0xbb, 0xed, 0xd3, 0x8f, 0xaf, 0xef, 0x98, 0xbf, 0x69, 0x0f, 0xf0, 0x14, 0xd0, 0xcc, 0x00, 0x94,
	0x8d, 0xa6, 0x4d, 0x3d, 0x14, 0x59, 0xe8, 0xc3, 0x76, 0x79, 0x30, 0x0d, 0xa5, 0xfc, 0xa6, 0xba,
	0x5a, 0xf8, 0x09, 0x07, 0xb7, 0xaf, 0x69, 0x5b, 0xc8, 0xfb, 0xfd, 0x55, 0xff, 0xfb, 0xad, 0x2d,
	0xa5, 0x86, 0x45, 0xfd, 0xf1, 0xbe, 0xeb, 0xff, 0x11, 0x87, 0x7c, 0x79, 0x30, 0xf5, 0x79, 0xa2,
	0x5d, 0x58, 0x1d, 0x4f, 0xb4, 0xbe, 0x34, 0x11, 0xcf, 0x86, 0xc6, 0x94, 0xbe, 0x0f, 0x16, 0x0b,
	0xe5, 0x29, 0xe2, 0x78, 0x68, 0x4c, 0x09, 0x43, 0xb4, 0x03, 0x49, 0x1c, 0x21, 0x8b, 0x53, 0x45,
	0xb5, 0xb3, 0x81, 0xf8, 0xf9, 0x44, 0x51, 0x0b, 0x3f, 0xe6, 0x60, 0xd5, 0x93, 0x5e, 0x62, 0xcc,
	0xdd, 0x44, 0x12, 0xe7, 0x49, 0x24, 0xe1, 0xf5, 0x39, 0x56, 0xa0, 0x9d, 0xc4, 0xee, 0xcf, 0x46,
	0xcc, 0x04, 0xb2, 0xaf, 0xc4, 0x53, 0xe9, 0x92, 0xe5, 0xbe, 0xca, 0xb3, 0x11, 0xb5, 0x82, 0x1f,
	0xc2, 0x3a, 0x26, 0x91, 0x83, 0x14, 0x34, 0xe1, 0xb8, 0x3a, 0x95, 0x2e, 0x6b, 0x3e, 0x82, 0xc2,
	0x7f, 0xe3, 0x00, 0xf9, 0xb2, 0x7d, 0x15, 0x4d, 0x55, 0xae, 0xcb, 0x9c, 0xe9, 0x63, 0x4f, 0xbf,
	0xe2, 0xfa, 0xf8, 0x44, 0x51, 0x71, 0x43, 0xf5, 0x31, 0x55, 0x0c, 0x53, 0x92, 0xac, 0x4a, 0x7d,
	0xb6, 0xc8, 0xc9, 0x0a, 0x48, 0x1f, 0x63, 0xe5, 0x1c, 0x11, 0x54, 0x8d, 0x60, 0x70, 0x43, 0xf5,
	0xb1, 0x68, 0x9e, 0x49, 0x86, 0x3c, 0xb4, 0x47, 0xb7, 0x3c, 0x99, 0xb0, 0xb4, 0xef, 0xaa, 0x3e,
	0xee, 0x12, 0x14, 0x7d, 0x43, 0xf2, 0x64, 0x82, 0x5f, 0x80, 0x4b, 0x30, 0xbc, 0x52, 0xa5, 0xa9,
	0x32, 0x20, 0x36, 0x24, 0x2b, 0xe4, 0xed, 0xda, 0x55, 0x0a, 0x26, 0xdf, 0x06, 0x2b, 0x9a, 0x79,
	0xc1, 0xd4, 0x1b, 0x9a, 0xbc, 0x23, 0x40, 0xb7, 0x27, 0xb1, 0x0b, 0xdc, 0x91, 0xb7, 0x21, 0x77,
	0xc1, 0x5a, 0xe3, 0xeb, 0x41, 0xe6, 0x82, 0x34, 0x84, 0xb5, 0xfd, 0x1d, 0xc8, 0xdb, 0xb5, 0xec,
	0x86, 0xb0, 0x0f, 0xcb, 0xb4, 0x1a, 0x6b, 0x06, 0xfa, 0x00, 0xd6, 0x2e, 0x42, 0xba, 0x48, 0x1b,
	0xcd, 0x5f, 0x04, 0x7b, 0xe8, 0xad, 0x2e, 0x4d, 0xf4, 0x33, 0x89, 0x56, 0x5f, 0xf1, 0x55, 0x2f,
	0x61, 0x04, 0xa9, 0xfe, 0x31, 0x14, 0x2e, 0xc4, 0x81, 0x36, 0xd1, 0x0c, 0x7f, 0x5b, 0x28, 0x55,
	0x82, 0x50, 0x6d, 0x5e, 0x54, 0x70, 0x05, 0x6f, 0xab, 0x30, 0x6d, 0xe1, 0x4f, 0xd6, 0xa8, 0xf9,
	0xf2, 0xc7, 0x3d, 0xe8, 0x3e, 0xa4, 0x87, 0xb2, 0x39, 0x30, 0x14, 0x1d, 0x2f, 0xfa, 0x58, 0x84,
	0xee, 0x05, 0x21, 0x13, 0x36, 0x48, 0xfc, 0x35, 0x9a, 0xa9, 0x03, 0x92, 0x7b, 0xb3, 0x4d, 0x12,
	0x0d, 0xce, 0x3f, 0xb9, 0x7e, 0x2e, 0xfa, 0xc5, 0x91, 0xe4, 0x5e, 0x9d, 0x31, 0x62, 0xb3, 0x70,
	0xed, 0x6c, 0x0e, 0x66, 0xa2, 0x19, 0x6c, 0x4e, 0xa5, 0x81, 0xa1, 0x89, 0x64, 0x25, 0xe7, 0x8d,
	0xff, 0x68, 0x22, 0xe7, 0xd3, 0xa5, 0xa4, 0x9e, 0x60, 0x56, 0x78, 0xbd, 0xe7, 0xc9, 0x2d, 0xae,
	0x4d, 0xe7, 0x81, 0xe8, 0x0c, 0x78, 0x37, 0x9b, 0xe6, 0x4b, 0x5a, 0xfe, 0x60, 0x29, 0x81, 0x1d,
	0xd9, 0xc0, 0x6b, 0x3f, 0x8f, 0xb8, 0x9c, 0xcc, 0x12, 0x71, 0x4c, 0xd2, 0x08, 0xf2, 0x4e, 0x0a,
	0xce, 0x89, 0xde, 0xbf, 0x09, 0x41, 0xd9, 0x09, 0xcd, 0xde, 0x31, 0xaf, 0xf5, 0xff, 0x22, 0x80,
	0xe6, 0x95, 0x8e, 0x9a, 0x10, 0x27, 0x1f, 0x9c, 0x43, 0x3f, 0xeb, 0xde, 0xe4, 0x25, 0x96, 0x31,
	0xb5, 0x40, 0x99, 0x90, 0xbc, 0x90, 0x2c, 0x0f, 0x99, 0xb1, 0x27, 0x65, 0xd4, 0x82, 0x95, 0x91,
	0x22, 0x4f, 0x86, 0xd4, 0x75, 0x7d, 0x15, 0x11, 0x75, 0x4c, 0x2e, 0x30, 0x2e, 0xe8, 0x4b, 0xc8,
	0xe8, 0xda, 0xe4, 0x4a, 0xd5, 0xa6, 0x8a, 0x34, 0x11, 0xf7, 0x58, 0x4c, 0xfb, 0x78, 0x39, 0x6d,
	0x39, 0x0c, 0x84, 0xb4, 0xcb, 0x6c, 0x2f, 0xc0, 0x7b, 0x9f, 0x25, 0x96, 0xbf, 0x09, 0xde, 0xfb,
	0x85, 0x3f, 0x8a, 0xc1, 0x5a, 0xc8, 0xf8, 0x43, 0xcf, 0x01, 0xdc, 0x6a, 0xec, 0x35, 0x7c, 0x65,
	0x89, 0x1e, 0x56, 0xe8, 0x02, 0xb2, 0x16, 0xd9, 0x32, 0xe0, 0x9f, 0xa7, 0xcd, 0xaf, 0x3b, 0x63,
	0x1e, 0xf4, 0x30, 0x57, 0x36, 0xca, 0x32, 0x96, 0xfb, 0x40, 0xdc, 0x3e, 0x0e, 0x8d, 0xa7, 0x66,
	0x5f, 0xdc, 0x7f, 0xd4, 0x57, 0x2c, 0x93, 0x85, 0x8f, 0x38, 0x36, 0x3e, 0x31, 0xfb, 0x14, 0x86,
	0xde, 0x85, 0xbc, 0x21, 0xa9, 0x43, 0x6d, 0x8a, 0x03, 0x7b, 0x42, 0xcf, 0x82, 0xc7, 0x9c, 0x03,
	0x26, 0x22, 0xd0, 0x77, 0x60, 0x95, 0x42, 0x44, 0xc5, 0x62, 0xd9, 0x28, 0x3b, 0x6c, 0xe7, 0x29,
	0xa2, 0xe1, 0xc0, 0x9d, 0xb1, 0xb7, 0xe2, 0x8e, 0xbd, 0xc2, 0x9f, 0x72, 0x90, 0xf6, 0xb4, 0x16,
	0x3d, 0x83, 0x94, 0x39, 0xeb, 0x8b, 0xde, 0x11, 0xff, 0xdd, 0xa5, 0x87, 0x63, 0x77, 0xd6, 0xa7,
	0x83, 0x3e, 0x69, 0xb2, 0x12, 0x7a, 0x03, 0xd2, 0x24, 0xa1, 0xcb, 0xbe, 0x11, 0xd2, 0xe1, 0x0f,
	0x04, 0x44, 0x3f, 0x12, 0xde, 0x86, 0x14, 0xad, 0x20, 0xab, 0x43, 0xb6, 0x8a, 0x49, 0x12, 0x40,
	0x4d, 0x25, 0xc9, 0x14, 0x6d, 0x34, 0xc2, 0x81, 0x2f, 0x75, 0x25, 0xec, 0xa9, 0xf0, 0x9f, 0xa2,
	0xb0, 0x3a, 0x37, 0xaf, 0xbf, 0xe1, 0x19, 0xab, 0x43, 0xce, 0x3b, 0x48, 0xc4, 0x3d, 0x16, 0x59,
	0x7d, 0xf6, 0xf5, 0xac, 0xcf, 0xc2, 0x31, 0xb2, 0x37, 0x27, 0x71, 0x9f, 0x59, 0xf2, 0x5f, 0x96,
	0xc4, 0x7d, 0xf4, 0x1e, 0xf0, 0x24, 0x26, 0xf3, 0x7e, 0xe6, 0xa0, 0x0b, 0xc4, 0x1c, 0x86, 0xbb,
	0x9f, 0x38, 0x0a, 0x3d, 0xff, 0x70, 0x71, 0x5f, 0x0c, 0x5b, 0x3e, 0xd1, 0x27, 0xec, 0xad, 0xc9,
	0x30, 0xf7, 0x3b, 0x26, 0xb6, 0x90, 0xe2, 0xf1, 0x58, 0xf7, 0xce, 0x9a, 0xe2, 0xbf, 0xe7, 0x20,
	0xe5, 0xd8, 0x31, 0x6f, 0x1a, 0xb0, 0xde, 0xa8, 0x35, 0xab, 0xfc, 0x2d, 0x04, 0xb0, 0xd2, 0x15,
	0x2a, 0x62, 0xa3, 0xc3, 0x73, 0xb8, 0x5c, 0xed, 0xf6, 0x70, 0x39, 0x82, 0x32, 0x90, 0xc4, 0xf0,
	0x4e, 0x5b, 0xe8, 0xf1, 0x51, 0xb2, 0x4b, 0xac, 0xdb, 0xa3, 0x4f, 0x31, 0x94, 0x86, 0xc4, 0xb3,
	0x66, 0xa9, 0x25, 0x36, 0xaa, 0x7c, 0x1c, 0xa3, 0x1a, 0x1d, 0xb1, 0x23, 0xb4, 0x7b, 0x6d, 0x7e,
	0x05, 0xe5, 0x00, 0x4e, 0x3a, 0xcd, 0xae, 0xd8, 0x2c, 0x95, 0x6b, 0x4d, 0x3e, 0x81, 0xee, 0x41,
	0xa1, 0xd1, 0x79, 0xf6, 0x48, 0x6c, 0xb6, 0xc5, 0x7a, 0xb3, 0xfd, 0x9c, 0xc2, 0xc5, 0xfd, 0x47,
	0x62, 0xb9, 0xd1, 0xeb, 0xf2, 0x49, 0x74, 0x17, 0x76, 0x08, 0xfe, 0xb8, 0xe1, 0xc5, 0x1f, 0x52,
	0x74, 0xaa, 0xf8, 0x88, 0xb6, 0x9e, 0x8e, 0x74, 0x4f, 0xeb, 0xcb, 0xcd, 0x76, 0xe5, 0x29, 0x6d,
	0xbd, 0xd0, 0x2b, 0x1d, 0x3d, 0x2e, 0xd1, 0xd6, 0x93, 0x72, 0x99, 0x8f, 0x14, 0x5f, 0x40, 0xc6,
	0x3b, 0x5d, 0xd0, 0x06, 0xac, 0xda, 0xa4, 0xdd, 0xd3, 0xb2, 0x43, 0x9e, 0x86, 0x04, 0x25, 0xdf,
	0xe3, 0x39, 0xe7, 0xa1, 0xbc, 0xc7, 0x47, 0x5c, 0xcc, 0x3e, 0x1f, 0x75, 0x31, 0xfb, 0x7c, 0xac,
	0xf8, 0xb7, 0x1c, 0x80, 0x6b, 0xf5, 0xd0, 0x26, 0x20, 0x9b, 0x73, 0xa7, 0xdd, 0x7c, 0xd1, 0x6a,
	0x9f, 0x34, 0x4a, 0x4d, 0xda, 0xb2, 0x72, 0xa3, 0xfb, 0xa2, 0x55, 0xe1, 0x39, 0x94, 0x87, 0x34,
	0x2d, 0x8b, 0x5f, 0xb4, 0x85, 0x7d, 0x3e, 0xe2, 0x07, 0x1c, 0xf0, 0x51, 0x3f, 0xe0, 0x90, 0x8f,
	0xf9, 0x01, 0x4f, 0xf8, 0x38, 0x4a, 0x41, 0xbc, 0x52, 0x69, 0xf4, 0x7a, 0xfc, 0x0a, 0x2e, 0x62,
	0x3e, 0x8f, 0xf8, 0x04, 0x56, 0x7e, 0x45, 0xa8, 0x3c, 0x3c, 0x10, 0x9b, 0x6d, 0x3e, 0xe9, 0x3e,
	0x1d, 0x37, 0xf8, 0x14, 0xe2, 0x21, 0x43, 0x9f, 0x6a, 0xbd, 0x63, 0x8c, 0x07, 0x3f, 0xe4, 0xb8,
	0xc1, 0xa7, 0xd1, 0x3a, 0xf0, 0x14, 0xf2, 0xb4, 0xdd, 0xee, 0x9c, 0x94, 0x5a, 0xb8, 0x5e, 0x66,
	0x1e, 0x7a, 0xdc, 0xe0, 0xb3, 0x05, 0x15, 0xb6, 0x16, 0x64, 0x3a, 0xbd, 0x8b, 0xa5, 0x18, 0x5d,
	0x2c, 0xfd, 0x8a, 0x7f, 0xb1, 0xf4, 0xee, 0x0d, 0x93, 0x55, 0xde, 0xe5, 0xd0, 0x6f, 0xc0, 0x46,
	0x68, 0xd2, 0x33, 0x44, 0xda, 0xf7, 0xfc, 0xd2, 0xbe, 0x75, 0xa3, 0xa5, 0xf7, 0x02, 0x59, 0xbd,
	0x6f, 0x52, 0x56, 0x2f, 0x44, 0xd6, 0x25, 0xdc, 0xb9, 0x2e, 0x05, 0x1a, 0x22, 0xb2, 0xec, 0x17,
	0xf9, 0xfe, 0x32, 0x2b, 0x4f, 0xaf, 0x64, 0x03, 0x76, 0x16, 0x66, 0x42, 0x43, 0xc4, 0x7e, 0xe2,
	0x17, 0xfb, 0xed, 0x6b, 0xc5, 0x7a, 0x19, 0x2e, 0xea, 0x6d, 0x48, 0x32, 0xf4, 0x6b, 0xf7, 0xd6,
	0xcf, 0xd3, 0x23, 0xb9, 0xf8, 0x5b, 0x64, 0xad, 0x11, 0x48, 0x29, 0xa2, 0x37, 0xe1, 0x6e, 0xb9,
	0x72, 0x22, 0x3e, 0x6d, 0xd5, 0x7a, 0x62, 0xa3, 0xd5, 0xab, 0x8b, 0x9d, 0x53, 0xa1, 0xd3, 0xee,
	0xd6, 0x3c, 0x5f, 0x8f, 0xdf, 0x86, 0xfb, 0xe1, 0x55, 0x2a, 0xed, 0x56, 0x4f, 0x68, 0x37, 0x9b,
	0x35, 0x81, 0xe7, 0xd0, 0x1b, 0x70, 0x3b, 0xbc, 0x56, 0x17, 0x1b, 0x32, 0x3e, 0x52, 0xfc, 0x9b,
	0x77, 0x20, 0xd3, 0xd3, 0x46, 0x8a, 0xaa, 0x31, 0x93, 0xfe, 0x9b, 0x70, 0xcf, 0x93, 0x55, 0x26,
	0x6e, 0xc1, 0x3c, 0x93, 0x74, 0xcf, 0xe6, 0x43, 0x9a, 0xd9, 0x7d, 0xe2, 0xff, 0xfa, 0xe4, 0x61,
	0xe1, 0xe4, 0x95, 0x3b, 0x9a, 0x61, 0x75, 0x29, 0xad, 0x37, 0xb3, 0xbc, 0xa3, 0x2e, 0xc2, 0xa3,
	0xdf, 0xe5, 0xa0, 0xe8, 0x91, 0x3e, 0x94, 0x47, 0xd8, 0xeb, 0x88, 0x9a, 0x2a, 0x0e, 0x0d, 0x4d,
	0x0f, 0xc4, 0x69, 0xdf, 0x7b, 0x7d, 0x0b, 0xaa, 0x94, 0x41, 0x5b, 0xad, 0x1a, 0x9a, 0xee, 0xcb,
	0xea, 0xdc, 0x51, 0xaf, 0xa9, 0x82, 0xfa, 0xb0, 0xe1, 0x69, 0x86, 0x6f, 0x4b, 0x2e, 0x96, 0xbc,
	0xf7, 0x7a, 0xc9, 0xce, 0xbe, 0x34, 0x96, 0x92, 0x54, 0x83, 0xf0, 0xc2, 0x09, 0xa4, 0x69, 0x06,
	0x10, 0xab, 0x40, 0x46, 0x3b, 0x90, 0xf4, 0xa5, 0x8b, 0x62, 0x42, 0xc2, 0x60, 0xb9, 0xa2, 0xb7,
	0x20, 0xcb, 0xf2, 0x44, 0x34, 0x63, 0xc8, 0x56, 0xe5, 0x19, 0x02, 0x64, 0x59, 0xc4, 0xc2, 0x11,
	0xa4, 0xca, 0x57, 0x96, 0xec, 0x67, 0xd6, 0xf7, 0x33, 0x2b, 0xeb, 0x26, 0x8e, 0xc4, 0x28, 0x33,
	0x6f, 0xb6, 0x04, 0x08, 0x88, 0x26, 0x3d, 0xfe, 0x77, 0x14, 0xd6, 0xca, 0xa3, 0xf9, 0x77, 0xf3,
	0x0f, 0x38, 0xd8, 0x26, 0x59, 0xe9, 0xf9, 0x21, 0x61, 0x67, 0xfb, 0x8f, 0x17, 0xeb, 0x25, 0x84,
	0x23, 0x0e, 0x51, 0xe6, 0x80, 0xec, 0xf5, 0x6c, 0xe8, 0x61, 0xb8, 0xc2, 0x7f, 0xe0, 0x60, 0xb3,
	0x3c, 0x0a, 0xa3, 0x43, 0x2d, 0xc8, 0x51, 0xf5, 0xd8, 0x6d, 0x63, 0x47, 0x3f, 0xbe, 0xb5, 0xb8,
	0x4d, 0x1e, 0xf5, 0x1f, 0xdf, 0x12, 0xb2, 0xba, 0xf3, 0xa8, 0xa8, 0x63, 0x74, 0x0c, 0x19, 0xac,
	0x21, 0x87, 0x1b, 0x9d, 0xe7, 0x6f, 0x5d, 0xd3, 0x43, 0x5b, 0xfb, 0xc7, 0xb7, 0x84, 0x74, 0x9f,
	0x3d, 0x28, 0xea, 0xb8, 0x9c, 0x82, 0x04, 0x63, 0x52, 0xf8, 0x31, 0x07, 0x85, 0xc5, 0xbd, 0xf6,
	0x9a, 0x99, 0x2c, 0x35, 0x33, 0x5f, 0xfa, 0xcd, 0x4c, 0x75, 0x39, 0x05, 0x87, 0xab, 0xca, 0x6b,
	0xf8, 0x7e, 0xce, 0xc1, 0x8e, 0x33, 0x03, 0xa8, 0x3e, 0xdc, 0x79, 0x80, 0x24, 0xc8, 0x90, 0x79,
	0x47, 0xbf, 0x8b, 0xdb, 0x6f, 0xf9, 0x07, 0x8b, 0x1b, 0xb1, 0x90, 0xd5, 0x03, 0x5c, 0xec, 0x11,
	0x36, 0x42, 0x7a, 0xe8, 0x94, 0xcd, 0x42, 0x1f, 0xc0, 0x45, 0xa1, 0x75, 0xb6, 0x45, 0x82, 0x68,
	0xe0, 0xf8, 0x16, 0xdb, 0x24, 0x71, 0x1b, 0x92, 0xe6, 0xf0, 0x9c, 0x7e, 0x58, 0x8f, 0x30, 0x4c,
	0xc2, 0x1c, 0xd2, 0x6f, 0xe9, 0xeb, 0x10, 0xa7, 0x5f, 0x7a, 0x68, 0x32, 0x8a, 0x3e, 0x94, 0xd3,
	0x90, 0x22, 0xe3, 0xd4, 0xba, 0xd2, 0xe5, 0xc2, 0x3f, 0x2f, 0x40, 0x9e, 0x36, 0xd3, 0xdd, 0xb7,
	0xfd, 0x1c, 0x2f, 0x64, 0xb5, 0x49, 0x60, 0x00, 0x1f, 0x2e, 0xee, 0x5a, 0x80, 0xc1, 0x03, 0x37,
	0x43, 0x89, 0x57, 0xb1, 0x76, 0xd9, 0x44, 0x75, 0xb8, 0xcf, 0x18, 0x4f, 0x34, 0x83, 0x9a, 0xad,
	0xb3, 0x2b, 0xd3, 0x92, 0x0d, 0xd9, 0x54, 0x4c, 0x71, 0x6c, 0xc8, 0xb2, 0x9d, 0x55, 0xbb, 0x43,
	0xc9, 0x26, 0x9a, 0x81, 0x35, 0x70, 0xec, 0x54, 0x3a, 0xc2, 0x75, 0xd0, 0x31, 0xbc, 0x79, 0x0d,
	0x9f, 0x2b, 0x79, 0x32, 0xd1, 0x5e, 0xb1, 0x3e, 0xdf, 0x5d, 0xc0, 0xe8, 0x05, 0xa9, 0x84, 0xca,
	0x70, 0xef, 0x1a, 0x4e, 0x86, 0x3c, 0x64, 0xab, 0xaa, 0xc2, 0x02, 0x36, 0x82, 0x3c, 0x44, 0x3d,
	0x48, 0xeb, 0xfa, 0x38, 0x70, 0x36, 0xe8, 0xe1, 0x12, 0xda, 0xd2, 0xed, 0xc1, 0x07, 0xba, 0x5d,
	0x34, 0xd1, 0x97, 0x90, 0x25, 0xaf, 0xcb, 0xe1, 0x4b, 0xbf, 0x91, 0x7e, 0x74, 0x73, 0xbe, 0xe4,
	0xa3, 0x9e, 0xbd, 0xa6, 0xb9, 0x70, 0x1f, 0xcc, 0xc2, 0x7f, 0x8c, 0xe0, 0x08, 0xd8, 0xc9, 0x22,
	0x9f, 0xe0, 0x91, 0xa5, 0x4d, 0x42, 0xd7, 0xb4, 0xd7, 0x4a, 0x28, 0xe9, 0xfa, 0x44, 0x19, 0x90,
	0x25, 0x34, 0x66, 0x27, 0x10, 0x36, 0x78, 0xb9, 0x4a, 0x74, 0x6a, 0x2a, 0x3f, 0xb4, 0xcf, 0x0b,
	0x25, 0x31, 0xa0, 0xab, 0xfc, 0x50, 0x46, 0xbb, 0xb0, 0x4a, 0x13, 0xa4, 0x1e, 0x95, 0xb3, 0x75,
	0x7e, 0x9e, 0x22, 0x1c, 0x2d, 0xa3, 0x87, 0xb0, 0xe9, 0x79, 0x2f, 0x34, 0x57, 0x49, 0x07, 0x09,
	0xdb, 0xe3, 0x3b, 0xb0, 0xab, 0x92, 0x70, 0x89, 0x8e, 0x8d, 0x8f, 0x60, 0x6b, 0x8e, 0x88, 0x8d,
	0x08, 0x9a, 0x3f, 0x5d, 0xf7, 0x53, 0xb1, 0x81, 0xf0, 0x21, 0xac, 0xcf, 0x91, 0x19, 0x2c, 0x21,
	0x90, 0x15, 0x56, 0xfd, 0x34, 0x82, 0x3c, 0x2c, 0xfc, 0x2c, 0x0a, 0x29, 0xe7, 0xcd, 0xdd, 0x60,
	0x72, 0x42, 0x70, 0x72, 0xbe, 0x0d, 0x39, 0xc5, 0x14, 0xed, 0x63, 0x3f, 0xba, 0x3e, 0x26, 0x3b,
	0x96, 0x92, 0x42, 0x46, 0x31, 0xab, 0x14, 0xd8, 0xd1, 0xc7, 0xe8, 0x09, 0x6c, 0x4f, 0x15, 0x55,
	0x99, 0xce, 0xa6, 0xe2, 0x78, 0x26, 0x19, 0x92, 0x6a, 0xc9, 0xf2, 0x90, 0x64, 0x6a, 0x6d, 0xff,
	0xb4, 0xc9, 0xf0, 0x47, 0x0e, 0xba, 0x82, 0xb1, 0xce, 0x5b, 0x8d, 0x7e, 0x33, 0x6f, 0xf5, 0x6d,
	0xc8, 0xf5, 0x25, 0x53, 0x16, 0xf1, 0xda, 0x95, 0x7e, 0xc4, 0x88, 0x31, 0x4f, 0x2b, 0x99, 0xf2,
	0xa9, 0x49, 0x23, 0x56, 0xf4, 0x09, 0x44, 0xfb, 0xd2, 0x88, 0xa5, 0xbe, 0x3e, 0xb8, 0xb9, 0xcc,
	0xb2, 0x34, 0x12, 0x30, 0x25, 0xba, 0x07, 0xe0, 0x4e, 0x40, 0xa6, 0x7d, 0x0f, 0x04, 0xbd, 0x0f,
	0xc8, 0xfe, 0xac, 0xe1, 0xbe, 0x29, 0x96, 0xb4, 0xe6, 0x19, 0xc6, 0x79, 0x4f, 0x24, 0xb5, 0x32,
	0xd0, 0x4c, 0xb1, 0xaf, 0x58, 0x53, 0x49, 0x27, 0x3b, 0x8f, 0xb2, 0x02, 0x60, 0x50, 0x99, 0x40,
	0xfc, 0xb6, 0xf0, 0x3f, 0xa7, 0x20, 0xed, 0x99, 0x34, 0x5f, 0xc5, 0xe2, 0x8e, 0xed, 0x59, 0xeb,
	0x3f, 0x2b, 0x52, 0xfe, 0x4a, 0xb3, 0x96, 0x96, 0x9d, 0x93, 0x23, 0x17, 0x9e, 0xa7, 0xc2, 0xef,
	0x25, 0x21, 0xe3, 0x45, 0xe3, 0xb0, 0x86, 0x4a, 0x76, 0x0e, 0x32, 0x25, 0xc8, 0x73, 0x63, 0x88,
	0xbe, 0x80, 0xa4, 0x6f, 0xdb, 0x7a, 0x2e, 0xf0, 0x0d, 0xf9, 0xda, 0xf6, 0xb8, 0x3b, 0x92, 0xed,
	0xaf, 0x3d, 0x82, 0xc3, 0xcd, 0xb3, 0x93, 0x87, 0x5a, 0x5b, 0xf6, 0x74, 0xed, 0xa8, 0x8d, 0xdd,
	0x68, 0xd4, 0xc6, 0x7f, 0x59, 0xa3, 0x76, 0x65, 0xf1, 0xa8, 0x4d, 0x7c, 0x43, 0xa3, 0x36, 0x39,
	0x37, 0x6a, 0x3f, 0x07, 0xde, 0xfd, 0xe6, 0xc9, 0x02, 0xd5, 0xd4, 0x72, 0x21, 0x58, 0xce, 0xfe,
	0x40, 0x4a, 0xc9, 0xd1, 0x53, 0xfa, 0x91, 0x94, 0x86, 0xb2, 0x24, 0x5c, 0x85, 0x65, 0xa2, 0xb0,
	0x0c, 0x63, 0x47, 0xbf, 0xfe, 0xe1, 0xf6, 0x29, 0xaa, 0xbf, 0x7d, 0xe9, 0x65, 0xda, 0xc7, 0x09,
	0xb9, 0xa9, 0xa2, 0x06, 0xdb, 0x67, 0xb3, 0xa4, 0xed, 0xcb, 0xdc, 0xbc, 0x7d, 0x9c, 0x90, 0x61,
	0xec, 0x68, 0xfb, 0x42, 0xbd, 0x46, 0x36, 0xdc, 0x6b, 0xe8, 0x8b, 0x1d, 0x40, 0x6e, 0xd9, 0x41,
	0xc5, 0x26, 0xa3, 0xfd, 0x25, 0x6c, 0x81, 0xef, 0xf8, 0x8d, 0x05, 0xbe, 0x23, 0xff, 0x75, 0xc5,
	0xcd, 0xbb, 0x9d, 0x32, 0x40, 0xd2, 0x7e, 0xed, 0xa4, 0xcc, 0x54, 0xec, 0x33, 0x64, 0xc5, 0x5f,
	0x70, 0x90, 0x0f, 0xcc, 0x07, 0xb4, 0x0e, 0xbc, 0x9d, 0xe6, 0x2a, 0x75, 0x3a, 0x62, 0xa7, 0xdd,
	0x6e, 0xf2, 0xb7, 0xd0, 0x26, 0xa0, 0x46, 0xeb, 0x48, 0xa8, 0x75, 0xbb, 0x0e, 0x54, 0xdc, 0xe3,
	0xb9, 0x50, 0xf8, 0x3e, 0x1f, 0x09, 0x85, 0x1f, 0xf0, 0xd1, 0x50, 0xf8, 0x43, 0x3e, 0x86, 0x36,
	0x60, 0xb5, 0x36, 0xc7, 0x3e, 0x1e, 0x06, 0xde, 0xe7, 0x57, 0xc2, 0xc0, 0x07, 0x7c, 0x22, 0x0c,
	0xfc, 0x90, 0x4f, 0x16, 0xff, 0x8a, 0x83, 0x68, 0x59, 0x1a, 0xa1, 0x3c, 0xa4, 0x9d, 0xac, 0x62,
	0xa9, 0xce, 0xdf, 0x42, 0x3b, 0xb0, 0x51, 0x2e, 0xd5, 0xc5, 0x7d, 0xb1, 0xd3, 0x6e, 0xb4, 0x7a,
	0xe2, 0x47, 0x62, 0xa7, 0x26, 0x54, 0x6a, 0xad, 0x1e, 0xcf, 0xa1, 0x55, 0xc8, 0x62, 0xd4, 0x43,
	0x07, 0x14, 0xb1, 0x41, 0x8f, 0x1c, 0x10, 0x39, 0x28, 0x41, 0x18, 0xec, 0x3b, 0xb0, 0x98, 0x0d,
	0x3b, 0xd8, 0x73, 0x60, 0x71, 0x1b, 0xf6, 0xd0, 0x65, 0xb7, 0x62, 0xc3, 0x3e, 0x72, 0xeb, 0x25,
	0x6c, 0xd8, 0x23, 0x57, 0x46, 0xd2, 0x86, 0x3d, 0x71, 0xeb, 0xa5, 0x70, 0x4f, 0xd8, 0x51, 0x5e,
	0xd2, 0x13, 0x28, 0xfe, 0x23, 0x0e, 0xd0, 0xbc, 0x01, 0x46, 0x3c, 0x64, 0x9c, 0x94, 0xa5, 0xd0,
	0x68, 0xd3, 0x64, 0x25, 0x2e, 0x91, 0x77, 0x67, 0x97, 0xf1, 0xfb, 0xb2, 0xcb, 0xf8, 0x1d, 0xd9,
	0x65, 0xfc, 0x5e, 0xec, 0xf2, 0x21, 0x1f, 0x77, 0xca, 0x1f, 0xf1, 0x2b, 0x4e, 0xf9, 0x11, 0x9f,
	0x70, 0xca, 0x8f, 0xf9, 0x64, 0xf1, 0x6f, 0x38, 0xc8, 0x07, 0x46, 0xa7, 0x37, 0x9b, 0xdb, 0x6c,
	0x9c, 0x34, 0x7a, 0xfc, 0x2d, 0x74, 0x07, 0xb6, 0x49, 0x51, 0xdc, 0x3f, 0x08, 0x51, 0xfe, 0x3a,
	0xf0, 0x14, 0x7b, 0xf0, 0x91, 0x47, 0xff, 0x0e, 0xcd, 0xc3, 0xc7, 0x73, 0x34, 0x51, 0x97, 0xc6,
	0xa3, 0xd0, 0x98, 0x4b, 0xf3, 0x68, 0x5e, 0x4e, 0xdc, 0xa5, 0x79, 0xfc, 0x91, 0xe7, 0xc5, 0x38,
	0x34, 0x4f, 0xe6, 0xe5, 0x90, 0x31, 0xc6, 0x5a, 0xbe, 0xe7, 0x0a, 0x4a, 0x16, 0x7e, 0x13, 0xee,
	0x5d, 0x9f, 0xb1, 0x09, 0x49, 0x7f, 0x55, 0xfc, 0xeb, 0xd2, 0x0f, 0x96, 0x5a, 0x97, 0x7a, 0x17,
	0xa0, 0x3f, 0xe2, 0xe0, 0xcd, 0xd7, 0x66, 0x6b, 0x42, 0x1a, 0xd0, 0xf0, 0x37, 0xe0, 0xe1, 0x57,
	0x58, 0x93, 0x7a, 0x9b, 0xa1, 0xc1, 0x66, 0x78, 0xe6, 0x66, 0xd9, 0x8c, 0xe3, 0x75, 0xb6, 0xcf,
	0x9b, 0xf7, 0xfb, 0x31, 0x07, 0x99, 0x67, 0xb2, 0x3a, 0xd4, 0xec, 0x3d, 0x34, 0x3f, 0x80, 0xec,
	0x98, 0xa4, 0x0d, 0xfd, 0x37, 0x57, 0xec, 0x2c, 0x4c, 0x2c, 0x0a, 0x99, 0xb1, 0x77, 0x1f, 0xf1,
	0x0f, 0x20, 0x6b, 0x11, 0x71, 0xfe, 0x33, 0xe8, 0x3b, 0x0b, 0x5b, 0x27, 0x64, 0x2c, 0xcf, 0x53,
	0xf1, 0x7f, 0x46, 0x21, 0xeb, 0x3b, 0xe6, 0x71, 0x83, 0x0d, 0x0f, 0x0f, 0xc8, 0xe9, 0x05, 0x4c,
	0xc2, 0xa4, 0xad, 0x87, 0x9d, 0x1a, 0x11, 0xec, 0x4a, 0xe8, 0x5d, 0x88, 0xab, 0xda, 0x50, 0xb6,
	0xf7, 0x68, 0xad, 0xce, 0x9d, 0xc3, 0x10, 0x28, 0x1e, 0x55, 0x20, 0x6f, 0xda, 0x67, 0x2e, 0x48,
	0x14, 0x6a, 0x5f, 0x6f, 0xe1, 0x3f, 0x02, 0xe4, 0x3b, 0x97, 0x21, 0xe4, 0x4c, 0xef, 0xa3, 0x89,
	0x1e, 0x43, 0xda, 0x32, 0x66, 0xea, 0x39, 0x63, 0x40, 0xd7, 0xac, 0x9b, 0xe1, 0x9b, 0xe6, 0x05,
	0xb0, 0xec, 0x22, 0x21, 0x24, 0x7e, 0x86, 0x1c, 0xc6, 0xb5, 0x17, 0xa5, 0x9b, 0xe1, 0x9b, 0xc4,
	0x05, 0xd0, 0xed, 0xa2, 0x89, 0xdf, 0xc1, 0x4b, 0xf2, 0x4e, 0xdd, 0x2d, 0xb8, 0xf3, 0xef, 0xc0,
	0xfb, 0xd6, 0x85, 0xcc, 0x4b, 0xef, 0x18, 0xe8, 0x43, 0x41, 0xa3, 0xe7, 0x27, 0xc4, 0xb9, 0x03,
	0x0f, 0xf6, 0xd6, 0xc8, 0xb7, 0x7d, 0xcc, 0x16, 0x1c, 0xb7, 0x10, 0xb6, 0xb5, 0x70, 0x84, 0x59,
	0xbc, 0x84, 0x6c, 0x77, 0xa4, 0x93, 0x73, 0x4a, 0x72, 0x45, 0xd2, 0x4d, 0xb4, 0x06, 0xf1, 0x11,
	0xb6, 0x08, 0xe4, 0x05, 0x27, 0x85, 0xd8, 0x68, 0x7f, 0x6f, 0x0f, 0xad, 0x42, 0x6c, 0x24, 0xee,
	0x8f, 0xd9, 0x17, 0xbb, 0xe8, 0x68, 0x7f, 0x6c, 0xd7, 0x1b, 0xb3, 0x95, 0x2c, 0xae, 0xc7, 0x80,
	0x87, 0x7b, 0x63, 0xf6, 0x7d, 0x3a, 0x36, 0x3a, 0xdc, 0x23, 0xfb, 0xa3, 0x08, 0x47, 0x7b, 0x1b,
	0x63, 0x1c, 0xb3, 0x1c, 0x17, 0xff, 0x94, 0x83, 0x44, 0x5d, 0x52, 0x89, 0xd0, 0x2d, 0x48, 0x98,
	0xb2, 0x25, 0x0e, 0x15, 0x83, 0x89, 0x5d, 0x31, 0x65, 0xab, 0xaa, 0x18, 0x18, 0x31, 0x66, 0x08,
	0x2a, 0x7b, 0x65, 0xec, 0x20, 0x30, 0x85, 0xa1, 0x4f, 0x59, 0x03, 0x30, 0x85, 0xa0, 0x4f, 0xd1,
	0xb7, 0x20, 0x87, 0x11, 0x9e, 0xfb, 0x3b, 0x68, 0x5b, 0xb2, 0xa6, 0x6c, 0x79, 0x6e, 0xef, 0x60,
	0x8c, 0x31, 0x7d, 0xdc, 0x61, 0xcc, 0xe8, 0xc7, 0x7e, 0x7a, 0x7a, 0x6b, 0x40, 0x76, 0xec, 0xa5,
	0x2f, 0xfe, 0x94, 0x83, 0x44, 0xc7, 0x9c, 0x91, 0xd6, 0xef, 0x40, 0x92, 0x5c, 0x03, 0x72, 0xa5,
	0xcb, 0xac, 0xf9, 0x98, 0x37, 0x39, 0xc3, 0xc0, 0xc4, 0xbc, 0x64, 0x7b, 0xa7, 0xa8, 0x98, 0x67,
	0x8a, 0x6a, 0xd3, 0xbc, 0xd4, 0x66, 0xf6, 0xa5, 0x09, 0xb8, 0xe2, 0x33, 0x6d, 0x66, 0xd9, 0x34,
	0x0a, 0xdb, 0x96, 0x4b, 0x69, 0x1a, 0x2e, 0x8d, 0x82, 0x69, 0xe2, 0x0e, 0x4d, 0xc3, 0x43, 0xa3,
	0x2b, 0x2a, 0x6b, 0x2e, 0xa6, 0xe9, 0xb8, 0x34, 0x3a, 0xa6, 0x49, 0x38, 0x34, 0x1d, 0x6d, 0x66,
	0x15, 0x7f, 0xc6, 0x41, 0xba, 0x77, 0x26, 0x1b, 0x53, 0x69, 0x42, 0xba, 0xf1, 0x2e, 0xe4, 0x03,
	0xb7, 0x99, 0xb0, 0xde, 0xe4, 0xfc, 0x57, 0x98, 0xa0, 0x03, 0xd8, 0xc0, 0x15, 0x5f, 0xd1, 0xcb,
	0x13, 0x44, 0xeb, 0xcc, 0x90, 0xcd, 0x33, 0x6d, 0x32, 0x64, 0x5d, 0x5c, 0x1b, 0xcb, 0xd6, 0x73,
	0x8a, 0xeb, 0xd9, 0x28, 0xf4, 0x00, 0x30, 0x58, 0x94, 0x0d, 0x43, 0x33, 0x3c, 0x14, 0xb4, 0xeb,
	0xab, 0x63, 0xd9, 0xaa, 0x61, 0x8c, 0x5b, 0xff, 0x10, 0x36, 0xc7, 0x24, 0x79, 0x3b, 0xb3, 0x86,
	0xda, 0x2b, 0xd5, 0x43, 0x42, 0x75, 0xb2, 0x3e, 0xc6, 0x71, 0x38, 0x45, 0x3a, 0x54, 0xc5, 0x3f,
	0x8f, 0x42, 0xa2, 0x29, 0x0f, 0x49, 0x77, 0x78, 0x88, 0x6a, 0xa3, 0x11, 0xeb, 0x02, 0x2e, 0x22,
	0x04, 0x31, 0x69, 0x66, 0x69, 0xac, 0x99, 0xa4, 0x8c, 0xde, 0x82, 0x2c, 0xfe, 0x15, 0xfb, 0x13,
	0x45, 0x3d, 0xa7, 0xab, 0x57, 0x92, 0x91, 0xc0, 0xc0, 0x32, 0x83, 0x61, 0xc2, 0xc1, 0x99, 0x64,
	0xd8, 0xa3, 0x1a, 0x97, 0x31, 0x7b, 0x1c, 0xf0, 0xd2, 0xf7, 0x80, 0x8b, 0xe8, 0x4d, 0xc8, 0x18,
	0xf2, 0xd0, 0xe5, 0x44, 0x5f, 0x44, 0xda, 0x90, 0x87, 0x0e, 0xa3, 0x4d, 0x58, 0xd1, 0x0c, 0x49,
	0x1d, 0xcb, 0xec, 0x5d, 0xb0, 0x27, 0xac, 0x7a, 0x5a, 0x72, 0xa9, 0x93, 0x54, 0xf5, 0x14, 0xec,
	0x65, 0xc0, 0x02, 0x7b, 0x9a, 0x39, 0x61, 0x4f, 0x98, 0x01, 0x2d, 0xb9, 0x0c, 0x80, 0x32, 0xa0,
	0x60, 0x87, 0xc1, 0x3a, 0xc4, 0x69, 0x3e, 0x29, 0x4d, 0xe7, 0x22, 0x79, 0x20, 0x83, 0x1e, 0x17,
	0x5c, 0xea, 0x0c, 0x1b, 0xf4, 0x18, 0xea, 0xd5, 0x43, 0x1f, 0x7b, 0x3a, 0xba, 0x0c, 0x21, 0x65,
	0xf2, 0x35, 0x62, 0x32, 0xf3, 0x34, 0x3c, 0x47, 0x15, 0x88, 0x81, 0xde, 0x66, 0xeb, 0x33, 0x43,
	0x9f, 0xc8, 0x64, 0x81, 0x90, 0x14, 0xd8, 0x13, 0x6e, 0x36, 0x2d, 0xb9, 0xe4, 0x3c, 0x6d, 0x36,
	0x05, 0xdb, 0x0c, 0x8a, 0xff, 0x26, 0x02, 0xa8, 0x6e, 0x68, 0xaa, 0xd5, 0x91, 0x54, 0x79, 0x82,
	0xcd, 0x6d, 0x43, 0x1d, 0x69, 0xe8, 0x29, 0x20, 0xfd, 0xec, 0xca, 0x24, 0x26, 0xd2, 0x59, 0x0b,
	0xb0, 0xa4, 0x5e, 0xe0, 0xe0, 0x11, 0xab, 0x86, 0x49, 0xc9, 0x61, 0x28, 0x5e, 0x0f, 0x40, 0xd0,
	0x47, 0x00, 0x53, 0x79, 0xa8, 0x48, 0x94, 0x09, 0xcd, 0x1a, 0xf8, 0xcd, 0xfc, 0x09, 0x46, 0x13,
	0xea, 0xd4, 0xd4, 0x2e, 0xa2, 0x37, 0x20, 0xcd, 0xac, 0x3c, 0x39, 0x5a, 0x44, 0xef, 0xd6, 0x01,
	0x0a, 0x6a, 0x49, 0x53, 0x52, 0x41, 0x97, 0x0c, 0x4b, 0x54, 0x67, 0xd3, 0xbe, 0x4c, 0x07, 0x51,
	0x4a, 0x00, 0x0c, 0x6a, 0x11, 0x08, 0x56, 0xa1, 0x29, 0x1b, 0x0a, 0x36, 0xf3, 0xb4, 0x0a, 0xbd,
	0x55, 0x27, 0x43, 0x81, 0xac, 0xd2, 0x87, 0x90, 0x3c, 0x7b, 0xc5, 0xce, 0x22, 0x87, 0x9d, 0xb7,
	0x3d, 0x7e, 0xc5, 0x8e, 0x10, 0x9f, 0xd1, 0x42, 0xf1, 0x2f, 0xa2, 0xb0, 0xc9, 0xfc, 0x41, 0xcf,
	0x90, 0x54, 0x73, 0x20, 0x2b, 0x2f, 0x65, 0x83, 0xa8, 0xcd, 0x77, 0x28, 0x8e, 0x0b, 0x1e, 0x8a,
	0xfb, 0x0c, 0xd2, 0x8a, 0xea, 0x1e, 0x86, 0x0b, 0x0b, 0x6b, 0xc2, 0xf9, 0xd2, 0xbb, 0xa9, 0x04,
	0x20, 0xd4, 0xf4, 0xc0, 0x5c, 0x13, 0x32, 0xbe, 0x93, 0x75, 0xd1, 0x65, 0x99, 0xa5, 0x35, 0xcf,
	0xf1, 0xbb, 0x05, 0xc7, 0xf5, 0x62, 0xcb, 0x1c, 0xd7, 0x8b, 0x87, 0x1e, 0xd7, 0x2b, 0xfc, 0x2b,
	0x0e, 0xe2, 0x94, 0x68, 0x1b, 0x12, 0x8a, 0x6a, 0x5a, 0x12, 0x3b, 0x9c, 0xc1, 0x09, 0xf6, 0x23,
	0x9e, 0xf2, 0xd2, 0x4b, 0xea, 0x04, 0x39, 0x01, 0x17, 0x51, 0x01, 0x92, 0xc4, 0x23, 0xbf, 0x94,
	0x26, 0xec, 0x64, 0x9e, 0xf3, 0x4c, 0x4e, 0xa2, 0x48, 0x97, 0xac, 0x71, 0xb8, 0x88, 0x6d, 0x31,
	0x5e, 0xc8, 0x5a, 0xca, 0xd4, 0x6e, 0x46, 0x62, 0x2a, 0x5d, 0xf6, 0x94, 0x29, 0x3d, 0x32, 0xce,
	0x6c, 0x37, 0xae, 0x4c, 0x0d, 0x37, 0x5e, 0xe9, 0x92, 0xca, 0x09, 0x56, 0x59, 0x51, 0x71, 0xe5,
	0xe2, 0x08, 0xa0, 0xad, 0xcb, 0x06, 0x7e, 0xcd, 0x33, 0x13, 0xbd, 0x0f, 0x71, 0xef, 0x09, 0xf5,
	0xf9, 0xc0, 0x84, 0x8e, 0x0b, 0x5a, 0x09, 0xed, 0xc2, 0x2a, 0x66, 0x29, 0x4e, 0x24, 0xd3, 0x22,
	0xa7, 0x2d, 0xc6, 0x6c, 0xfb, 0x61, 0x4c, 0xc8, 0x63, 0x44, 0x53, 0x32, 0xad, 0x0a, 0x05, 0x17,
	0xcb, 0x90, 0xf3, 0x9e, 0xaa, 0x9e, 0x99, 0x68, 0xcf, 0x2f, 0xeb, 0xba, 0x13, 0xd8, 0xb4, 0x62,
	0xf1, 0xfb, 0x90, 0x76, 0x4e, 0xc9, 0xcf, 0x4c, 0xf4, 0x81, 0x9f, 0xc1, 0xc2, 0xe3, 0xf4, 0x8c,
	0xfa, 0x03, 0x00, 0xf7, 0x4c, 0x38, 0x9e, 0x48, 0xde, 0x13, 0xe4, 0x74, 0xe0, 0x7a, 0x0e, 0x8a,
	0x17, 0xdf, 0xa3, 0x67, 0xff, 0xba, 0xba, 0x2c, 0x0f, 0xfd, 0x27, 0x66, 0x39, 0xff, 0x89, 0xd9,
	0xe2, 0xfb, 0x90, 0xf3, 0xdf, 0x19, 0x86, 0x5f, 0x65, 0xe0, 0x56, 0x05, 0xe7, 0xb9, 0xf8, 0x2f,
	0x62, 0x90, 0xa1, 0x27, 0x17, 0x67, 0xf8, 0xed, 0x9a, 0x74, 0x7b, 0x9a, 0xa8, 0x0d, 0x2c, 0xfa,
	0x19, 0x8c, 0xbd, 0xf8, 0x36, 0x79, 0x46, 0xef, 0x40, 0x5e, 0x71, 0x6e, 0x29, 0x72, 0x37, 0xf3,
	0xc7, 0x84, 0xac, 0x62, 0x5f, 0x50, 0x44, 0x0e, 0x2e, 0xec, 0xc2, 0xaa, 0xa2, 0xba, 0x57, 0x2d,
	0xd1, 0x9a, 0x74, 0x14, 0xe5, 0x15, 0xd5, 0xb9, 0x6c, 0xc9, 0x53, 0xd7, 0xb9, 0x31, 0x89, 0xd6,
	0x8d, 0xd9, 0x75, 0x9d, 0xcb, 0x92, 0x48, 0x5d, 0xb2, 0xb9, 0x4e, 0x1c, 0x2a, 0xe6, 0x40, 0x32,
	0x86, 0x26, 0x1b, 0x69, 0xa0, 0xa8, 0x55, 0x06, 0x61, 0xad, 0x27, 0xae, 0xd8, 0x39, 0x4b, 0xac,
	0xa8, 0xc4, 0x01, 0xdb, 0x92, 0xec, 0xbb, 0x96, 0xc8, 0x4d, 0x7b, 0xa6, 0x7d, 0xc6, 0x15, 0xb7,
	0x9f, 0xc0, 0x3b, 0x04, 0x8c, 0xee, 0x02, 0x68, 0x33, 0xcb, 0xd6, 0x43, 0x92, 0x1a, 0x12, 0x6d,
	0x66, 0x31, 0x45, 0xbc, 0x07, 0x3c, 0x46, 0xfb, 0x34, 0x41, 0x8f, 0x28, 0xe7, 0xb4, 0x99, 0xe5,
	0x55, 0xc5, 0xfb, 0x80, 0x70, 0xcd, 0x80, 0x2e, 0x80, 0xd4, 0xc5, 0x3c, 0xfc, 0xca, 0x60, 0xb5,
	0x03, 0xda, 0x48, 0x3b, 0xb5, 0xfd, 0xea, 0x78, 0x93, 0x98, 0x20, 0x57, 0x1f, 0x19, 0x52, 0x0f,
	0xdb, 0x15, 0x47, 0x21, 0xac, 0x1f, 0x4c, 0x23, 0x59, 0xa7, 0x1f, 0x4c, 0x25, 0x45, 0xc8, 0x2a,
	0xaa, 0x38, 0x1a, 0x98, 0x76, 0x8d, 0x1c, 0x65, 0xa1, 0xa8, 0xf5, 0x81, 0x49, 0xeb, 0x14, 0x7f,
	0xc2, 0xd1, 0x43, 0xa0, 0x64, 0x75, 0xc7, 0x46, 0x49, 0x30, 0x3f, 0x9d, 0x75, 0xf3, 0xd3, 0x7e,
	0xcd, 0x45, 0x82, 0x9a, 0xdb, 0x81, 0x24, 0x46, 0x7b, 0x46, 0x44, 0x42, 0x9b, 0xd1, 0xee, 0x30,
	0xa5, 0x0e, 0x0d, 0x4d, 0xd7, 0xe5, 0xa1, 0x77, 0x20, 0x60, 0xa5, 0x56, 0x29, 0x18, 0xd7, 0x2c,
	0xfe, 0x2f, 0x0e, 0xe2, 0xa5, 0x89, 0x64, 0x4c, 0xb1, 0x0a, 0xc8, 0xa4, 0x1f, 0x18, 0xb2, 0x64,
	0xc9, 0xf6, 0x71, 0xfc, 0x34, 0x86, 0x55, 0x28, 0x28, 0xb8, 0xba, 0x8b, 0xcc, 0xaf, 0xee, 0x1e,
	0x43, 0xd2, 0x94, 0x5f, 0xca, 0xce, 0x9d, 0x2c, 0xb9, 0xc0, 0xd1, 0x60, 0x22, 0xea, 0x41, 0x97,
	0x55, 0x11, 0x9c, 0xca, 0xd8, 0xf9, 0x9b, 0x64, 0xf6, 0xdb, 0xe1, 0x2c, 0x7d, 0x2a, 0x1e, 0x43,
	0xd2, 0xae, 0xed, 0xbf, 0xde, 0x2d, 0x05, 0xf1, 0x93, 0x46, 0xab, 0x2d, 0xd0, 0xfd, 0x6d, 0xcf,
	0x4b, 0x42, 0xab, 0xd1, 0x3a, 0xe2, 0x23, 0x04, 0x5e, 0xfa, 0xac, 0x2d, 0xd0, 0xbd, 0x7d, 0x15,
	0xa1, 0xd1, 0x6b, 0x54, 0x4a, 0x4d, 0x3e, 0x86, 0x39, 0x91, 0xe5, 0x3a, 0xf6, 0x6d, 0x01, 0x77,
	0xcc, 0xcd, 0xb9, 0xe3, 0xdb, 0x90, 0x1a, 0x9c, 0x29, 0xba, 0xe8, 0x39, 0x08, 0x9c, 0xc4, 0x00,
	0x8c, 0x2c, 0x1e, 0x40, 0x16, 0x73, 0xaa, 0xca, 0xfd, 0xd9, 0x98, 0xb0, 0x7b, 0x13, 0x32, 0x43,
	0xfc, 0x20, 0x9a, 0x96, 0x61, 0xef, 0x22, 0x20, 0x8a, 0xe9, 0xcf, 0xc6, 0x5d, 0x02, 0x2a, 0xb6,
	0x61, 0xad, 0xae, 0x19, 0xaf, 0x24, 0x63, 0xa8, 0xa8, 0xe3, 0x67, 0x8a, 0xd4, 0x57, 0x26, 0xb8,
	0x4b, 0x4f, 0xfc, 0xa6, 0xae, 0x38, 0xbf, 0xd2, 0xa4, 0x67, 0x85, 0xc9, 0x66, 0x3f, 0x9f, 0xd5,
	0x2b, 0x41, 0xfe, 0x58, 0x96, 0x26, 0xd6, 0x59, 0x43, 0x1d, 0x2a, 0x03, 0xc9, 0xd2, 0xb0, 0xe7,
	0xf3, 0x31, 0xdb, 0xf6, 0xbb, 0x7e, 0x52, 0xd9, 0xc7, 0xa2, 0x0a, 0x1b, 0x25, 0x7a, 0x95, 0x88,
	0x66, 0x29, 0xf4, 0xae, 0x32, 0x6a, 0x80, 0xbf, 0xe3, 0x67, 0xb4, 0xe0, 0x1e, 0x12, 0xc6, 0xe5,
	0x23, 0x48, 0xd5, 0xe5, 0x01, 0xa3, 0x7c, 0x8f, 0x5d, 0x46, 0xc8, 0x5d, 0x73, 0xd9, 0x07, 0xa9,
	0x51, 0x7c, 0x1b, 0x52, 0xdd, 0x21, 0x59, 0x75, 0x37, 0x86, 0x78, 0x65, 0x42, 0x22, 0x33, 0x67,
	0x0e, 0xac, 0xe8, 0x04, 0x51, 0xfc, 0xc7, 0xab, 0x90, 0xae, 0x4a, 0x96, 0x24, 0xe0, 0xb8, 0xc3,
	0xb4, 0xd0, 0xf7, 0x21, 0x69, 0xd0, 0xa2, 0xfd, 0xf9, 0xdd, 0x7f, 0xa2, 0xdd, 0x53, 0xf7, 0x01,
	0xfb, 0x15, 0x1c, 0x8a, 0xc2, 0xbf, 0xe3, 0x21, 0x61, 0x73, 0x3a, 0x86, 0x34, 0x76, 0xef, 0x22,
	0x1b, 0x75, 0x61, 0x1b, 0x3f, 0x42, 0x98, 0x11, 0x5f, 0x79, 0x7c, 0x4b, 0x00, 0xcd, 0xf5, 0xad,
	0x9f, 0x41, 0xc6, 0xbd, 0x03, 0x66, 0x66, 0x86, 0x6e, 0x9f, 0xbb, 0x86, 0x55, 0x5a, 0xf2, 0xb8,
	0xbe, 0x63, 0xbf, 0xf7, 0x8a, 0x2e, 0xd9, 0x2a, 0xcf, 0x7d, 0x28, 0x75, 0x00, 0xba, 0xeb, 0x06,
	0x7b, 0x33, 0x76, 0xcc, 0xe2, 0xc6, 0x8c, 0x48, 0xce, 0x9c, 0x7a, 0xc8, 0x5f, 0x85, 0x0d, 0x7b,
	0x80, 0x60, 0x4b, 0xe2, 0xb2, 0x8c, 0x2f, 0xc7, 0x72, 0xcd, 0xe5, 0xe2, 0xba, 0xdf, 0xf6, 0xfc,
	0xed, 0x9e, 0x2b, 0xcb, 0xb1, 0x0d, 0x5c, 0x03, 0xfa, 0x62, 0xc1, 0x35, 0xa0, 0x89, 0xe5, 0xb8,
	0x86, 0xdc, 0x17, 0x8a, 0x9a, 0x90, 0x25, 0xbd, 0x1f, 0x30, 0xcb, 0xcd, 0x6e, 0xbb, 0xb8, 0x31,
	0xcf, 0x8c, 0xee, 0x0d, 0x0e, 0xbe, 0x00, 0x34, 0x95, 0xa7, 0x9a, 0x71, 0xc5, 0x56, 0xbb, 0x12,
	0x36, 0x8c, 0xec, 0xdb, 0xd7, 0x7b, 0xaf, 0x65, 0xc9, 0xb2, 0x64, 0xc7, 0xb7, 0x04, 0x9e, 0x72,
	0x21, 0x0e, 0x86, 0xda, 0x71, 0x13, 0xee, 0xd3, 0x0b, 0x1a, 0x0c, 0x6d, 0x6c, 0x48, 0xd3, 0x29,
	0x5e, 0x7d, 0xcb, 0x97, 0x03, 0x99, 0x18, 0x68, 0x26, 0x07, 0x96, 0x96, 0x73, 0x97, 0x5c, 0xe2,
	0xe0, 0xb2, 0xac, 0xd9, 0x1c, 0xa9, 0xd0, 0x2f, 0x60, 0x95, 0x28, 0x87, 0x6e, 0x7b, 0x63, 0x0a,
	0x4a, 0x87, 0x5c, 0x7d, 0xbb, 0x48, 0x41, 0x24, 0x89, 0x7e, 0x7c, 0x4b, 0xc8, 0xeb, 0x01, 0xff,
	0xf8, 0xeb, 0xec, 0x78, 0x3c, 0xfd, 0xfc, 0xa6, 0x68, 0x22, 0xb5, 0xb4, 0x8a, 0x3a, 0xd2, 0xd8,
	0x97, 0xb3, 0xd7, 0xbf, 0x01, 0x6c, 0xad, 0x8f, 0x6f, 0x09, 0x64, 0x7f, 0x5e, 0x87, 0xf1, 0x71,
	0xad, 0xf7, 0x97, 0xb0, 0x3e, 0x72, 0x4c, 0xb3, 0xf8, 0xd2, 0xb6, 0xcd, 0xc4, 0xc5, 0x2f, 0x33,
	0xc0, 0x47, 0x21, 0xf6, 0x5d, 0x00, 0xfe, 0x8c, 0x18, 0x5e, 0x51, 0xb1, 0xcd, 0x34, 0x09, 0x0c,
	0x96, 0xe0, 0x9b, 0x3f, 0x0b, 0x98, 0xf9, 0x16, 0xe4, 0xd8, 0x0d, 0x50, 0xb6, 0xc5, 0xc9, 0x2f,
	0x39, 0x67, 0x18, 0x39, 0xb3, 0x39, 0x5f, 0xc2, 0xc6, 0x08, 0xaf, 0x9a, 0x45, 0x1d, 0x2f, 0x9b,
	0xe9, 0x14, 0x27, 0xea, 0xe5, 0x97, 0x9c, 0x34, 0xa3, 0xf9, 0xb5, 0x77, 0x1d, 0x60, 0x24, 0x0f,
	0xec, 0x76, 0xa2, 0x25, 0xad, 0xd0, 0xc8, 0xf1, 0x2b, 0x16, 0xd8, 0xd9, 0x49, 0xd1, 0x72, 0x97,
	0x80, 0xb4, 0x99, 0x6b, 0x84, 0xeb, 0x93, 0xd7, 0x72, 0x5d, 0x90, 0xf7, 0x3c, 0xbe, 0x25, 0x6c,
	0x6a, 0xe1, 0x4b, 0xe0, 0x0e, 0xe4, 0x9d, 0x3b, 0xa5, 0x58, 0x17, 0xd6, 0x97, 0xeb, 0x42, 0x6e,
	0xe2, 0x5f, 0x1b, 0x55, 0x21, 0x45, 0x37, 0x89, 0xe2, 0x86, 0x6f, 0x2c, 0x37, 0x7c, 0x93, 0xaa,
	0x1d, 0xbe, 0x1c, 0x41, 0xda, 0x1c, 0xaa, 0xa2, 0xed, 0x32, 0x37, 0x97, 0x54, 0xab, 0x69, 0xfb,
	0xdd, 0xc2, 0x13, 0x88, 0x91, 0xed, 0x19, 0x5b, 0x90, 0x60, 0x7b, 0x57, 0x59, 0xd8, 0xb7, 0x42,
	0xf7, 0x9e, 0x7a, 0x1d, 0x73, 0xc4, 0xeb, 0x98, 0x0b, 0x6f, 0xb0, 0xab, 0x9b, 0x16, 0x51, 0x16,
	0x52, 0xce, 0xad, 0x53, 0x85, 0x2f, 0xe8, 0x8a, 0x8b, 0x5e, 0xa6, 0xb0, 0xb4, 0x28, 0x5f, 0x84,
	0x1c, 0xf5, 0x45, 0xc8, 0x85, 0x5f, 0x5b, 0x7c, 0x79, 0x90, 0x7b, 0x31, 0x10, 0xf7, 0xfa, 0x8b,
	0x81, 0x22, 0xe1, 0x17, 0x03, 0x95, 0x53, 0x90, 0x60, 0xc1, 0x43, 0xf1, 0x9f, 0x64, 0x20, 0x43,
	0x95, 0x6a, 0xea, 0x9a, 0x6a, 0xca, 0xe8, 0xe3, 0xb0, 0x00, 0x62, 0x2b, 0x90, 0xb4, 0xb0, 0x83,
	0x84, 0x40, 0xc8, 0xf0, 0x2b, 0xa1, 0x21, 0xc3, 0x76, 0xf8, 0x42, 0x97, 0x50, 0xfb, 0xa2, 0x84,
	0x8f, 0xc3, 0xa2, 0x84, 0x45, 0xb7, 0xa4, 0x05, 0xe2, 0x82, 0xc7, 0x21, 0x71, 0x41, 0x48, 0x3a,
	0x00, 0x63, 0xfd, 0x81, 0x40, 0xf3, 0xfa, 0x40, 0x60, 0x31, 0x8f, 0x50, 0xcf, 0x5f, 0x5a, 0xe4,
	0xf9, 0xaf, 0xe9, 0x46, 0xc0, 0xd7, 0xb7, 0xaf, 0xf5, 0xf5, 0xfe, 0x75, 0x87, 0xdf, 0x97, 0x2f,
	0xf0, 0xf0, 0x9f, 0x86, 0x7b, 0xf8, 0x9d, 0x90, 0xcb, 0x89, 0x68, 0x85, 0x39, 0xaf, 0x5e, 0xbe,
	0xc6, 0xab, 0xa3, 0xf9, 0x85, 0x50, 0xa8, 0xff, 0xfe, 0x7b, 0x37, 0xf6, 0xdf, 0xe1, 0x1c, 0x5f,
	0xe3, 0xa9, 0x3f, 0x5b, 0xec, 0xa9, 0xef, 0xcc, 0x75, 0xd4, 0xe3, 0x88, 0xc3, 0x7c, 0xf3, 0xe9,
	0x6b, 0x7d, 0x73, 0x61, 0xee, 0x73, 0x9d, 0xe3, 0x77, 0x17, 0x3b, 0xe4, 0xd3, 0x6b, 0x1d, 0xb2,
	0x3f, 0xe0, 0x0f, 0x59, 0x54, 0x2d, 0xf2, 0xc5, 0x8d, 0x85, 0xbe, 0xf8, 0x4e, 0xc8, 0x4a, 0xc9,
	0xf1, 0xb7, 0x61, 0x2e, 0xf8, 0xe9, 0x02, 0x17, 0xec, 0x5f, 0xbf, 0x85, 0x2e, 0xae, 0xe6, 0xfd,
	0x6f, 0xef, 0x7a, 0xff, 0xfb, 0x86, 0xbf, 0xbf, 0x73, 0x3e, 0x76, 0x81, 0xe7, 0x7d, 0x1c, 0xe2,
	0x79, 0x37, 0x83, 0xeb, 0x31, 0xa7, 0x49, 0x1e, 0x57, 0x2b, 0xbe, 0xd6, 0xd5, 0xbe, 0x75, 0x83,
	0xcc, 0xec, 0x35, 0x5e, 0xb5, 0xbe, 0xc8, 0xab, 0xde, 0x5e, 0x98, 0x29, 0x24, 0x6d, 0x0c, 0xfa,
	0xd2, 0xc3, 0x79, 0x5f, 0xba, 0x31, 0x37, 0xdc, 0x58, 0x5b, 0x5c, 0xdf, 0xf9, 0x24, 0xcc, 0x77,
	0xfa, 0x15, 0xe3, 0xac, 0x4b, 0x7d, 0xce, 0xb2, 0x0c, 0x78, 0xed, 0x49, 0x8d, 0x7f, 0xf1, 0x8f,
	0x01, 0xa0, 0x2b, 0x5b, 0xf6, 0x62, 0xf2, 0x7b, 0x73, 0xcb, 0x52, 0xff, 0x5b, 0x73, 0xab, 0x86,
	0xac, 0x4a, 0xff, 0x3a, 0xe5, 0xae, 0x4a, 0x3f, 0xf6, 0x6c, 0xad, 0x0c, 0x7e, 0xb7, 0x9d, 0x67,
	0x62, 0x7b, 0x74, 0xba, 0x01, 0xf3, 0x63, 0x76, 0xfb, 0x5b, 0xe4, 0x66, 0xb4, 0x2c, 0xaa, 0xa0,
	0xb7, 0xc4, 0x55, 0xdc, 0xaf, 0xf2, 0x61, 0x37, 0xc8, 0x87, 0x90, 0xbb, 0x4b, 0x03, 0xe7, 0x53,
	0xfd, 0x0c, 0x76, 0x16, 0x7e, 0x8a, 0x66, 0x9e, 0xe6, 0xf1, 0xeb, 0xd8, 0x2e, 0x0e, 0xd2, 0xb6,
	0x16, 0x7c, 0x9e, 0x2e, 0xfc, 0x34, 0xfe, 0x55, 0xa3, 0x98, 0x39, 0x3f, 0x1c, 0xfd, 0x5a, 0x7e,
	0x38, 0xf6, 0xd5, 0xfd, 0x70, 0xfc, 0xe6, 0x7e, 0xf8, 0xef, 0xa2, 0xe7, 0x0c, 0x33, 0xad, 0xc9,
	0x6f, 0xca, 0xb4, 0xa6, 0xbe, 0xba, 0x69, 0x5d, 0xe4, 0x49, 0xe0, 0xeb, 0x79, 0x92, 0x10, 0x0b,
	0x96, 0xfe, 0x0a, 0x16, 0xac, 0x9c, 0x60, 0xbb, 0x82, 0x0a, 0x2b, 0x34, 0x9a, 0xf6, 0x06, 0xcd,
	0x7f, 0xc6, 0xfd, 0x72, 0x63, 0xdb, 0x6b, 0xed, 0x7c, 0xf4, 0x1b, 0xb0, 0xf3, 0x4e, 0xef, 0x3c,
	0x51, 0xf4, 0xee, 0x6f, 0x41, 0xb6, 0x6d, 0x7f, 0x54, 0x23, 0x37, 0x60, 0x16, 0x60, 0xb3, 0xdd,
	0xa9, 0x09, 0xf4, 0xc6, 0xda, 0x93, 0x76, 0xd5, 0x7b, 0x5c, 0xf1, 0x2e, 0xec, 0x04, 0x70, 0xdd,
	0x5e, 0xa9, 0x55, 0x2d, 0x35, 0xdb, 0xad, 0x1a, 0xcf, 0x85, 0x90, 0x56, 0xda, 0xa7, 0x9d, 0x66,
	0xad, 0x4a, 0xf7, 0x63, 0x06, 0x49, 0x1b, 0x27, 0x7c, 0x74, 0xf7, 0x33, 0x48, 0xda, 0xf9, 0x4b,
	0xb4, 0x01, 0xab, 0x3d, 0xa1, 0x81, 0x79, 0xf6, 0xbc, 0x52, 0x11, 0xe4, 0x5c, 0x70, 0x4f, 0x38,
	0xc5, 0xa2, 0xd6, 0x20, 0xef, 0xc2, 0xea, 0xa5, 0x66, 0xb7, 0xc6, 0x47, 0x76, 0xff, 0x4b, 0x04,
	0x92, 0xf6, 0x85, 0xb9, 0x28, 0x0f, 0xe9, 0x4e, 0xb3, 0xe7, 0x61, 0x73, 0x07, 0xb6, 0x31, 0xe0,
	0xa8, 0xd6, 0xaa, 0x09, 0xe4, 0x2a, 0xca, 0x46, 0xb5, 0xd6, 0xea, 0x89, 0x9d, 0xe6, 0x69, 0x97,
	0x5d, 0xd7, 0x3b, 0x8f, 0x3d, 0xe0, 0x23, 0x73, 0x98, 0xf6, 0x49, 0xe9, 0xb8, 0xf4, 0xfc, 0x29,
	0x1f, 0xc5, 0xea, 0x08, 0xc3, 0x50, 0x96, 0x31, 0xb4, 0x03, 0x1b, 0x61, 0xe8, 0x03, 0x3e, 0xbe,
	0x08, 0xf5, 0x90, 0x5f, 0xc1, 0x3d, 0xc3, 0xa8, 0x93, 0x66, 0xeb, 0x0b, 0xb1, 0xdb, 0x3a, 0x78,
	0xbc, 0xb7, 0xc7, 0xa7, 0xb0, 0xf6, 0x30, 0xb0, 0x73, 0x28, 0x76, 0xdb, 0xf5, 0x9e, 0xd8, 0x7d,
	0xde, 0xe8, 0x55, 0x8e, 0x79, 0x20, 0xb7, 0x0f, 0x37, 0x7b, 0x62, 0xab, 0x73, 0x28, 0x36, 0x5a,
	0xbd, 0x5a, 0x53, 0x6c, 0x3d, 0xdc, 0xdb, 0xdb, 0xe3, 0xb3, 0xe8, 0x0d, 0xb8, 0xed, 0x15, 0x50,
	0x2e, 0x09, 0xb5, 0x7a, 0xbb, 0xdd, 0x13, 0x7b, 0xed, 0x7a, 0xa3, 0xd5, 0xe6, 0x73, 0xe8, 0x3e,
	0xdc, 0xb9, 0xa6, 0xc2, 0x01, 0x9f, 0xdf, 0xbd, 0x82, 0x8c, 0xf7, 0x0a, 0x75, 0x94, 0x85, 0xd4,
	0x69, 0xab, 0x5a, 0xab, 0x37, 0x5a, 0xb5, 0x2a, 0x7f, 0x0b, 0x25, 0x20, 0x5a, 0xae, 0xed, 0xf3,
	0xeb, 0xb8, 0x50, 0xaa, 0xef, 0xf3, 0x1b, 0xb4, 0x70, 0xc0, 0x6f, 0xd2, 0xc2, 0x43, 0x7e, 0x8b,
	0x16, 0x0e, 0xf9, 0x6d, 0x5c, 0x68, 0x55, 0xf6, 0xf9, 0x1d, 0x5a, 0xd8, 0xe3, 0x0b, 0x94, 0x7c,
	0x8f, 0xbf, 0x8d, 0x92, 0x10, 0x6b, 0x36, 0x3f, 0xdf, 0xe7, 0xef, 0xb2, 0xd2, 0x01, 0x7f, 0x6f,
	0xf7, 0x14, 0x12, 0x2c, 0x37, 0x8d, 0xd6, 0x81, 0xaf, 0xd7, 0x2a, 0xc1, 0x81, 0x98, 0x87, 0xb4,
	0x03, 0x6d, 0xb7, 0xe8, 0xb5, 0xe2, 0x2e, 0xa0, 0x5e, 0xa7, 0xbb, 0x65, 0x1d, 0x48, 0xe9, 0xb4,
	0xd7, 0xe6, 0xa3, 0xbb, 0x7d, 0xf6, 0xa1, 0x91, 0x0c, 0x36, 0xac, 0xd2, 0xb6, 0xd0, 0x9b, 0x1b,
	0x6d, 0xab, 0x90, 0xf5, 0xc2, 0x3b, 0x74, 0xb0, 0x79, 0x40, 0x55, 0x5c, 0x2f, 0x82, 0x07, 0xab,
	0x07, 0x58, 0x2f, 0x35, 0xf0, 0x38, 0x8f, 0xee, 0xb6, 0x01, 0xc8, 0x57, 0x02, 0x2a, 0x64, 0x0b,
	0xd6, 0xc8, 0x15, 0xa7, 0xe1, 0x63, 0xda, 0x83, 0xe8, 0xd0, 0x5d, 0xa7, 0x5e, 0x18, 0x95, 0xb3,
	0xfb, 0x4f, 0x39, 0xd8, 0x08, 0xfd, 0xee, 0x80, 0xde, 0x86, 0xfb, 0xb4, 0xfe, 0x49, 0xed, 0xa4,
	0x5c, 0x13, 0xe8, 0x55, 0x03, 0x73, 0x92, 0xae, 0xab, 0x45, 0xca, 0xe4, 0xdf, 0x78, 0xde, 0x85,
	0xb7, 0x16, 0xd6, 0xaa, 0xb7, 0x85, 0xe7, 0x25, 0xa1, 0x4a, 0xbe, 0xe6, 0xec, 0x5a, 0x90, 0xf5,
	0x7d, 0x31, 0xc6, 0x93, 0xbe, 0xd9, 0x6e, 0x77, 0xca, 0xa5, 0x10, 0xd9, 0x5b, 0xb0, 0x16, 0xc0,
	0xb5, 0xa8, 0xa5, 0xd8, 0x04, 0x14, 0x40, 0x9c, 0x94, 0x2a, 0xd4, 0x4a, 0x04, 0xe0, 0x9d, 0xe3,
	0x17, 0x7c, 0x74, 0x57, 0x05, 0x70, 0x3f, 0x33, 0x63, 0xb6, 0xa5, 0xea, 0x49, 0xa3, 0x15, 0x26,
	0xcf, 0x8b, 0xa8, 0xb5, 0xec, 0x3f, 0x1b, 0xda, 0x86, 0x75, 0x2f, 0xc2, 0xf9, 0x1b, 0xa2, 0x08,
	0x56, 0xba, 0x1f, 0x53, 0x3a, 0xe2, 0xa3, 0xbb, 0x3f, 0xe5, 0x20, 0xc1, 0xb6, 0x66, 0xe0, 0x1a,
	0xc7, 0xcf, 0xc3, 0x5e, 0xa0, 0x03, 0x15, 0x6a, 0xa5, 0xea, 0x0b, 0xfa, 0x02, 0x1d, 0x58, 0x47,
	0xa8, 0x75, 0xe9, 0xb6, 0xe1, 0x6d, 0x58, 0x77, 0xa0, 0xad, 0x76, 0xcf, 0xc1, 0x44, 0xf1, 0xa0,
	0x75, 0x30, 0x78, 0xd0, 0xc6, 0xd0, 0x6d, 0xd8, 0x72, 0x20, 0x95, 0x76, 0xab, 0xde, 0x38, 0x3a,
	0x15, 0x6a, 0x55, 0x82, 0x8c, 0xe3, 0x61, 0xe8, 0x20, 0xd9, 0x78, 0x5b, 0xc1, 0x5d, 0x76, 0x80,
	0xb8, 0xf1, 0xad, 0x76, 0xb7, 0xd7, 0xa8, 0xf0, 0x89, 0xdd, 0x1e, 0xa4, 0x3d, 0x5f, 0x98, 0x48,
	0x2b, 0x6a, 0xa5, 0x66, 0xef, 0x78, 0xae, 0x27, 0x1b, 0xb0, 0xea, 0xc3, 0x1c, 0xb5, 0xdb, 0x55,
	0xd6, 0x19, 0x2f, 0xb8, 0x5c, 0xaa, 0xf2, 0x91, 0xdd, 0x7f, 0xc8, 0x41, 0xb2, 0x29, 0x0f, 0x1d,
	0x7b, 0xdd, 0xac, 0x55, 0xc3, 0x66, 0x90, 0x0b, 0xc6, 0x4d, 0x27, 0x33, 0xc8, 0x05, 0x75, 0xdb,
	0xcd, 0x06, 0x56, 0xfd, 0x6d, 0xd8, 0x72, 0x81, 0xe5, 0x66, 0xa3, 0xf5, 0xb4, 0xd1, 0x3a, 0x12,
	0xbb, 0xcd, 0xf6, 0x73, 0x3e, 0xba, 0x00, 0x59, 0x2f, 0x75, 0x7b, 0x7c, 0x6c, 0xf7, 0xff, 0x70,
	0x64, 0xc3, 0x18, 0xd9, 0xc8, 0xb3, 0x0e, 0x3c, 0xae, 0xd8, 0x7b, 0xd1, 0xf1, 0xb6, 0x61, 0x07,
	0x36, 0x1c, 0x68, 0xb9, 0x51, 0x69, 0x37, 0xdb, 0x82, 0x58, 0xef, 0x1c, 0x95, 0x78, 0x2e, 0x14,
	0x85, 0xf9, 0xf3, 0x11, 0x6c, 0xd0, 0x43, 0xa9, 0xc4, 0x23, 0x51, 0xe0, 0xa3, 0xd8, 0x66, 0x3a,
	0xe8, 0x9e, 0xe0, 0xc3, 0x0b, 0xe2, 0xd1, 0x0b, 0x3e, 0x86, 0xcd, 0xee, 0xe2, 0x1a, 0x2f, 0xf8,
	0xf8, 0x75, 0x2c, 0x44, 0x5c, 0x63, 0x25, 0xb4, 0x0d, 0x47, 0x9d, 0x46, 0x9b, 0xb4, 0x21, 0xb1,
	0xfb, 0x6b, 0x44, 0xff, 0x64, 0x73, 0xbb, 0xad, 0x7f, 0x5a, 0xc7, 0xed, 0x3b, 0x53, 0x36, 0x23,
	0x15, 0x6a, 0xb5, 0x16, 0x3d, 0x4f, 0xe0, 0x02, 0x05, 0x32, 0xf4, 0x7d, 0xf5, 0x4a, 0x78, 0xda,
	0xf3, 0xd1, 0xdd, 0x7f, 0x1b, 0x01, 0x3e, 0xb8, 0xeb, 0x0a, 0xdd, 0x83, 0x42, 0xe7, 0xf8, 0x45,
	0xb7, 0x51, 0x29, 0x35, 0xc9, 0xc5, 0x2c, 0x41, 0x6d, 0x17, 0xe1, 0x5e, 0x08, 0xbe, 0xd6, 0x3b,
	0xae, 0x09, 0xad, 0x5a, 0x4f, 0xdc, 0x3f, 0xe2, 0x39, 0xe2, 0x7e, 0xe7, 0xeb, 0x34, 0x3a, 0xa5,
	0x6e, 0x97, 0x8f, 0x10, 0x7f, 0x35, 0x8f, 0xed, 0xd6, 0x3b, 0x62, 0xa5, 0x74, 0x54, 0xa3, 0xba,
	0x0f, 0xa9, 0xf0, 0xb9, 0x53, 0x23, 0xb6, 0xa0, 0x91, 0x4d, 0x86, 0x8f, 0x2f, 0x10, 0x51, 0xb1,
	0x19, 0xac, 0x2c, 0x10, 0x81, 0x6d, 0x51, 0xa7, 0x59, 0x6a, 0xd5, 0xf8, 0x04, 0xf9, 0x27, 0x80,
	0xf9, 0x1a, 0xd5, 0xe7, 0xd5, 0x13, 0x3e, 0xb9, 0xfb, 0x27, 0x11, 0x48, 0x39, 0x5b, 0xcd, 0xb0,
	0x25, 0x3b, 0xa9, 0x55, 0x1b, 0xa5, 0xa0, 0xaa, 0xb6, 0x60, 0xcd, 0x03, 0x27, 0xed, 0xef, 0x0a,
	0x87, 0x3c, 0x17, 0x86, 0x68, 0x0a, 0x87, 0x7c, 0x04, 0x1b, 0xd8, 0x20, 0xa2, 0xd2, 0xee, 0x74,
	0x6a, 0xec, 0x8f, 0x32, 0x3c, 0xb8, 0x6e, 0xbd, 0xc3, 0xc7, 0xf1, 0x4c, 0x0f, 0xd6, 0xef, 0x74,
	0x4f, 0x0e, 0xf9, 0x95, 0x40, 0x9b, 0x2a, 0x4c, 0x42, 0x02, 0xcf, 0x88, 0x00, 0x9c, 0x09, 0x48,
	0x06, 0x98, 0x95, 0x1d, 0x4c, 0x2a, 0x4c, 0x4c, 0x05, 0xf7, 0x24, 0x1d, 0x8a, 0xc1, 0x82, 0x32,
	0xa1, 0x98, 0x8a, 0x70, 0xc8, 0xe7, 0x76, 0x7f, 0x97, 0x83, 0x44, 0x77, 0xa4, 0xdb, 0x33, 0x1a,
	0x63, 0x02, 0x8a, 0xe3, 0x21, 0xe3, 0x40, 0x71, 0x47, 0xc9, 0x90, 0x76, 0x20, 0x98, 0x17, 0xf5,
	0x1f, 0x3e, 0x10, 0x0d, 0xc5, 0xa2, 0x78, 0xa8, 0xfb, 0xe0, 0x07, 0x4f, 0xe8, 0x41, 0x19, 0x2f,
	0xc7, 0x83, 0x27, 0x7c, 0x7c, 0xf7, 0x27, 0x9c, 0x67, 0x67, 0xb5, 0xfd, 0xef, 0x0f, 0xb8, 0x16,
	0xf9, 0x1b, 0x87, 0x5a, 0xb0, 0x51, 0x6f, 0xc2, 0xdd, 0x20, 0x72, 0x7f, 0x6f, 0xef, 0x48, 0x2c,
	0x97, 0xba, 0x35, 0xb1, 0x42, 0xde, 0xeb, 0x1b, 0x70, 0x7b, 0xbe, 0x8a, 0x53, 0x83, 0x8f, 0xe0,
	0x71, 0x3b, 0x57, 0x81, 0xe1, 0xbb, 0x5f, 0xf0, 0xd1, 0xdd, 0x4f, 0x60, 0xa5, 0x2e, 0xa9, 0x55,
	0xc5, 0xc0, 0xbd, 0xa8, 0x97, 0x5a, 0x62, 0xb5, 0x21, 0x04, 0x42, 0x21, 0x06, 0x2c, 0x1f, 0xd4,
	0xe9, 0x15, 0x40, 0x36, 0xa0, 0x7e, 0x50, 0xe6, 0x23, 0xbb, 0xcf, 0xc8, 0x9e, 0x67, 0x5b, 0xb5,
	0x9d, 0xee, 0x69, 0xb0, 0x17, 0x38, 0x54, 0xb6, 0xa1, 0xa5, 0x0a, 0xd5, 0xac, 0x03, 0xa8, 0x56,
	0xf6, 0x0f, 0x68, 0x38, 0xe5, 0x01, 0x1d, 0x3e, 0xe1, 0xa3, 0xbb, 0x7f, 0x40, 0xb7, 0xed, 0xda,
	0x61, 0x1a, 0xb6, 0x25, 0x81, 0x30, 0x8d, 0x87, 0x8c, 0x03, 0xa5, 0x8e, 0x80, 0x99, 0x21, 0x37,
	0x2a, 0x23, 0xe3, 0xdb, 0x07, 0x72, 0xac, 0x3d, 0x1f, 0xf5, 0x55, 0xaf, 0x1c, 0x97, 0x04, 0x3e,
	0xe6, 0xe3, 0x89, 0xed, 0x58, 0xdc, 0x36, 0xe8, 0x36, 0xc4, 0xa5, 0x5f, 0xb1, 0x4d, 0x1c, 0x6d,
	0x80, 0x50, 0x6a, 0x1d, 0xe1, 0x59, 0x7c, 0x07, 0xb6, 0x03, 0x40, 0x97, 0x24, 0xe9, 0x23, 0x79,
	0x51, 0x6b, 0x62, 0x6f, 0x94, 0xf2, 0x91, 0x50, 0xa0, 0x4b, 0x02, 0x78, 0x20, 0x39, 0x58, 0x6a,
	0x6f, 0xd3, 0xb6, 0xff, 0x72, 0x61, 0x2e, 0x41, 0xc6, 0xd7, 0xad, 0x72, 0xf3, 0xb4, 0xc6, 0x67,
	0x7d, 0x5a, 0xc0, 0x20, 0xb7, 0x7a, 0xce, 0xd7, 0xa4, 0xce, 0xa9, 0xd0, 0x69, 0xd6, 0xf8, 0xbc,
	0xaf, 0x49, 0x14, 0xe8, 0x92, 0xf0, 0xe5, 0xdb, 0x7f, 0xf6, 0xf3, 0x7b, 0xdc, 0xcf, 0x7e, 0x7e,
	0x8f, 0xfb, 0xab, 0x9f, 0xdf, 0xe3, 0x7e, 0xf2, 0x8b, 0x7b, 0xb7, 0x7e, 0xf6, 0x8b, 0x7b, 0xb7,
	0xfe, 0xfb, 0x2f, 0xee, 0xdd, 0xfa, 0xfb, 0xdc, 0xad, 0xfe, 0x0a, 0xd9, 0x1f, 0xf6, 0xf0, 0xff,
	0x07, 0x00, 0x00, 0xff, 0xff, 0x33, 0xe0, 0x68, 0x89, 0xb0, 0x75, 0x00, 0x00,
}

func (m *ChassisConfigParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TuntapConfigs) > 0 {
		for iNdEx := len(m.TuntapConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TuntapConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FanConfigs) > 0 {
		for iNdEx := len(m.FanConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FanConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PowerConfig != nil {
		{
			size, err := m.PowerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NetConfig != nil {
		{
			size, err := m.NetConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LacpConfig != nil {
		{
			size, err := m.LacpConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChassisConfigParams_LacpConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams_LacpConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams_LacpConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LacpSystemPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.LacpSystemPriority))
		i--
		dAtA[i] = 0x10
	}
	if m.LacpRouterMac != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.LacpRouterMac))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChassisConfigParams_NtpConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams_NtpConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams_NtpConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ChassisConfigParams_PowerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams_PowerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams_PowerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ChassisConfigParams_FanConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams_FanConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams_FanConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetTemperatureCelsius != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.TargetTemperatureCelsius))
		i--
		dAtA[i] = 0x18
	}
	if m.SpeedPercentage != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpeedPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChassisConfigParams_TuntapConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfigParams_TuntapConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfigParams_TuntapConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultNetdev {
		i--
		if m.DefaultNetdev {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Ipv6Prefixlen != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Ipv6Prefixlen))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Ipv6Address) > 0 {
		i -= len(m.Ipv6Address)
		copy(dAtA[i:], m.Ipv6Address)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Ipv6Address)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ipv4Prefixlen != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Ipv4Prefixlen))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ipv4Address) > 0 {
		i -= len(m.Ipv4Address)
		copy(dAtA[i:], m.Ipv4Address)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Ipv4Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeFlowParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeFlowParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeFlowParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QosConfig != nil {
		{
			size, err := m.QosConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.L2Config != nil {
		{
			size, err := m.L2Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VlanConfigs) > 0 {
		for iNdEx := len(m.VlanConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VlanConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_VlanConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_VlanConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_VlanConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisableL2Learning {
		i--
		if m.DisableL2Learning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.BlockUnknownUnicast {
		i--
		if m.BlockUnknownUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BlockUnknownMulticast {
		i--
		if m.BlockUnknownMulticast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.BlockKnownMulticast {
		i--
		if m.BlockKnownMulticast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.BlockBroadcast {
		i--
		if m.BlockBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.VlanId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.VlanId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_L2Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_L2Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_L2Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L2AgeDurationSec != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.L2AgeDurationSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EgressServicePoolMapping) > 0 {
		for iNdEx := len(m.EgressServicePoolMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressServicePoolMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.IngressServicePoolMapping) > 0 {
		for iNdEx := len(m.IngressServicePoolMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressServicePoolMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PriorityGroupMapping) > 0 {
		for iNdEx := len(m.PriorityGroupMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PriorityGroupMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CosqMapping) > 0 {
		for iNdEx := len(m.CosqMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosqMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TrafficClassMapping) > 0 {
		for iNdEx := len(m.TrafficClassMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrafficClassMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DscpMapping) > 0 {
		for iNdEx := len(m.DscpMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DscpMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Dot1PMapping) > 0 {
		for iNdEx := len(m.Dot1PMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dot1PMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SchedulingConfig) > 0 {
		for iNdEx := len(m.SchedulingConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SchedulingConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SchedulingMode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SchedulingMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxBandwidthPercent != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxBandwidthPercent))
		i--
		dAtA[i] = 0x20
	}
	if m.MinBandwidthPercent != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MinBandwidthPercent))
		i--
		dAtA[i] = 0x18
	}
	if m.SchedulerWeight != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SchedulerWeight))
		i--
		dAtA[i] = 0x10
	}
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x10
	}
	if m.Dot1PPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Dot1PPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_DscpMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_DscpMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_DscpMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x18
	}
	if m.DscpEnd != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DscpEnd))
		i--
		dAtA[i] = 0x10
	}
	if m.DscpStart != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.DscpStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrafficClass != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.TrafficClass))
		i--
		dAtA[i] = 0x10
	}
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgNum))
		i--
		dAtA[i] = 0x10
	}
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_CosqMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_CosqMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_CosqMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QNum))
		i--
		dAtA[i] = 0x10
	}
	if m.InternalPriority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InternalPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpNum))
		i--
		dAtA[i] = 0x10
	}
	if m.PgNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpNum))
		i--
		dAtA[i] = 0x10
	}
	if m.QNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortFlowParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortFlowParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortFlowParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PortConfigParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortConfigParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortConfigParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoopbackMode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.LoopbackMode))
		i--
		dAtA[i] = 0x40
	}
	if m.MacAddress != nil {
		{
			size, err := m.MacAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.FecMode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.FecMode))
		i--
		dAtA[i] = 0x30
	}
	if m.ModulationType != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ModulationType))
		i--
		dAtA[i] = 0x28
	}
	if m.HashConfig != nil {
		{
			size, err := m.HashConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Autoneg != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Autoneg))
		i--
		dAtA[i] = 0x18
	}
	if m.Mtu != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x10
	}
	if m.AdminState != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.AdminState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortConfigParams_HashConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortConfigParams_HashConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortConfigParams_HashConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rtag7LagHashSelect != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Rtag7LagHashSelect))
		i--
		dAtA[i] = 0x10
	}
	if m.Rtag7EcmpHashSelect != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Rtag7EcmpHashSelect))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Chassis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chassis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chassis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigParams != nil {
		{
			size, err := m.ConfigParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Platform != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Platform))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigParams != nil {
		{
			size, err := m.ConfigParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FlowParams != nil {
		{
			size, err := m.FlowParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Index != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x20
	}
	if m.Slot != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SingletonPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingletonPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingletonPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x48
	}
	if m.ConfigParams != nil {
		{
			size, err := m.ConfigParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.FlowParams != nil {
		{
			size, err := m.FlowParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SpeedBps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpeedBps))
		i--
		dAtA[i] = 0x30
	}
	if m.Channel != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x28
	}
	if m.Port != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.Slot != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpticalNetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticalNetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticalNetworkInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LinePort) > 0 {
		i -= len(m.LinePort)
		copy(dAtA[i:], m.LinePort)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.LinePort)))
		i--
		dAtA[i] = 0x42
	}
	if m.OperationalMode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OperationalMode))
		i--
		dAtA[i] = 0x38
	}
	if m.TargetOutputPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TargetOutputPower))))
		i--
		dAtA[i] = 0x31
	}
	if m.Frequency != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x28
	}
	if m.NetworkInterface != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NetworkInterface))
		i--
		dAtA[i] = 0x20
	}
	if m.Module != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Module))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrunkPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrunkPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrunkPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigParams != nil {
		{
			size, err := m.ConfigParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.FlowParams != nil {
		{
			size, err := m.FlowParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Members) > 0 {
		dAtA16 := make([]byte, len(m.Members)*10)
		var j15 int
		for _, num := range m.Members {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintCommon(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Node != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortGroup_PortGroupMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortGroup_PortGroupMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortGroup_PortGroupMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeIdToRtag7HashConfig) > 0 {
		for k := range m.NodeIdToRtag7HashConfig {
			v := m.NodeIdToRtag7HashConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.NodeIdToBufferConfig) > 0 {
		for k := range m.NodeIdToBufferConfig {
			v := m.NodeIdToBufferConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.NodeIdToRateLimitConfig) > 0 {
		for k := range m.NodeIdToRateLimitConfig {
			v := m.NodeIdToRateLimitConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeIdToTxConfig) > 0 {
		for k := range m.NodeIdToTxConfig {
			v := m.NodeIdToTxConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NodeIdToRxConfig) > 0 {
		for k := range m.NodeIdToRxConfig {
			v := m.NodeIdToRxConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NodeIdToKnetConfig) > 0 {
		for k := range m.NodeIdToKnetConfig {
			v := m.NodeIdToKnetConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BcmChassisMapId) > 0 {
		i -= len(m.BcmChassisMapId)
		copy(dAtA[i:], m.BcmChassisMapId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BcmChassisMapId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmKnetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmKnetConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmKnetConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KnetIntfConfigs) > 0 {
		for iNdEx := len(m.KnetIntfConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KnetIntfConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Purpose != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Purpose))
		i--
		dAtA[i] = 0x20
	}
	if m.Vlan != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuQueue != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.CpuQueue))
		i--
		dAtA[i] = 0x10
	}
	if m.Mtu != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRxConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRxConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRxConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DmaChannelConfigs) > 0 {
		for k := range m.DmaChannelConfigs {
			v := m.DmaChannelConfigs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.UseInterrupt {
		i--
		if m.UseInterrupt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.MaxBurstPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxBurstPkts))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxRatePps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxRatePps))
		i--
		dAtA[i] = 0x28
	}
	if m.PktsPerChain != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PktsPerChain))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxPktSizeBytes != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxPktSizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.RxPoolBytesPerPkt != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.RxPoolBytesPerPkt))
		i--
		dAtA[i] = 0x10
	}
	if m.RxPoolPktCount != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.RxPoolPktCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CosSet) > 0 {
		dAtA25 := make([]byte, len(m.CosSet)*10)
		var j24 int
		for _, num1 := range m.CosSet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintCommon(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x32
	}
	if m.NoPktParsing {
		i--
		if m.NoPktParsing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.OversizedPacketsOk {
		i--
		if m.OversizedPacketsOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.StripVlan {
		i--
		if m.StripVlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.StripCrc {
		i--
		if m.StripCrc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Chains != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Chains))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmTxConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmTxConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmTxConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRateLimitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRateLimitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRateLimitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PerCosRateLimitConfigs) > 0 {
		for k := range m.PerCosRateLimitConfigs {
			v := m.PerCosRateLimitConfigs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaxBurstPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxBurstPkts))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRatePps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxRatePps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxBurstPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxBurstPkts))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRatePps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxRatePps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmBufferConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmBufferConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmBufferConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortMin != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortMin))
		i--
		dAtA[i] = 0x10
	}
	if m.GlobalHdrmLimit != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.GlobalHdrmLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxEgressBufBytes != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxEgressBufBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxIngressBufBytes != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxIngressBufBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.SpNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgSharedDynamic != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgSharedDynamic))
		i--
		dAtA[i] = 0x28
	}
	if m.PgSharedLimitCell != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgSharedLimitCell))
		i--
		dAtA[i] = 0x20
	}
	if m.PgHdrmGlobalEnable != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgHdrmGlobalEnable))
		i--
		dAtA[i] = 0x18
	}
	if m.PgMin != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgMin))
		i--
		dAtA[i] = 0x10
	}
	if m.PgNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PgNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QColorLimitDynamicCell != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QColorLimitDynamicCell))
		i--
		dAtA[i] = 0x38
	}
	if m.QSharedAlphaCell != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QSharedAlphaCell))
		i--
		dAtA[i] = 0x30
	}
	if m.QSharedLimitCell != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QSharedLimitCell))
		i--
		dAtA[i] = 0x28
	}
	if m.QLimitDynamic != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QLimitDynamic))
		i--
		dAtA[i] = 0x20
	}
	if m.QLimitEnable != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QLimitEnable))
		i--
		dAtA[i] = 0x18
	}
	if m.QMin != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QMin))
		i--
		dAtA[i] = 0x10
	}
	if m.QNum != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LagHashConfig != nil {
		{
			size, err := m.LagHashConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EcmpHashConfig != nil {
		{
			size, err := m.EcmpHashConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MacroFlowHashConfig != nil {
		{
			size, err := m.MacroFlowHashConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HashFunctionConfigs) > 0 {
		for iNdEx := len(m.HashFunctionConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashFunctionConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Polynomial_1 != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Polynomial_1))
		i--
		dAtA[i] = 0x28
	}
	if m.Polynomial_0 != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Polynomial_0))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Fields) > 0 {
		dAtA31 := make([]byte, len(m.Fields)*10)
		var j30 int
		for _, num := range m.Fields {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintCommon(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x1a
	}
	if m.Seed != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x10
	}
	if m.Block != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Block))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x30
	}
	if m.RandomIterations != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.RandomIterations))
		i--
		dAtA[i] = 0x28
	}
	if m.RandomizeTable {
		i--
		if m.RandomizeTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UseMsb_16Bits {
		i--
		if m.UseMsb_16Bits {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.TableConfigs) > 0 {
		for iNdEx := len(m.TableConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Polynomial != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Polynomial))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexEnd != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.IndexEnd))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexStart != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.IndexStart))
		i--
		dAtA[i] = 0x10
	}
	if m.SubBlock != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SubBlock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortHashSelect != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortHashSelect))
		i--
		dAtA[i] = 0x20
	}
	if m.TableConfig_1 != nil {
		{
			size, err := m.TableConfig_1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TableConfig_0 != nil {
		{
			size, err := m.TableConfig_0.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Block))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseMacroFlowHash {
		i--
		if m.UseMacroFlowHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeIdToQosConfig) > 0 {
		for k := range m.NodeIdToQosConfig {
			v := m.NodeIdToQosConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NodeIdToDeflectOnDropConfigs) > 0 {
		for k := range m.NodeIdToDeflectOnDropConfigs {
			v := m.NodeIdToDeflectOnDropConfigs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeIdToPortShapingConfig) > 0 {
		for k := range m.NodeIdToPortShapingConfig {
			v := m.NodeIdToPortShapingConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_PacketShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_PacketShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_PacketShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BurstPackets != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.BurstPackets))
		i--
		dAtA[i] = 0x10
	}
	if m.RatePps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.RatePps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_ByteShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_ByteShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_ByteShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BurstBytes != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.BurstBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RateBps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.RateBps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_BfPortShapingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_BfPortShapingConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_BfPortShapingConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PerPortShapingConfigs) > 0 {
		for k := range m.PerPortShapingConfigs {
			v := m.PerPortShapingConfigs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintCommon(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shaping != nil {
		{
			size := m.Shaping.Size()
			i -= size
			if _, err := m.Shaping.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PacketShaping != nil {
		{
			size, err := m.PacketShaping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ByteShaping != nil {
		{
			size, err := m.ByteShaping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_DeflectOnPacketDropConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_DeflectOnPacketDropConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropTargets) > 0 {
		for iNdEx := len(m.DropTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DropTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Queue != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Queue))
		i--
		dAtA[i] = 0x18
	}
	if m.PortType != nil {
		{
			size := m.PortType.Size()
			i -= size
			if _, err := m.PortType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.SdkPort))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_TofinoQosConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueueConfigs) > 0 {
		for iNdEx := len(m.QueueConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueueConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PpgConfigs) > 0 {
		for iNdEx := len(m.PpgConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PpgConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PoolColorDropHysteresisRed != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PoolColorDropHysteresisRed))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolColorDropHysteresisYellow != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PoolColorDropHysteresisYellow))
		i--
		dAtA[i] = 0x18
	}
	if m.PoolColorDropHysteresisGreen != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PoolColorDropHysteresisGreen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PoolConfigs) > 0 {
		for iNdEx := len(m.PoolConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColorDropLimitRed != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ColorDropLimitRed))
		i--
		dAtA[i] = 0x30
	}
	if m.ColorDropLimitYellow != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ColorDropLimitYellow))
		i--
		dAtA[i] = 0x28
	}
	if m.ColorDropLimitGreen != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ColorDropLimitGreen))
		i--
		dAtA[i] = 0x20
	}
	if m.EnableColorDrop {
		i--
		if m.EnableColorDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PoolSize != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PoolSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Pool != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortType != nil {
		{
			size := m.PortType.Size()
			i -= size
			if _, err := m.PortType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IsDefaultPpg {
		i--
		if m.IsDefaultPpg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IcosBitmap != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.IcosBitmap))
		i--
		dAtA[i] = 0x40
	}
	if m.IngressDropLimit != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.IngressDropLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.Hysteresis != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Hysteresis))
		i--
		dAtA[i] = 0x30
	}
	if m.Baf != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Baf))
		i--
		dAtA[i] = 0x28
	}
	if m.BaseUseLimit != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.BaseUseLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.Pool != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumGuaranteedCells != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MinimumGuaranteedCells))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.SdkPort))
	i--
	dAtA[i] = 0x50
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueueMapping) > 0 {
		for iNdEx := len(m.QueueMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueueMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PortType != nil {
		{
			size := m.PortType.Size()
			i -= size
			if _, err := m.PortType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCommon(dAtA, i, uint64(m.SdkPort))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColorDropLimitRed != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ColorDropLimitRed))
		i--
		dAtA[i] = 0x78
	}
	if m.ColorDropLimitYellow != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.ColorDropLimitYellow))
		i--
		dAtA[i] = 0x70
	}
	if m.EnableColorDrop {
		i--
		if m.EnableColorDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MinRate != nil {
		{
			size := m.MinRate.Size()
			i -= size
			if _, err := m.MinRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaxRate != nil {
		{
			size := m.MaxRate.Size()
			i -= size
			if _, err := m.MaxRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Hysteresis != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Hysteresis))
		i--
		dAtA[i] = 0x40
	}
	if m.Baf != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Baf))
		i--
		dAtA[i] = 0x38
	}
	if m.BaseUseLimit != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.BaseUseLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.Pool != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x28
	}
	if m.MinimumGuaranteedCells != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MinimumGuaranteedCells))
		i--
		dAtA[i] = 0x20
	}
	if m.Weight != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Priority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if m.QueueId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QueueId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MaxRatePackets != nil {
		{
			size, err := m.MaxRatePackets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MaxRateBytes != nil {
		{
			size, err := m.MaxRateBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MinRatePackets != nil {
		{
			size, err := m.MinRatePackets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MinRateBytes != nil {
		{
			size, err := m.MinRateBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *VendorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VendorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VendorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TofinoConfig != nil {
		{
			size, err := m.TofinoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GoogleConfig != nil {
		{
			size, err := m.GoogleConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChassisConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChassisConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChassisConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpticalNetworkInterfaces) > 0 {
		for iNdEx := len(m.OpticalNetworkInterfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpticalNetworkInterfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.VendorConfig != nil {
		{
			size, err := m.VendorConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PortGroups) > 0 {
		for iNdEx := len(m.PortGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PortGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TrunkPorts) > 0 {
		for iNdEx := len(m.TrunkPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrunkPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SingletonPorts) > 0 {
		for iNdEx := len(m.SingletonPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SingletonPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Chassis != nil {
		{
			size, err := m.Chassis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SfpModuleCaps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SfpModuleCaps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SfpModuleCaps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.F_100G {
		i--
		if m.F_100G {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.F_40G {
		i--
		if m.F_40G {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.F_10G {
		i--
		if m.F_10G {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.F_1G {
		i--
		if m.F_1G {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.F_100 {
		i--
		if m.F_100 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FanCaps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FanCaps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FanCaps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GetPercentage {
		i--
		if m.GetPercentage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.GetRpm {
		i--
		if m.GetRpm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SetPercentage {
		i--
		if m.SetPercentage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SetRpm {
		i--
		if m.SetRpm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GetDir {
		i--
		if m.GetDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SetDir {
		i--
		if m.SetDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PsuCaps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PsuCaps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PsuCaps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GetPout {
		i--
		if m.GetPout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.GetPin {
		i--
		if m.GetPin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.GetIout {
		i--
		if m.GetIout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.GetIin {
		i--
		if m.GetIin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.GetVout {
		i--
		if m.GetVout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GetVin {
		i--
		if m.GetVin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.GetType {
		i--
		if m.GetType {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThermalCaps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThermalCaps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThermalCaps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GetShutdownThreshold {
		i--
		if m.GetShutdownThreshold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.GetErrorThreshold {
		i--
		if m.GetErrorThreshold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GetWarningThreshold {
		i--
		if m.GetWarningThreshold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.GetTemperature {
		i--
		if m.GetTemperature {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedCaps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedCaps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedCaps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PurpleBlinking {
		i--
		if m.PurpleBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Purple {
		i--
		if m.Purple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.BlueBlinking {
		i--
		if m.BlueBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Blue {
		i--
		if m.Blue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.GreenBlinking {
		i--
		if m.GreenBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Green {
		i--
		if m.Green {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.YellowBlinking {
		i--
		if m.YellowBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Yellow {
		i--
		if m.Yellow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.OrangeBlinking {
		i--
		if m.OrangeBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Orange {
		i--
		if m.Orange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RedBlinking {
		i--
		if m.RedBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Red {
		i--
		if m.Red {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Char {
		i--
		if m.Char {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AutoBlinking {
		i--
		if m.AutoBlinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Auto {
		i--
		if m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Off {
		i--
		if m.Off {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FrontPanelPortInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrontPanelPortInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrontPanelPortInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HwState != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.HwState))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PartNumber) > 0 {
		i -= len(m.PartNumber)
		copy(dAtA[i:], m.PartNumber)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PartNumber)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VendorName) > 0 {
		i -= len(m.VendorName)
		copy(dAtA[i:], m.VendorName)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.VendorName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MediaType != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MediaType))
		i--
		dAtA[i] = 0x10
	}
	if m.PhysicalPortType != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PhysicalPortType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpticalTransceiverInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticalTransceiverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticalTransceiverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OperationalMode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OperationalMode))
		i--
		dAtA[i] = 0x28
	}
	if m.TargetOutputPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TargetOutputPower))))
		i--
		dAtA[i] = 0x21
	}
	if m.OutputPower != nil {
		{
			size, err := m.OutputPower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InputPower != nil {
		{
			size, err := m.InputPower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Frequency != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpticalTransceiverInfo_Power) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticalTransceiverInfo_Power) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticalTransceiverInfo_Power) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinTime != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MinTime))
		i--
		dAtA[i] = 0x38
	}
	if m.Min != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
		i--
		dAtA[i] = 0x31
	}
	if m.MaxTime != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxTime))
		i--
		dAtA[i] = 0x28
	}
	if m.Max != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
		i--
		dAtA[i] = 0x21
	}
	if m.Interval != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x18
	}
	if m.Avg != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Avg))))
		i--
		dAtA[i] = 0x11
	}
	if m.Instant != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Instant))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *OperStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeLastChanged != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.TimeLastChanged))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoopbackStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MacAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MacAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MacAddress != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MacAddress))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortSpeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SpeedBps != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.SpeedBps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SystemPriority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortCounters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InFcsErrors != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InFcsErrors))
		i--
		dAtA[i] = 0x70
	}
	if m.OutErrors != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutErrors))
		i--
		dAtA[i] = 0x68
	}
	if m.OutDiscards != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutDiscards))
		i--
		dAtA[i] = 0x60
	}
	if m.OutMulticastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutMulticastPkts))
		i--
		dAtA[i] = 0x58
	}
	if m.OutBroadcastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutBroadcastPkts))
		i--
		dAtA[i] = 0x50
	}
	if m.OutUnicastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutUnicastPkts))
		i--
		dAtA[i] = 0x48
	}
	if m.OutOctets != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutOctets))
		i--
		dAtA[i] = 0x40
	}
	if m.InUnknownProtos != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InUnknownProtos))
		i--
		dAtA[i] = 0x38
	}
	if m.InErrors != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InErrors))
		i--
		dAtA[i] = 0x30
	}
	if m.InDiscards != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InDiscards))
		i--
		dAtA[i] = 0x28
	}
	if m.InMulticastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InMulticastPkts))
		i--
		dAtA[i] = 0x20
	}
	if m.InBroadcastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InBroadcastPkts))
		i--
		dAtA[i] = 0x18
	}
	if m.InUnicastPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InUnicastPkts))
		i--
		dAtA[i] = 0x10
	}
	if m.InOctets != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.InOctets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortQosCounters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortQosCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortQosCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutDroppedPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutDroppedPkts))
		i--
		dAtA[i] = 0x20
	}
	if m.OutPkts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutPkts))
		i--
		dAtA[i] = 0x18
	}
	if m.OutOctets != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.OutOctets))
		i--
		dAtA[i] = 0x10
	}
	if m.QueueId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QueueId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alarm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Severity != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.TimeCreated != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.TimeCreated))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChipName) > 0 {
		i -= len(m.ChipName)
		copy(dAtA[i:], m.ChipName)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ChipName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VendorName) > 0 {
		i -= len(m.VendorName)
		copy(dAtA[i:], m.VendorName)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.VendorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeDebugInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeDebugInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeDebugInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DebugString) > 0 {
		i -= len(m.DebugString)
		copy(dAtA[i:], m.DebugString)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DebugString)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForwardingViability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardingViability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardingViability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HealthIndicator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutonegotiationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutonegotiationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutonegotiationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FecStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FecStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FecStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SdnPortId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdnPortId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SdnPortId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request_OperStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_OperStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OperStatus != nil {
		{
			size, err := m.OperStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_AdminStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_AdminStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminStatus != nil {
		{
			size, err := m.AdminStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_MacAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_MacAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MacAddress != nil {
		{
			size, err := m.MacAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_PortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_PortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortSpeed != nil {
		{
			size, err := m.PortSpeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_NegotiatedPortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_NegotiatedPortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NegotiatedPortSpeed != nil {
		{
			size, err := m.NegotiatedPortSpeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_LacpRouterMac) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_LacpRouterMac) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpRouterMac != nil {
		{
			size, err := m.LacpRouterMac.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_LacpSystemPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_LacpSystemPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpSystemPriority != nil {
		{
			size, err := m.LacpSystemPriority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_PortCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_PortCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortCounters != nil {
		{
			size, err := m.PortCounters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_MemoryErrorAlarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_MemoryErrorAlarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MemoryErrorAlarm != nil {
		{
			size, err := m.MemoryErrorAlarm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_FlowProgrammingExceptionAlarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_FlowProgrammingExceptionAlarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlowProgrammingExceptionAlarm != nil {
		{
			size, err := m.FlowProgrammingExceptionAlarm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_PortQosCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_PortQosCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortQosCounters != nil {
		{
			size, err := m.PortQosCounters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_NodePacketioDebugInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_NodePacketioDebugInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodePacketioDebugInfo != nil {
		{
			size, err := m.NodePacketioDebugInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_ForwardingViability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_ForwardingViability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForwardingViability != nil {
		{
			size, err := m.ForwardingViability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_HealthIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_HealthIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HealthIndicator != nil {
		{
			size, err := m.HealthIndicator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_AutonegStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_AutonegStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutonegStatus != nil {
		{
			size, err := m.AutonegStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_FrontPanelPortInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_FrontPanelPortInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FrontPanelPortInfo != nil {
		{
			size, err := m.FrontPanelPortInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_FecStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_FecStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FecStatus != nil {
		{
			size, err := m.FecStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_OpticalTransceiverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_OpticalTransceiverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpticalTransceiverInfo != nil {
		{
			size, err := m.OpticalTransceiverInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_LoopbackStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_LoopbackStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackStatus != nil {
		{
			size, err := m.LoopbackStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeInfo != nil {
		{
			size, err := m.NodeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_SdnPortId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_SdnPortId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SdnPortId != nil {
		{
			size, err := m.SdnPortId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *DataRequest_Request_Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request_Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request_Chassis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request_Chassis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_Chassis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request_PortQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request_PortQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_PortQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.QueueId))
		i--
		dAtA[i] = 0x18
	}
	if m.PortId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataRequest_Request_OpticalNetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRequest_Request_OpticalNetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRequest_Request_OpticalNetworkInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkInterface != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NetworkInterface))
		i--
		dAtA[i] = 0x10
	}
	if m.Module != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Module))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataResponse_OperStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_OperStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OperStatus != nil {
		{
			size, err := m.OperStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_AdminStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_AdminStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminStatus != nil {
		{
			size, err := m.AdminStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_MacAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_MacAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MacAddress != nil {
		{
			size, err := m.MacAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_PortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_PortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortSpeed != nil {
		{
			size, err := m.PortSpeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_NegotiatedPortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_NegotiatedPortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NegotiatedPortSpeed != nil {
		{
			size, err := m.NegotiatedPortSpeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_LacpRouterMac) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_LacpRouterMac) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpRouterMac != nil {
		{
			size, err := m.LacpRouterMac.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_LacpSystemPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_LacpSystemPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpSystemPriority != nil {
		{
			size, err := m.LacpSystemPriority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_PortCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_PortCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortCounters != nil {
		{
			size, err := m.PortCounters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_MemoryErrorAlarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_MemoryErrorAlarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MemoryErrorAlarm != nil {
		{
			size, err := m.MemoryErrorAlarm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_FlowProgrammingExceptionAlarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_FlowProgrammingExceptionAlarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlowProgrammingExceptionAlarm != nil {
		{
			size, err := m.FlowProgrammingExceptionAlarm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_PortQosCounters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_PortQosCounters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortQosCounters != nil {
		{
			size, err := m.PortQosCounters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_NodePacketioDebugInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_NodePacketioDebugInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodePacketioDebugInfo != nil {
		{
			size, err := m.NodePacketioDebugInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_ForwardingViability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_ForwardingViability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForwardingViability != nil {
		{
			size, err := m.ForwardingViability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_HealthIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_HealthIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HealthIndicator != nil {
		{
			size, err := m.HealthIndicator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_AutonegStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_AutonegStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutonegStatus != nil {
		{
			size, err := m.AutonegStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_FrontPanelPortInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_FrontPanelPortInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FrontPanelPortInfo != nil {
		{
			size, err := m.FrontPanelPortInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_FecStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_FecStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FecStatus != nil {
		{
			size, err := m.FecStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_OpticalTransceiverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_OpticalTransceiverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpticalTransceiverInfo != nil {
		{
			size, err := m.OpticalTransceiverInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_LoopbackStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_LoopbackStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackStatus != nil {
		{
			size, err := m.LoopbackStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeInfo != nil {
		{
			size, err := m.NodeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *DataResponse_SdnPortId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataResponse_SdnPortId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SdnPortId != nil {
		{
			size, err := m.SdnPortId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request_Port_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Node_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Node_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Chassis_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Chassis_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Chassis != nil {
		{
			size, err := m.Chassis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_OpticalNetworkInterface_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_OpticalNetworkInterface_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpticalNetworkInterface != nil {
		{
			size, err := m.OpticalNetworkInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest_Request_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.PortId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request_Port_AdminStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_AdminStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminStatus != nil {
		{
			size, err := m.AdminStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_MacAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_MacAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MacAddress != nil {
		{
			size, err := m.MacAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_PortSpeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_PortSpeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortSpeed != nil {
		{
			size, err := m.PortSpeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_LacpRouterMac) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_LacpRouterMac) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpRouterMac != nil {
		{
			size, err := m.LacpRouterMac.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_LacpSystemPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_LacpSystemPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LacpSystemPriority != nil {
		{
			size, err := m.LacpSystemPriority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_HealthIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_HealthIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HealthIndicator != nil {
		{
			size, err := m.HealthIndicator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_AutonegStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_AutonegStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutonegStatus != nil {
		{
			size, err := m.AutonegStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_ForwardingViability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_ForwardingViability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForwardingViability != nil {
		{
			size, err := m.ForwardingViability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Port_LoopbackStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Port_LoopbackStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackStatus != nil {
		{
			size, err := m.LoopbackStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *SetRequest_Request_Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest_Request_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request_Chassis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest_Request_Chassis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_Chassis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request_OpticalNetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest_Request_OpticalNetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_OpticalNetworkInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkInterface != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.NetworkInterface))
		i--
		dAtA[i] = 0x10
	}
	if m.Module != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Module))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpticalTransceiverInfo != nil {
		{
			size, err := m.OpticalTransceiverInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChassisConfigParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpConfig != nil {
		l = m.LacpConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.NetConfig != nil {
		l = m.NetConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PowerConfig != nil {
		l = m.PowerConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.FanConfigs) > 0 {
		for _, e := range m.FanConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TuntapConfigs) > 0 {
		for _, e := range m.TuntapConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ChassisConfigParams_LacpConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpRouterMac != 0 {
		n += 1 + sovCommon(uint64(m.LacpRouterMac))
	}
	if m.LacpSystemPriority != 0 {
		n += 1 + sovCommon(uint64(m.LacpSystemPriority))
	}
	return n
}

func (m *ChassisConfigParams_NtpConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChassisConfigParams_PowerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChassisConfigParams_FanConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.SpeedPercentage != 0 {
		n += 1 + sovCommon(uint64(m.SpeedPercentage))
	}
	if m.TargetTemperatureCelsius != 0 {
		n += 1 + sovCommon(uint64(m.TargetTemperatureCelsius))
	}
	return n
}

func (m *ChassisConfigParams_TuntapConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovCommon(uint64(m.Mode))
	}
	l = len(m.Ipv4Address)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Ipv4Prefixlen != 0 {
		n += 1 + sovCommon(uint64(m.Ipv4Prefixlen))
	}
	l = len(m.Ipv6Address)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Ipv6Prefixlen != 0 {
		n += 1 + sovCommon(uint64(m.Ipv6Prefixlen))
	}
	if m.DefaultNetdev {
		n += 2
	}
	return n
}

func (m *NodeFlowParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NodeConfigParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VlanConfigs) > 0 {
		for _, e := range m.VlanConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.L2Config != nil {
		l = m.L2Config.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.QosConfig != nil {
		l = m.QosConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *NodeConfigParams_VlanConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VlanId != 0 {
		n += 1 + sovCommon(uint64(m.VlanId))
	}
	if m.BlockBroadcast {
		n += 2
	}
	if m.BlockKnownMulticast {
		n += 2
	}
	if m.BlockUnknownMulticast {
		n += 2
	}
	if m.BlockUnknownUnicast {
		n += 2
	}
	if m.DisableL2Learning {
		n += 2
	}
	return n
}

func (m *NodeConfigParams_L2Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2AgeDurationSec != 0 {
		n += 1 + sovCommon(uint64(m.L2AgeDurationSec))
	}
	return n
}

func (m *NodeConfigParams_QosConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchedulingMode != 0 {
		n += 1 + sovCommon(uint64(m.SchedulingMode))
	}
	if len(m.SchedulingConfig) > 0 {
		for _, e := range m.SchedulingConfig {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Dot1PMapping) > 0 {
		for _, e := range m.Dot1PMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.DscpMapping) > 0 {
		for _, e := range m.DscpMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TrafficClassMapping) > 0 {
		for _, e := range m.TrafficClassMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.CosqMapping) > 0 {
		for _, e := range m.CosqMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.PriorityGroupMapping) > 0 {
		for _, e := range m.PriorityGroupMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.IngressServicePoolMapping) > 0 {
		for _, e := range m.IngressServicePoolMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.EgressServicePoolMapping) > 0 {
		for _, e := range m.EgressServicePoolMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *NodeConfigParams_QosConfig_SchedulerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	if m.SchedulerWeight != 0 {
		n += 1 + sovCommon(uint64(m.SchedulerWeight))
	}
	if m.MinBandwidthPercent != 0 {
		n += 1 + sovCommon(uint64(m.MinBandwidthPercent))
	}
	if m.MaxBandwidthPercent != 0 {
		n += 1 + sovCommon(uint64(m.MaxBandwidthPercent))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_Dot1PMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dot1PPriority != 0 {
		n += 1 + sovCommon(uint64(m.Dot1PPriority))
	}
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_DscpMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DscpStart != 0 {
		n += 1 + sovCommon(uint64(m.DscpStart))
	}
	if m.DscpEnd != 0 {
		n += 1 + sovCommon(uint64(m.DscpEnd))
	}
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_TrafficClassMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	if m.TrafficClass != 0 {
		n += 1 + sovCommon(uint64(m.TrafficClass))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	if m.PgNum != 0 {
		n += 1 + sovCommon(uint64(m.PgNum))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_CosqMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPriority != 0 {
		n += 1 + sovCommon(uint64(m.InternalPriority))
	}
	if m.QNum != 0 {
		n += 1 + sovCommon(uint64(m.QNum))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PgNum != 0 {
		n += 1 + sovCommon(uint64(m.PgNum))
	}
	if m.SpNum != 0 {
		n += 1 + sovCommon(uint64(m.SpNum))
	}
	return n
}

func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QNum != 0 {
		n += 1 + sovCommon(uint64(m.QNum))
	}
	if m.SpNum != 0 {
		n += 1 + sovCommon(uint64(m.SpNum))
	}
	return n
}

func (m *PortFlowParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PortConfigParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminState != 0 {
		n += 1 + sovCommon(uint64(m.AdminState))
	}
	if m.Mtu != 0 {
		n += 1 + sovCommon(uint64(m.Mtu))
	}
	if m.Autoneg != 0 {
		n += 1 + sovCommon(uint64(m.Autoneg))
	}
	if m.HashConfig != nil {
		l = m.HashConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ModulationType != 0 {
		n += 1 + sovCommon(uint64(m.ModulationType))
	}
	if m.FecMode != 0 {
		n += 1 + sovCommon(uint64(m.FecMode))
	}
	if m.MacAddress != nil {
		l = m.MacAddress.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.LoopbackMode != 0 {
		n += 1 + sovCommon(uint64(m.LoopbackMode))
	}
	return n
}

func (m *PortConfigParams_HashConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rtag7EcmpHashSelect != 0 {
		n += 1 + sovCommon(uint64(m.Rtag7EcmpHashSelect))
	}
	if m.Rtag7LagHashSelect != 0 {
		n += 1 + sovCommon(uint64(m.Rtag7LagHashSelect))
	}
	return n
}

func (m *Chassis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Platform != 0 {
		n += 1 + sovCommon(uint64(m.Platform))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ConfigParams != nil {
		l = m.ConfigParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Slot != 0 {
		n += 1 + sovCommon(uint64(m.Slot))
	}
	if m.Index != 0 {
		n += 1 + sovCommon(uint64(m.Index))
	}
	if m.FlowParams != nil {
		l = m.FlowParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ConfigParams != nil {
		l = m.ConfigParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SingletonPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Slot != 0 {
		n += 1 + sovCommon(uint64(m.Slot))
	}
	if m.Port != 0 {
		n += 1 + sovCommon(uint64(m.Port))
	}
	if m.Channel != 0 {
		n += 1 + sovCommon(uint64(m.Channel))
	}
	if m.SpeedBps != 0 {
		n += 1 + sovCommon(uint64(m.SpeedBps))
	}
	if m.FlowParams != nil {
		l = m.FlowParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ConfigParams != nil {
		l = m.ConfigParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Node != 0 {
		n += 1 + sovCommon(uint64(m.Node))
	}
	return n
}

func (m *OpticalNetworkInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Module != 0 {
		n += 1 + sovCommon(uint64(m.Module))
	}
	if m.NetworkInterface != 0 {
		n += 1 + sovCommon(uint64(m.NetworkInterface))
	}
	if m.Frequency != 0 {
		n += 1 + sovCommon(uint64(m.Frequency))
	}
	if m.TargetOutputPower != 0 {
		n += 9
	}
	if m.OperationalMode != 0 {
		n += 1 + sovCommon(uint64(m.OperationalMode))
	}
	l = len(m.LinePort)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *TrunkPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Node != 0 {
		n += 1 + sovCommon(uint64(m.Node))
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if len(m.Members) > 0 {
		l = 0
		for _, e := range m.Members {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.FlowParams != nil {
		l = m.FlowParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ConfigParams != nil {
		l = m.ConfigParams.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *PortGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *PortGroup_PortGroupMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Weight != 0 {
		n += 1 + sovCommon(uint64(m.Weight))
	}
	return n
}

func (m *GoogleConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BcmChassisMapId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.NodeIdToKnetConfig) > 0 {
		for k, v := range m.NodeIdToKnetConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToRxConfig) > 0 {
		for k, v := range m.NodeIdToRxConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToTxConfig) > 0 {
		for k, v := range m.NodeIdToTxConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToRateLimitConfig) > 0 {
		for k, v := range m.NodeIdToRateLimitConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToBufferConfig) > 0 {
		for k, v := range m.NodeIdToBufferConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToRtag7HashConfig) > 0 {
		for k, v := range m.NodeIdToRtag7HashConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GoogleConfig_BcmKnetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KnetIntfConfigs) > 0 {
		for _, e := range m.KnetIntfConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mtu != 0 {
		n += 1 + sovCommon(uint64(m.Mtu))
	}
	if m.CpuQueue != 0 {
		n += 1 + sovCommon(uint64(m.CpuQueue))
	}
	if m.Vlan != 0 {
		n += 1 + sovCommon(uint64(m.Vlan))
	}
	if m.Purpose != 0 {
		n += 1 + sovCommon(uint64(m.Purpose))
	}
	return n
}

func (m *GoogleConfig_BcmRxConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RxPoolPktCount != 0 {
		n += 1 + sovCommon(uint64(m.RxPoolPktCount))
	}
	if m.RxPoolBytesPerPkt != 0 {
		n += 1 + sovCommon(uint64(m.RxPoolBytesPerPkt))
	}
	if m.MaxPktSizeBytes != 0 {
		n += 1 + sovCommon(uint64(m.MaxPktSizeBytes))
	}
	if m.PktsPerChain != 0 {
		n += 1 + sovCommon(uint64(m.PktsPerChain))
	}
	if m.MaxRatePps != 0 {
		n += 1 + sovCommon(uint64(m.MaxRatePps))
	}
	if m.MaxBurstPkts != 0 {
		n += 1 + sovCommon(uint64(m.MaxBurstPkts))
	}
	if m.UseInterrupt {
		n += 2
	}
	if len(m.DmaChannelConfigs) > 0 {
		for k, v := range m.DmaChannelConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chains != 0 {
		n += 1 + sovCommon(uint64(m.Chains))
	}
	if m.StripCrc {
		n += 2
	}
	if m.StripVlan {
		n += 2
	}
	if m.OversizedPacketsOk {
		n += 2
	}
	if m.NoPktParsing {
		n += 2
	}
	if len(m.CosSet) > 0 {
		l = 0
		for _, e := range m.CosSet {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *GoogleConfig_BcmTxConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GoogleConfig_BcmRateLimitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRatePps != 0 {
		n += 1 + sovCommon(uint64(m.MaxRatePps))
	}
	if m.MaxBurstPkts != 0 {
		n += 1 + sovCommon(uint64(m.MaxBurstPkts))
	}
	if len(m.PerCosRateLimitConfigs) > 0 {
		for k, v := range m.PerCosRateLimitConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRatePps != 0 {
		n += 1 + sovCommon(uint64(m.MaxRatePps))
	}
	if m.MaxBurstPkts != 0 {
		n += 1 + sovCommon(uint64(m.MaxBurstPkts))
	}
	return n
}

func (m *GoogleConfig_BcmBufferConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalHdrmLimit != 0 {
		n += 1 + sovCommon(uint64(m.GlobalHdrmLimit))
	}
	if m.PortMin != 0 {
		n += 1 + sovCommon(uint64(m.PortMin))
	}
	return n
}

func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpNum != 0 {
		n += 1 + sovCommon(uint64(m.SpNum))
	}
	if m.MaxIngressBufBytes != 0 {
		n += 1 + sovCommon(uint64(m.MaxIngressBufBytes))
	}
	if m.MaxEgressBufBytes != 0 {
		n += 1 + sovCommon(uint64(m.MaxEgressBufBytes))
	}
	return n
}

func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PgNum != 0 {
		n += 1 + sovCommon(uint64(m.PgNum))
	}
	if m.PgMin != 0 {
		n += 1 + sovCommon(uint64(m.PgMin))
	}
	if m.PgHdrmGlobalEnable != 0 {
		n += 1 + sovCommon(uint64(m.PgHdrmGlobalEnable))
	}
	if m.PgSharedLimitCell != 0 {
		n += 1 + sovCommon(uint64(m.PgSharedLimitCell))
	}
	if m.PgSharedDynamic != 0 {
		n += 1 + sovCommon(uint64(m.PgSharedDynamic))
	}
	return n
}

func (m *GoogleConfig_BcmBufferConfig_CosqConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QNum != 0 {
		n += 1 + sovCommon(uint64(m.QNum))
	}
	if m.QMin != 0 {
		n += 1 + sovCommon(uint64(m.QMin))
	}
	if m.QLimitEnable != 0 {
		n += 1 + sovCommon(uint64(m.QLimitEnable))
	}
	if m.QLimitDynamic != 0 {
		n += 1 + sovCommon(uint64(m.QLimitDynamic))
	}
	if m.QSharedLimitCell != 0 {
		n += 1 + sovCommon(uint64(m.QSharedLimitCell))
	}
	if m.QSharedAlphaCell != 0 {
		n += 1 + sovCommon(uint64(m.QSharedAlphaCell))
	}
	if m.QColorLimitDynamicCell != 0 {
		n += 1 + sovCommon(uint64(m.QColorLimitDynamicCell))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.HashFunctionConfigs) > 0 {
		for _, e := range m.HashFunctionConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.MacroFlowHashConfig != nil {
		l = m.MacroFlowHashConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.EcmpHashConfig != nil {
		l = m.EcmpHashConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.LagHashConfig != nil {
		l = m.LagHashConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != 0 {
		n += 1 + sovCommon(uint64(m.Block))
	}
	if m.Seed != 0 {
		n += 1 + sovCommon(uint64(m.Seed))
	}
	if len(m.Fields) > 0 {
		l = 0
		for _, e := range m.Fields {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.Polynomial_0 != 0 {
		n += 1 + sovCommon(uint64(m.Polynomial_0))
	}
	if m.Polynomial_1 != 0 {
		n += 1 + sovCommon(uint64(m.Polynomial_1))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Polynomial != 0 {
		n += 1 + sovCommon(uint64(m.Polynomial))
	}
	if len(m.TableConfigs) > 0 {
		for _, e := range m.TableConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.UseMsb_16Bits {
		n += 2
	}
	if m.RandomizeTable {
		n += 2
	}
	if m.RandomIterations != 0 {
		n += 1 + sovCommon(uint64(m.RandomIterations))
	}
	if m.Seed != 0 {
		n += 1 + sovCommon(uint64(m.Seed))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubBlock != 0 {
		n += 1 + sovCommon(uint64(m.SubBlock))
	}
	if m.IndexStart != 0 {
		n += 1 + sovCommon(uint64(m.IndexStart))
	}
	if m.IndexEnd != 0 {
		n += 1 + sovCommon(uint64(m.IndexEnd))
	}
	if m.Offset != 0 {
		n += 1 + sovCommon(uint64(m.Offset))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != 0 {
		n += 1 + sovCommon(uint64(m.Block))
	}
	if m.TableConfig_0 != nil {
		l = m.TableConfig_0.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.TableConfig_1 != nil {
		l = m.TableConfig_1.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PortHashSelect != 0 {
		n += 1 + sovCommon(uint64(m.PortHashSelect))
	}
	return n
}

func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovCommon(uint64(m.Offset))
	}
	if m.UseMacroFlowHash {
		n += 2
	}
	return n
}

func (m *TofinoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeIdToPortShapingConfig) > 0 {
		for k, v := range m.NodeIdToPortShapingConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToDeflectOnDropConfigs) > 0 {
		for k, v := range m.NodeIdToDeflectOnDropConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.NodeIdToQosConfig) > 0 {
		for k, v := range m.NodeIdToQosConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TofinoConfig_PacketShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RatePps != 0 {
		n += 1 + sovCommon(uint64(m.RatePps))
	}
	if m.BurstPackets != 0 {
		n += 1 + sovCommon(uint64(m.BurstPackets))
	}
	return n
}

func (m *TofinoConfig_ByteShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RateBps != 0 {
		n += 1 + sovCommon(uint64(m.RateBps))
	}
	if m.BurstBytes != 0 {
		n += 1 + sovCommon(uint64(m.BurstBytes))
	}
	return n
}

func (m *TofinoConfig_BfPortShapingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PerPortShapingConfigs) > 0 {
		for k, v := range m.PerPortShapingConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shaping != nil {
		n += m.Shaping.Size()
	}
	return n
}

func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketShaping != nil {
		l = m.PacketShaping.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteShaping != nil {
		l = m.ByteShaping.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DropTargets) > 0 {
		for _, e := range m.DropTargets {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortType != nil {
		n += m.PortType.Size()
	}
	if m.Queue != 0 {
		n += 1 + sovCommon(uint64(m.Queue))
	}
	return n
}

func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.Port))
	return n
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.SdkPort))
	return n
}
func (m *TofinoConfig_TofinoQosConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PoolConfigs) > 0 {
		for _, e := range m.PoolConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.PoolColorDropHysteresisGreen != 0 {
		n += 1 + sovCommon(uint64(m.PoolColorDropHysteresisGreen))
	}
	if m.PoolColorDropHysteresisYellow != 0 {
		n += 1 + sovCommon(uint64(m.PoolColorDropHysteresisYellow))
	}
	if m.PoolColorDropHysteresisRed != 0 {
		n += 1 + sovCommon(uint64(m.PoolColorDropHysteresisRed))
	}
	if len(m.PpgConfigs) > 0 {
		for _, e := range m.PpgConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.QueueConfigs) > 0 {
		for _, e := range m.QueueConfigs {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *TofinoConfig_TofinoQosConfig_PoolConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pool != 0 {
		n += 1 + sovCommon(uint64(m.Pool))
	}
	if m.PoolSize != 0 {
		n += 1 + sovCommon(uint64(m.PoolSize))
	}
	if m.EnableColorDrop {
		n += 2
	}
	if m.ColorDropLimitGreen != 0 {
		n += 1 + sovCommon(uint64(m.ColorDropLimitGreen))
	}
	if m.ColorDropLimitYellow != 0 {
		n += 1 + sovCommon(uint64(m.ColorDropLimitYellow))
	}
	if m.ColorDropLimitRed != 0 {
		n += 1 + sovCommon(uint64(m.ColorDropLimitRed))
	}
	return n
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortType != nil {
		n += m.PortType.Size()
	}
	if m.MinimumGuaranteedCells != 0 {
		n += 1 + sovCommon(uint64(m.MinimumGuaranteedCells))
	}
	if m.Pool != 0 {
		n += 1 + sovCommon(uint64(m.Pool))
	}
	if m.BaseUseLimit != 0 {
		n += 1 + sovCommon(uint64(m.BaseUseLimit))
	}
	if m.Baf != 0 {
		n += 1 + sovCommon(uint64(m.Baf))
	}
	if m.Hysteresis != 0 {
		n += 1 + sovCommon(uint64(m.Hysteresis))
	}
	if m.IngressDropLimit != 0 {
		n += 1 + sovCommon(uint64(m.IngressDropLimit))
	}
	if m.IcosBitmap != 0 {
		n += 1 + sovCommon(uint64(m.IcosBitmap))
	}
	if m.IsDefaultPpg {
		n += 2
	}
	return n
}

func (m *TofinoConfig_TofinoQosConfig_PpgConfig_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.Port))
	return n
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.SdkPort))
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortType != nil {
		n += m.PortType.Size()
	}
	if len(m.QueueMapping) > 0 {
		for _, e := range m.QueueMapping {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.Port))
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCommon(uint64(m.SdkPort))
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueId != 0 {
		n += 1 + sovCommon(uint64(m.QueueId))
	}
	if m.Priority != 0 {
		n += 1 + sovCommon(uint64(m.Priority))
	}
	if m.Weight != 0 {
		n += 1 + sovCommon(uint64(m.Weight))
	}
	if m.MinimumGuaranteedCells != 0 {
		n += 1 + sovCommon(uint64(m.MinimumGuaranteedCells))
	}
	if m.Pool != 0 {
		n += 1 + sovCommon(uint64(m.Pool))
	}
	if m.BaseUseLimit != 0 {
		n += 1 + sovCommon(uint64(m.BaseUseLimit))
	}
	if m.Baf != 0 {
		n += 1 + sovCommon(uint64(m.Baf))
	}
	if m.Hysteresis != 0 {
		n += 1 + sovCommon(uint64(m.Hysteresis))
	}
	if m.MaxRate != nil {
		n += m.MaxRate.Size()
	}
	if m.MinRate != nil {
		n += m.MinRate.Size()
	}
	if m.EnableColorDrop {
		n += 2
	}
	if m.ColorDropLimitYellow != 0 {
		n += 1 + sovCommon(uint64(m.ColorDropLimitYellow))
	}
	if m.ColorDropLimitRed != 0 {
		n += 1 + sovCommon(uint64(m.ColorDropLimitRed))
	}
	return n
}

func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRatePackets != nil {
		l = m.MaxRatePackets.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRateBytes != nil {
		l = m.MaxRateBytes.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinRatePackets != nil {
		l = m.MinRatePackets.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinRateBytes != nil {
		l = m.MinRateBytes.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *VendorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GoogleConfig != nil {
		l = m.GoogleConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.TofinoConfig != nil {
		l = m.TofinoConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ChassisConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Chassis != nil {
		l = m.Chassis.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.SingletonPorts) > 0 {
		for _, e := range m.SingletonPorts {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TrunkPorts) > 0 {
		for _, e := range m.TrunkPorts {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.PortGroups) > 0 {
		for _, e := range m.PortGroups {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.VendorConfig != nil {
		l = m.VendorConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.OpticalNetworkInterfaces) > 0 {
		for _, e := range m.OpticalNetworkInterfaces {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *SfpModuleCaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F_100 {
		n += 2
	}
	if m.F_1G {
		n += 2
	}
	if m.F_10G {
		n += 2
	}
	if m.F_40G {
		n += 2
	}
	if m.F_100G {
		n += 2
	}
	return n
}

func (m *FanCaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetDir {
		n += 2
	}
	if m.GetDir {
		n += 2
	}
	if m.SetRpm {
		n += 2
	}
	if m.SetPercentage {
		n += 2
	}
	if m.GetRpm {
		n += 2
	}
	if m.GetPercentage {
		n += 2
	}
	return n
}

func (m *PsuCaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetType {
		n += 2
	}
	if m.GetVin {
		n += 2
	}
	if m.GetVout {
		n += 2
	}
	if m.GetIin {
		n += 2
	}
	if m.GetIout {
		n += 2
	}
	if m.GetPin {
		n += 2
	}
	if m.GetPout {
		n += 2
	}
	return n
}

func (m *ThermalCaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetTemperature {
		n += 2
	}
	if m.GetWarningThreshold {
		n += 2
	}
	if m.GetErrorThreshold {
		n += 2
	}
	if m.GetShutdownThreshold {
		n += 2
	}
	return n
}

func (m *LedCaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Off {
		n += 2
	}
	if m.Auto {
		n += 2
	}
	if m.AutoBlinking {
		n += 2
	}
	if m.Char {
		n += 2
	}
	if m.Red {
		n += 2
	}
	if m.RedBlinking {
		n += 2
	}
	if m.Orange {
		n += 2
	}
	if m.OrangeBlinking {
		n += 2
	}
	if m.Yellow {
		n += 2
	}
	if m.YellowBlinking {
		n += 2
	}
	if m.Green {
		n += 2
	}
	if m.GreenBlinking {
		n += 2
	}
	if m.Blue {
		n += 2
	}
	if m.BlueBlinking {
		n += 2
	}
	if m.Purple {
		n += 2
	}
	if m.PurpleBlinking {
		n += 3
	}
	return n
}

func (m *FrontPanelPortInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPortType != 0 {
		n += 1 + sovCommon(uint64(m.PhysicalPortType))
	}
	if m.MediaType != 0 {
		n += 1 + sovCommon(uint64(m.MediaType))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.PartNumber)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.HwState != 0 {
		n += 1 + sovCommon(uint64(m.HwState))
	}
	return n
}

func (m *OpticalTransceiverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Frequency != 0 {
		n += 1 + sovCommon(uint64(m.Frequency))
	}
	if m.InputPower != nil {
		l = m.InputPower.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.OutputPower != nil {
		l = m.OutputPower.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.TargetOutputPower != 0 {
		n += 9
	}
	if m.OperationalMode != 0 {
		n += 1 + sovCommon(uint64(m.OperationalMode))
	}
	return n
}

func (m *OpticalTransceiverInfo_Power) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instant != 0 {
		n += 9
	}
	if m.Avg != 0 {
		n += 9
	}
	if m.Interval != 0 {
		n += 1 + sovCommon(uint64(m.Interval))
	}
	if m.Max != 0 {
		n += 9
	}
	if m.MaxTime != 0 {
		n += 1 + sovCommon(uint64(m.MaxTime))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.MinTime != 0 {
		n += 1 + sovCommon(uint64(m.MinTime))
	}
	return n
}

func (m *OperStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	if m.TimeLastChanged != 0 {
		n += 1 + sovCommon(uint64(m.TimeLastChanged))
	}
	return n
}

func (m *LoopbackStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	return n
}

func (m *AdminStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	return n
}

func (m *MacAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddress != 0 {
		n += 1 + sovCommon(uint64(m.MacAddress))
	}
	return n
}

func (m *PortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpeedBps != 0 {
		n += 1 + sovCommon(uint64(m.SpeedBps))
	}
	return n
}

func (m *SystemPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovCommon(uint64(m.Priority))
	}
	return n
}

func (m *PortCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InOctets != 0 {
		n += 1 + sovCommon(uint64(m.InOctets))
	}
	if m.InUnicastPkts != 0 {
		n += 1 + sovCommon(uint64(m.InUnicastPkts))
	}
	if m.InBroadcastPkts != 0 {
		n += 1 + sovCommon(uint64(m.InBroadcastPkts))
	}
	if m.InMulticastPkts != 0 {
		n += 1 + sovCommon(uint64(m.InMulticastPkts))
	}
	if m.InDiscards != 0 {
		n += 1 + sovCommon(uint64(m.InDiscards))
	}
	if m.InErrors != 0 {
		n += 1 + sovCommon(uint64(m.InErrors))
	}
	if m.InUnknownProtos != 0 {
		n += 1 + sovCommon(uint64(m.InUnknownProtos))
	}
	if m.OutOctets != 0 {
		n += 1 + sovCommon(uint64(m.OutOctets))
	}
	if m.OutUnicastPkts != 0 {
		n += 1 + sovCommon(uint64(m.OutUnicastPkts))
	}
	if m.OutBroadcastPkts != 0 {
		n += 1 + sovCommon(uint64(m.OutBroadcastPkts))
	}
	if m.OutMulticastPkts != 0 {
		n += 1 + sovCommon(uint64(m.OutMulticastPkts))
	}
	if m.OutDiscards != 0 {
		n += 1 + sovCommon(uint64(m.OutDiscards))
	}
	if m.OutErrors != 0 {
		n += 1 + sovCommon(uint64(m.OutErrors))
	}
	if m.InFcsErrors != 0 {
		n += 1 + sovCommon(uint64(m.InFcsErrors))
	}
	return n
}

func (m *PortQosCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueId != 0 {
		n += 1 + sovCommon(uint64(m.QueueId))
	}
	if m.OutOctets != 0 {
		n += 1 + sovCommon(uint64(m.OutOctets))
	}
	if m.OutPkts != 0 {
		n += 1 + sovCommon(uint64(m.OutPkts))
	}
	if m.OutDroppedPkts != 0 {
		n += 1 + sovCommon(uint64(m.OutDroppedPkts))
	}
	return n
}

func (m *Alarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeCreated != 0 {
		n += 1 + sovCommon(uint64(m.TimeCreated))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovCommon(uint64(m.Severity))
	}
	if m.Status {
		n += 2
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VendorName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ChipName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *NodeDebugInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DebugString)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ForwardingViability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	return n
}

func (m *HealthIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	return n
}

func (m *AutonegotiationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	return n
}

func (m *FecStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovCommon(uint64(m.Mode))
	}
	return n
}

func (m *SdnPortId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortId != 0 {
		n += 1 + sovCommon(uint64(m.PortId))
	}
	return n
}

func (m *DataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *DataRequest_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *DataRequest_Request_OperStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperStatus != nil {
		l = m.OperStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_AdminStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminStatus != nil {
		l = m.AdminStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_MacAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddress != nil {
		l = m.MacAddress.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_PortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortSpeed != nil {
		l = m.PortSpeed.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_NegotiatedPortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NegotiatedPortSpeed != nil {
		l = m.NegotiatedPortSpeed.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_LacpRouterMac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpRouterMac != nil {
		l = m.LacpRouterMac.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_LacpSystemPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpSystemPriority != nil {
		l = m.LacpSystemPriority.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_PortCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortCounters != nil {
		l = m.PortCounters.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_MemoryErrorAlarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryErrorAlarm != nil {
		l = m.MemoryErrorAlarm.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_FlowProgrammingExceptionAlarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowProgrammingExceptionAlarm != nil {
		l = m.FlowProgrammingExceptionAlarm.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_PortQosCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortQosCounters != nil {
		l = m.PortQosCounters.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_NodePacketioDebugInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodePacketioDebugInfo != nil {
		l = m.NodePacketioDebugInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_ForwardingViability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwardingViability != nil {
		l = m.ForwardingViability.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_HealthIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthIndicator != nil {
		l = m.HealthIndicator.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_AutonegStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutonegStatus != nil {
		l = m.AutonegStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_FrontPanelPortInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FrontPanelPortInfo != nil {
		l = m.FrontPanelPortInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_FecStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FecStatus != nil {
		l = m.FecStatus.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_OpticalTransceiverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpticalTransceiverInfo != nil {
		l = m.OpticalTransceiverInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_LoopbackStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackStatus != nil {
		l = m.LoopbackStatus.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_SdnPortId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SdnPortId != nil {
		l = m.SdnPortId.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataRequest_Request_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovCommon(uint64(m.NodeId))
	}
	if m.PortId != 0 {
		n += 1 + sovCommon(uint64(m.PortId))
	}
	return n
}

func (m *DataRequest_Request_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovCommon(uint64(m.NodeId))
	}
	return n
}

func (m *DataRequest_Request_Chassis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DataRequest_Request_PortQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovCommon(uint64(m.NodeId))
	}
	if m.PortId != 0 {
		n += 1 + sovCommon(uint64(m.PortId))
	}
	if m.QueueId != 0 {
		n += 1 + sovCommon(uint64(m.QueueId))
	}
	return n
}

func (m *DataRequest_Request_OpticalNetworkInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Module != 0 {
		n += 1 + sovCommon(uint64(m.Module))
	}
	if m.NetworkInterface != 0 {
		n += 1 + sovCommon(uint64(m.NetworkInterface))
	}
	return n
}

func (m *DataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *DataResponse_OperStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperStatus != nil {
		l = m.OperStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_AdminStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminStatus != nil {
		l = m.AdminStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_MacAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddress != nil {
		l = m.MacAddress.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_PortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortSpeed != nil {
		l = m.PortSpeed.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_NegotiatedPortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NegotiatedPortSpeed != nil {
		l = m.NegotiatedPortSpeed.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_LacpRouterMac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpRouterMac != nil {
		l = m.LacpRouterMac.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_LacpSystemPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpSystemPriority != nil {
		l = m.LacpSystemPriority.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_PortCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortCounters != nil {
		l = m.PortCounters.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_MemoryErrorAlarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryErrorAlarm != nil {
		l = m.MemoryErrorAlarm.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_FlowProgrammingExceptionAlarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowProgrammingExceptionAlarm != nil {
		l = m.FlowProgrammingExceptionAlarm.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_PortQosCounters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortQosCounters != nil {
		l = m.PortQosCounters.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_NodePacketioDebugInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodePacketioDebugInfo != nil {
		l = m.NodePacketioDebugInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_ForwardingViability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwardingViability != nil {
		l = m.ForwardingViability.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_HealthIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthIndicator != nil {
		l = m.HealthIndicator.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_AutonegStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutonegStatus != nil {
		l = m.AutonegStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_FrontPanelPortInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FrontPanelPortInfo != nil {
		l = m.FrontPanelPortInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_FecStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FecStatus != nil {
		l = m.FecStatus.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_OpticalTransceiverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpticalTransceiverInfo != nil {
		l = m.OpticalTransceiverInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_LoopbackStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackStatus != nil {
		l = m.LoopbackStatus.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *DataResponse_SdnPortId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SdnPortId != nil {
		l = m.SdnPortId.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *SetRequest_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *SetRequest_Request_Port_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Node_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Chassis_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chassis != nil {
		l = m.Chassis.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_OpticalNetworkInterface_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpticalNetworkInterface != nil {
		l = m.OpticalNetworkInterface.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovCommon(uint64(m.NodeId))
	}
	if m.PortId != 0 {
		n += 1 + sovCommon(uint64(m.PortId))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *SetRequest_Request_Port_AdminStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminStatus != nil {
		l = m.AdminStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_MacAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddress != nil {
		l = m.MacAddress.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_PortSpeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortSpeed != nil {
		l = m.PortSpeed.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_LacpRouterMac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpRouterMac != nil {
		l = m.LacpRouterMac.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_LacpSystemPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LacpSystemPriority != nil {
		l = m.LacpSystemPriority.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_HealthIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthIndicator != nil {
		l = m.HealthIndicator.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_AutonegStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutonegStatus != nil {
		l = m.AutonegStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_ForwardingViability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwardingViability != nil {
		l = m.ForwardingViability.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Port_LoopbackStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackStatus != nil {
		l = m.LoopbackStatus.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}
func (m *SetRequest_Request_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetRequest_Request_Chassis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetRequest_Request_OpticalNetworkInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Module != 0 {
		n += 1 + sovCommon(uint64(m.Module))
	}
	if m.NetworkInterface != 0 {
		n += 1 + sovCommon(uint64(m.NetworkInterface))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpticalTransceiverInfo != nil {
		l = m.OpticalTransceiverInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChassisConfigParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChassisConfigParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChassisConfigParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LacpConfig == nil {
				m.LacpConfig = &ChassisConfigParams_LacpConfig{}
			}
			if err := m.LacpConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetConfig == nil {
				m.NetConfig = &ChassisConfigParams_NtpConfig{}
			}
			if err := m.NetConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerConfig == nil {
				m.PowerConfig = &ChassisConfigParams_PowerConfig{}
			}
			if err := m.PowerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FanConfigs = append(m.FanConfigs, &ChassisConfigParams_FanConfig{})
			if err := m.FanConfigs[len(m.FanConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TuntapConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TuntapConfigs = append(m.TuntapConfigs, &ChassisConfigParams_TuntapConfig{})
			if err := m.TuntapConfigs[len(m.TuntapConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfigParams_LacpConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LacpConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LacpConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpRouterMac", wireType)
			}
			m.LacpRouterMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LacpRouterMac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpSystemPriority", wireType)
			}
			m.LacpSystemPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LacpSystemPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfigParams_NtpConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtpConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtpConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfigParams_PowerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PowerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PowerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfigParams_FanConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FanConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FanConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedPercentage", wireType)
			}
			m.SpeedPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedPercentage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTemperatureCelsius", wireType)
			}
			m.TargetTemperatureCelsius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetTemperatureCelsius |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfigParams_TuntapConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TuntapConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TuntapConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ChassisConfigParams_TuntapConfig_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Prefixlen", wireType)
			}
			m.Ipv4Prefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ipv4Prefixlen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Prefixlen", wireType)
			}
			m.Ipv6Prefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ipv6Prefixlen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNetdev", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultNetdev = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeFlowParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeFlowParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeFlowParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeConfigParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeConfigParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VlanConfigs = append(m.VlanConfigs, &NodeConfigParams_VlanConfig{})
			if err := m.VlanConfigs[len(m.VlanConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2Config == nil {
				m.L2Config = &NodeConfigParams_L2Config{}
			}
			if err := m.L2Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QosConfig == nil {
				m.QosConfig = &NodeConfigParams_QosConfig{}
			}
			if err := m.QosConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_VlanConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VlanConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VlanConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			m.VlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockBroadcast = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockKnownMulticast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockKnownMulticast = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockUnknownMulticast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockUnknownMulticast = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockUnknownUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockUnknownUnicast = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableL2Learning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableL2Learning = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_L2Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2AgeDurationSec", wireType)
			}
			m.L2AgeDurationSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2AgeDurationSec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingMode", wireType)
			}
			m.SchedulingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedulingMode |= NodeConfigParams_QosConfig_SchedulingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedulingConfig = append(m.SchedulingConfig, &NodeConfigParams_QosConfig_SchedulerConfig{})
			if err := m.SchedulingConfig[len(m.SchedulingConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1PMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dot1PMapping = append(m.Dot1PMapping, &NodeConfigParams_QosConfig_Dot1PMapping{})
			if err := m.Dot1PMapping[len(m.Dot1PMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DscpMapping = append(m.DscpMapping, &NodeConfigParams_QosConfig_DscpMapping{})
			if err := m.DscpMapping[len(m.DscpMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClassMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficClassMapping = append(m.TrafficClassMapping, &NodeConfigParams_QosConfig_TrafficClassMapping{})
			if err := m.TrafficClassMapping[len(m.TrafficClassMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosqMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosqMapping = append(m.CosqMapping, &NodeConfigParams_QosConfig_CosqMapping{})
			if err := m.CosqMapping[len(m.CosqMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityGroupMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityGroupMapping = append(m.PriorityGroupMapping, &NodeConfigParams_QosConfig_PriorityGroupMapping{})
			if err := m.PriorityGroupMapping[len(m.PriorityGroupMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressServicePoolMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressServicePoolMapping = append(m.IngressServicePoolMapping, &NodeConfigParams_QosConfig_IngressServicePoolMapping{})
			if err := m.IngressServicePoolMapping[len(m.IngressServicePoolMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressServicePoolMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressServicePoolMapping = append(m.EgressServicePoolMapping, &NodeConfigParams_QosConfig_EgressServicePoolMapping{})
			if err := m.EgressServicePoolMapping[len(m.EgressServicePoolMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_SchedulerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulerWeight", wireType)
			}
			m.SchedulerWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedulerWeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBandwidthPercent", wireType)
			}
			m.MinBandwidthPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBandwidthPercent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBandwidthPercent", wireType)
			}
			m.MaxBandwidthPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBandwidthPercent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_Dot1PMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot1pMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot1pMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1PPriority", wireType)
			}
			m.Dot1PPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1PPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_DscpMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DscpMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DscpMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpStart", wireType)
			}
			m.DscpStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DscpStart |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpEnd", wireType)
			}
			m.DscpEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DscpEnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_TrafficClassMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficClassMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficClassMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= TrafficClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_PriorityGroupMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriorityGroupMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriorityGroupMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgNum", wireType)
			}
			m.PgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_CosqMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosqMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosqMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPriority", wireType)
			}
			m.InternalPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QNum", wireType)
			}
			m.QNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_IngressServicePoolMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressServicePoolMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressServicePoolMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgNum", wireType)
			}
			m.PgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpNum", wireType)
			}
			m.SpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfigParams_QosConfig_EgressServicePoolMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressServicePoolMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressServicePoolMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QNum", wireType)
			}
			m.QNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpNum", wireType)
			}
			m.SpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortFlowParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortFlowParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortFlowParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortConfigParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortConfigParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortConfigParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			m.AdminState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminState |= AdminState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoneg", wireType)
			}
			m.Autoneg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Autoneg |= TriState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashConfig == nil {
				m.HashConfig = &PortConfigParams_HashConfig{}
			}
			if err := m.HashConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModulationType", wireType)
			}
			m.ModulationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModulationType |= PortConfigParams_ModulationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecMode", wireType)
			}
			m.FecMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FecMode |= FecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacAddress == nil {
				m.MacAddress = &MacAddress{}
			}
			if err := m.MacAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackMode", wireType)
			}
			m.LoopbackMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopbackMode |= LoopbackState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortConfigParams_HashConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtag7EcmpHashSelect", wireType)
			}
			m.Rtag7EcmpHashSelect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtag7EcmpHashSelect |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtag7LagHashSelect", wireType)
			}
			m.Rtag7LagHashSelect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtag7LagHashSelect |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chassis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chassis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chassis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			m.Platform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platform |= Platform(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigParams == nil {
				m.ConfigParams = &ChassisConfigParams{}
			}
			if err := m.ConfigParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowParams == nil {
				m.FlowParams = &NodeFlowParams{}
			}
			if err := m.FlowParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigParams == nil {
				m.ConfigParams = &NodeConfigParams{}
			}
			if err := m.ConfigParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingletonPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingletonPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingletonPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedBps", wireType)
			}
			m.SpeedBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowParams == nil {
				m.FlowParams = &PortFlowParams{}
			}
			if err := m.FlowParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigParams == nil {
				m.ConfigParams = &PortConfigParams{}
			}
			if err := m.ConfigParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticalNetworkInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticalNetworkInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticalNetworkInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			m.Module = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Module |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			m.NetworkInterface = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkInterface |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetOutputPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TargetOutputPower = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationalMode", wireType)
			}
			m.OperationalMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationalMode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrunkPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrunkPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrunkPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TrunkPort_TrunkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Members = append(m.Members, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Members) == 0 {
					m.Members = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Members = append(m.Members, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowParams == nil {
				m.FlowParams = &PortFlowParams{}
			}
			if err := m.FlowParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigParams == nil {
				m.ConfigParams = &PortConfigParams{}
			}
			if err := m.ConfigParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &PortGroup_PortGroupMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortGroup_PortGroupMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortGroupMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortGroupMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoogleConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoogleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcmChassisMapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcmChassisMapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToKnetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToKnetConfig == nil {
				m.NodeIdToKnetConfig = make(map[uint64]*GoogleConfig_BcmKnetConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmKnetConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmKnetConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToKnetConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToRxConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToRxConfig == nil {
				m.NodeIdToRxConfig = make(map[uint64]*GoogleConfig_BcmRxConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmRxConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmRxConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToRxConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToTxConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToTxConfig == nil {
				m.NodeIdToTxConfig = make(map[uint64]*GoogleConfig_BcmTxConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmTxConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmTxConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToTxConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToRateLimitConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToRateLimitConfig == nil {
				m.NodeIdToRateLimitConfig = make(map[uint64]*GoogleConfig_BcmRateLimitConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmRateLimitConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmRateLimitConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToRateLimitConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToBufferConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToBufferConfig == nil {
				m.NodeIdToBufferConfig = make(map[uint64]*GoogleConfig_BcmBufferConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmBufferConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmBufferConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToBufferConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToRtag7HashConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToRtag7HashConfig == nil {
				m.NodeIdToRtag7HashConfig = make(map[uint64]*GoogleConfig_BcmRtag7HashConfig)
			}
			var mapkey uint64
			var mapvalue *GoogleConfig_BcmRtag7HashConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmRtag7HashConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToRtag7HashConfig[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmKnetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmKnetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmKnetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnetIntfConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KnetIntfConfigs = append(m.KnetIntfConfigs, &GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig{})
			if err := m.KnetIntfConfigs[len(m.KnetIntfConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmKnetConfig_BcmKnetIntfConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmKnetIntfConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmKnetIntfConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQueue", wireType)
			}
			m.CpuQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuQueue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			m.Purpose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Purpose |= GoogleConfig_BcmKnetIntfPurpose(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRxConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmRxConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmRxConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPoolPktCount", wireType)
			}
			m.RxPoolPktCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPoolPktCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPoolBytesPerPkt", wireType)
			}
			m.RxPoolBytesPerPkt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPoolBytesPerPkt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPktSizeBytes", wireType)
			}
			m.MaxPktSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPktSizeBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsPerChain", wireType)
			}
			m.PktsPerChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsPerChain |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRatePps", wireType)
			}
			m.MaxRatePps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRatePps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurstPkts", wireType)
			}
			m.MaxBurstPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBurstPkts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseInterrupt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseInterrupt = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmaChannelConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DmaChannelConfigs == nil {
				m.DmaChannelConfigs = make(map[int32]*GoogleConfig_BcmRxConfig_BcmDmaChannelConfig)
			}
			var mapkey int32
			var mapvalue *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmRxConfig_BcmDmaChannelConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DmaChannelConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRxConfig_BcmDmaChannelConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmDmaChannelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmDmaChannelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			m.Chains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chains |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripCrc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripCrc = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripVlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripVlan = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OversizedPacketsOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OversizedPacketsOk = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPktParsing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoPktParsing = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CosSet = append(m.CosSet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CosSet) == 0 {
					m.CosSet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CosSet = append(m.CosSet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CosSet", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmTxConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmTxConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmTxConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRateLimitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmRateLimitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmRateLimitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRatePps", wireType)
			}
			m.MaxRatePps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRatePps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurstPkts", wireType)
			}
			m.MaxBurstPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBurstPkts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerCosRateLimitConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerCosRateLimitConfigs == nil {
				m.PerCosRateLimitConfigs = make(map[int32]*GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig)
			}
			var mapkey int32
			var mapvalue *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PerCosRateLimitConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRateLimitConfig_BcmPerCosRateLimitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmPerCosRateLimitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmPerCosRateLimitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRatePps", wireType)
			}
			m.MaxRatePps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRatePps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurstPkts", wireType)
			}
			m.MaxBurstPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBurstPkts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmBufferConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmBufferConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmBufferConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalHdrmLimit", wireType)
			}
			m.GlobalHdrmLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalHdrmLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMin", wireType)
			}
			m.PortMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmBufferConfig_ServicePoolConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePoolConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePoolConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpNum", wireType)
			}
			m.SpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIngressBufBytes", wireType)
			}
			m.MaxIngressBufBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxIngressBufBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEgressBufBytes", wireType)
			}
			m.MaxEgressBufBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEgressBufBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmBufferConfig_PriorityGroupConig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriorityGroupConig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriorityGroupConig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgNum", wireType)
			}
			m.PgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgMin", wireType)
			}
			m.PgMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgHdrmGlobalEnable", wireType)
			}
			m.PgHdrmGlobalEnable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgHdrmGlobalEnable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgSharedLimitCell", wireType)
			}
			m.PgSharedLimitCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgSharedLimitCell |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgSharedDynamic", wireType)
			}
			m.PgSharedDynamic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgSharedDynamic |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmBufferConfig_CosqConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosqConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosqConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QNum", wireType)
			}
			m.QNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QMin", wireType)
			}
			m.QMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QLimitEnable", wireType)
			}
			m.QLimitEnable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QLimitEnable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QLimitDynamic", wireType)
			}
			m.QLimitDynamic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QLimitDynamic |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QSharedLimitCell", wireType)
			}
			m.QSharedLimitCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QSharedLimitCell |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QSharedAlphaCell", wireType)
			}
			m.QSharedAlphaCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QSharedAlphaCell |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QColorLimitDynamicCell", wireType)
			}
			m.QColorLimitDynamicCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QColorLimitDynamicCell |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BcmRtag7HashConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BcmRtag7HashConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashFunctionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashFunctionConfigs = append(m.HashFunctionConfigs, &GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig{})
			if err := m.HashFunctionConfigs[len(m.HashFunctionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacroFlowHashConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacroFlowHashConfig == nil {
				m.MacroFlowHashConfig = &GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig{}
			}
			if err := m.MacroFlowHashConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpHashConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcmpHashConfig == nil {
				m.EcmpHashConfig = &GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig{}
			}
			if err := m.EcmpHashConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LagHashConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LagHashConfig == nil {
				m.LagHashConfig = &GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig{}
			}
			if err := m.LagHashConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig_HashFunctionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashFunctionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashFunctionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Block |= GoogleConfig_BcmRtag7HashConfig_HashBlock(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v GoogleConfig_BcmRtag7HashConfig_HashField
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GoogleConfig_BcmRtag7HashConfig_HashField(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fields = append(m.Fields, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Fields) == 0 {
					m.Fields = make([]GoogleConfig_BcmRtag7HashConfig_HashField, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GoogleConfig_BcmRtag7HashConfig_HashField
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GoogleConfig_BcmRtag7HashConfig_HashField(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fields = append(m.Fields, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Polynomial_0", wireType)
			}
			m.Polynomial_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Polynomial_0 |= GoogleConfig_BcmRtag7HashConfig_Polynomial(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Polynomial_1", wireType)
			}
			m.Polynomial_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Polynomial_1 |= GoogleConfig_BcmRtag7HashConfig_Polynomial(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacroFlowHashConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacroFlowHashConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Polynomial", wireType)
			}
			m.Polynomial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Polynomial |= GoogleConfig_BcmRtag7HashConfig_Polynomial(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableConfigs = append(m.TableConfigs, &GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig{})
			if err := m.TableConfigs[len(m.TableConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMsb_16Bits", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMsb_16Bits = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomizeTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomizeTable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomIterations", wireType)
			}
			m.RandomIterations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomIterations |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig_MacroFlowHashConfig_TableConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubBlock", wireType)
			}
			m.SubBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubBlock |= GoogleConfig_BcmRtag7HashConfig_HashSubBlock(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexStart", wireType)
			}
			m.IndexStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexEnd", wireType)
			}
			m.IndexEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerTypeHashConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerTypeHashConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Block |= GoogleConfig_BcmRtag7HashConfig_HashBlock(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableConfig_0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableConfig_0 == nil {
				m.TableConfig_0 = &GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig{}
			}
			if err := m.TableConfig_0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableConfig_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableConfig_1 == nil {
				m.TableConfig_1 = &GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig{}
			}
			if err := m.TableConfig_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortHashSelect", wireType)
			}
			m.PortHashSelect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortHashSelect |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoogleConfig_BcmRtag7HashConfig_PerTypeHashConfig_TableConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMacroFlowHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMacroFlowHash = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TofinoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TofinoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToPortShapingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToPortShapingConfig == nil {
				m.NodeIdToPortShapingConfig = make(map[uint64]*TofinoConfig_BfPortShapingConfig)
			}
			var mapkey uint64
			var mapvalue *TofinoConfig_BfPortShapingConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TofinoConfig_BfPortShapingConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToPortShapingConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToDeflectOnDropConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToDeflectOnDropConfigs == nil {
				m.NodeIdToDeflectOnDropConfigs = make(map[uint64]*TofinoConfig_DeflectOnPacketDropConfig)
			}
			var mapkey uint64
			var mapvalue *TofinoConfig_DeflectOnPacketDropConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TofinoConfig_DeflectOnPacketDropConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToDeflectOnDropConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdToQosConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeIdToQosConfig == nil {
				m.NodeIdToQosConfig = make(map[uint64]*TofinoConfig_TofinoQosConfig)
			}
			var mapkey uint64
			var mapvalue *TofinoConfig_TofinoQosConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TofinoConfig_TofinoQosConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeIdToQosConfig[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_PacketShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatePps", wireType)
			}
			m.RatePps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatePps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPackets", wireType)
			}
			m.BurstPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPackets |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_ByteShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByteShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByteShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBps", wireType)
			}
			m.RateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstBytes", wireType)
			}
			m.BurstBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_BfPortShapingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BfPortShapingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BfPortShapingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerPortShapingConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerPortShapingConfigs == nil {
				m.PerPortShapingConfigs = make(map[uint32]*TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig)
			}
			var mapkey uint32
			var mapvalue *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PerPortShapingConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BfPerPortShapingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BfPerPortShapingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketShaping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_PacketShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Shaping = &TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_PacketShaping{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteShaping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_ByteShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Shaping = &TofinoConfig_BfPortShapingConfig_BfPerPortShapingConfig_ByteShaping{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_DeflectOnPacketDropConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeflectOnPacketDropConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeflectOnPacketDropConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropTargets = append(m.DropTargets, &TofinoConfig_DeflectOnPacketDropConfig_DropTarget{})
			if err := m.DropTargets[len(m.DropTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_DeflectOnPacketDropConfig_DropTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_DeflectOnPacketDropConfig_DropTarget_Port{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_DeflectOnPacketDropConfig_DropTarget_SdkPort{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			m.Queue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Queue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TofinoQosConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TofinoQosConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolConfigs = append(m.PoolConfigs, &TofinoConfig_TofinoQosConfig_PoolConfig{})
			if err := m.PoolConfigs[len(m.PoolConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolColorDropHysteresisGreen", wireType)
			}
			m.PoolColorDropHysteresisGreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolColorDropHysteresisGreen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolColorDropHysteresisYellow", wireType)
			}
			m.PoolColorDropHysteresisYellow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolColorDropHysteresisYellow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolColorDropHysteresisRed", wireType)
			}
			m.PoolColorDropHysteresisRed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolColorDropHysteresisRed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpgConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PpgConfigs = append(m.PpgConfigs, &TofinoConfig_TofinoQosConfig_PpgConfig{})
			if err := m.PpgConfigs[len(m.PpgConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueConfigs = append(m.QueueConfigs, &TofinoConfig_TofinoQosConfig_QueueConfig{})
			if err := m.QueueConfigs[len(m.QueueConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig_PoolConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= TofinoConfig_TofinoQosConfig_ApplicationPool(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSize", wireType)
			}
			m.PoolSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableColorDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableColorDrop = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDropLimitGreen", wireType)
			}
			m.ColorDropLimitGreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorDropLimitGreen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDropLimitYellow", wireType)
			}
			m.ColorDropLimitYellow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorDropLimitYellow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDropLimitRed", wireType)
			}
			m.ColorDropLimitRed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorDropLimitRed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig_PpgConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PpgConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PpgConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_TofinoQosConfig_PpgConfig_Port{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumGuaranteedCells", wireType)
			}
			m.MinimumGuaranteedCells = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumGuaranteedCells |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= TofinoConfig_TofinoQosConfig_ApplicationPool(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUseLimit", wireType)
			}
			m.BaseUseLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseUseLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baf", wireType)
			}
			m.Baf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baf |= TofinoConfig_TofinoQosConfig_Baf(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hysteresis", wireType)
			}
			m.Hysteresis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hysteresis |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressDropLimit", wireType)
			}
			m.IngressDropLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressDropLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcosBitmap", wireType)
			}
			m.IcosBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcosBitmap |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefaultPpg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefaultPpg = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_TofinoQosConfig_PpgConfig_SdkPort{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_TofinoQosConfig_QueueConfig_Port{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortType = &TofinoConfig_TofinoQosConfig_QueueConfig_SdkPort{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueMapping = append(m.QueueMapping, &TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping{})
			if err := m.QueueMapping[len(m.QueueMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueId", wireType)
			}
			m.QueueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= TofinoConfig_TofinoQosConfig_SchedulingPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumGuaranteedCells", wireType)
			}
			m.MinimumGuaranteedCells = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumGuaranteedCells |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= TofinoConfig_TofinoQosConfig_ApplicationPool(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUseLimit", wireType)
			}
			m.BaseUseLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseUseLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baf", wireType)
			}
			m.Baf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baf |= TofinoConfig_TofinoQosConfig_Baf(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hysteresis", wireType)
			}
			m.Hysteresis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hysteresis |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRatePackets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_PacketShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MaxRate = &TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRatePackets{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRateBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_ByteShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MaxRate = &TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MaxRateBytes{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRatePackets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_PacketShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MinRate = &TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRatePackets{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRateBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TofinoConfig_ByteShape{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MinRate = &TofinoConfig_TofinoQosConfig_QueueConfig_QueueMapping_MinRateBytes{v}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableColorDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableColorDrop = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDropLimitYellow", wireType)
			}
			m.ColorDropLimitYellow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorDropLimitYellow |= TofinoConfig_TofinoQosConfig_QueueColorLimit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDropLimitRed", wireType)
			}
			m.ColorDropLimitRed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorDropLimitRed |= TofinoConfig_TofinoQosConfig_QueueColorLimit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VendorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VendorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VendorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoogleConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoogleConfig == nil {
				m.GoogleConfig = &GoogleConfig{}
			}
			if err := m.GoogleConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TofinoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TofinoConfig == nil {
				m.TofinoConfig = &TofinoConfig{}
			}
			if err := m.TofinoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChassisConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChassisConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChassisConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chassis == nil {
				m.Chassis = &Chassis{}
			}
			if err := m.Chassis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingletonPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingletonPorts = append(m.SingletonPorts, &SingletonPort{})
			if err := m.SingletonPorts[len(m.SingletonPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrunkPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrunkPorts = append(m.TrunkPorts, &TrunkPort{})
			if err := m.TrunkPorts[len(m.TrunkPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortGroups = append(m.PortGroups, &PortGroup{})
			if err := m.PortGroups[len(m.PortGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VendorConfig == nil {
				m.VendorConfig = &VendorConfig{}
			}
			if err := m.VendorConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticalNetworkInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpticalNetworkInterfaces = append(m.OpticalNetworkInterfaces, &OpticalNetworkInterface{})
			if err := m.OpticalNetworkInterfaces[len(m.OpticalNetworkInterfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SfpModuleCaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SfpModuleCaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SfpModuleCaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F_100", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F_100 = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F_1G", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F_1G = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F_10G", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F_10G = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F_40G", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F_40G = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F_100G", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.F_100G = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FanCaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FanCaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FanCaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetDir = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetDir = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetRpm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetRpm = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetPercentage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetPercentage = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetRpm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetRpm = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPercentage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetPercentage = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PsuCaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PsuCaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PsuCaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetType", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetType = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetVin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetVin = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetVout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetVout = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetIin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetIin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetIout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetIout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetPin = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetPout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThermalCaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThermalCaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThermalCaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTemperature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetTemperature = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetWarningThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetWarningThreshold = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetErrorThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetErrorThreshold = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetShutdownThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetShutdownThreshold = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedCaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedCaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedCaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Off", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Off = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Auto = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBlinking = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Char", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Char = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Red", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Red = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedBlinking = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Orange = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrangeBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrangeBlinking = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yellow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Yellow = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YellowBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.YellowBlinking = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Green", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Green = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreenBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GreenBlinking = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blue = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlueBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlueBlinking = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purple = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurpleBlinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PurpleBlinking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrontPanelPortInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrontPanelPortInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrontPanelPortInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPortType", wireType)
			}
			m.PhysicalPortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalPortType |= PhysicalPortType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= MediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwState", wireType)
			}
			m.HwState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwState |= HwState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticalTransceiverInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticalTransceiverInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticalTransceiverInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputPower == nil {
				m.InputPower = &OpticalTransceiverInfo_Power{}
			}
			if err := m.InputPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputPower == nil {
				m.OutputPower = &OpticalTransceiverInfo_Power{}
			}
			if err := m.OutputPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetOutputPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TargetOutputPower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationalMode", wireType)
			}
			m.OperationalMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationalMode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticalTransceiverInfo_Power) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Power: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Power: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instant", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Instant = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Avg = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			m.MaxTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTime", wireType)
			}
			m.MinTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PortState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLastChanged", wireType)
			}
			m.TimeLastChanged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLastChanged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= LoopbackState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AdminState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			m.MacAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpeed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpeed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpeed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedBps", wireType)
			}
			m.SpeedBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemPriority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemPriority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemPriority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCounters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCounters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCounters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOctets", wireType)
			}
			m.InOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUnicastPkts", wireType)
			}
			m.InUnicastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUnicastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBroadcastPkts", wireType)
			}
			m.InBroadcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InBroadcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InMulticastPkts", wireType)
			}
			m.InMulticastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InMulticastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDiscards", wireType)
			}
			m.InDiscards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InDiscards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InErrors", wireType)
			}
			m.InErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUnknownProtos", wireType)
			}
			m.InUnknownProtos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUnknownProtos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutOctets", wireType)
			}
			m.OutOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUnicastPkts", wireType)
			}
			m.OutUnicastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUnicastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutBroadcastPkts", wireType)
			}
			m.OutBroadcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutBroadcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMulticastPkts", wireType)
			}
			m.OutMulticastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutMulticastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDiscards", wireType)
			}
			m.OutDiscards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutDiscards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutErrors", wireType)
			}
			m.OutErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFcsErrors", wireType)
			}
			m.InFcsErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InFcsErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortQosCounters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortQosCounters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortQosCounters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueId", wireType)
			}
			m.QueueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutOctets", wireType)
			}
			m.OutOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPkts", wireType)
			}
			m.OutPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDroppedPkts", wireType)
			}
			m.OutDroppedPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutDroppedPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alarm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alarm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alarm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Alarm_Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChipName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChipName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeDebugInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeDebugInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeDebugInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardingViability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardingViability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardingViability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrunkMemberBlockState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthIndicator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthIndicator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthIndicator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= HealthState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutonegotiationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutonegotiationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutonegotiationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TriState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FecStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FecStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FecStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= FecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdnPortId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdnPortId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdnPortId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			m.PortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &DataRequest_Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_OperStatus{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_AdminStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_MacAddress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSpeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_PortSpeed{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegotiatedPortSpeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_NegotiatedPortSpeed{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpRouterMac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_LacpRouterMac{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpSystemPriority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_LacpSystemPriority{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_PortCounters{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryErrorAlarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Chassis{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_MemoryErrorAlarm{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowProgrammingExceptionAlarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Chassis{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_FlowProgrammingExceptionAlarm{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortQosCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_PortQueue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_PortQosCounters{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePacketioDebugInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_NodePacketioDebugInfo{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingViability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_ForwardingViability{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthIndicator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_HealthIndicator{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutonegStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_AutonegStatus{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontPanelPortInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_FrontPanelPortInfo{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_FecStatus{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticalTransceiverInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_OpticalNetworkInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_OpticalTransceiverInfo{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_LoopbackStatus{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_NodeInfo{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdnPortId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DataRequest_Request_SdnPortId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request_Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			m.PortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request_Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request_Chassis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chassis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chassis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request_PortQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			m.PortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueId", wireType)
			}
			m.QueueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRequest_Request_OpticalNetworkInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticalNetworkInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticalNetworkInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			m.Module = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Module |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			m.NetworkInterface = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkInterface |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OperStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_OperStatus{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_AdminStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MacAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_MacAddress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSpeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortSpeed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_PortSpeed{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegotiatedPortSpeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortSpeed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_NegotiatedPortSpeed{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpRouterMac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MacAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_LacpRouterMac{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpSystemPriority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemPriority{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_LacpSystemPriority{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortCounters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_PortCounters{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryErrorAlarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alarm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_MemoryErrorAlarm{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowProgrammingExceptionAlarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alarm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_FlowProgrammingExceptionAlarm{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortQosCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortQosCounters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_PortQosCounters{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePacketioDebugInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeDebugInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_NodePacketioDebugInfo{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingViability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForwardingViability{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_ForwardingViability{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthIndicator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthIndicator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_HealthIndicator{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutonegStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutonegotiationStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_AutonegStatus{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontPanelPortInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FrontPanelPortInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_FrontPanelPortInfo{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FecStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FecStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_FecStatus{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticalTransceiverInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpticalTransceiverInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_OpticalTransceiverInfo{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_LoopbackStatus{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_NodeInfo{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdnPortId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SdnPortId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DataResponse_SdnPortId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &SetRequest_Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetRequest_Request_Port{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SetRequest_Request_Port_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetRequest_Request_Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SetRequest_Request_Node_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetRequest_Request_Chassis{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SetRequest_Request_Chassis_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticalNetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetRequest_Request_OpticalNetworkInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SetRequest_Request_OpticalNetworkInterface_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest_Request_Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			m.PortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_AdminStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MacAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_MacAddress{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSpeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortSpeed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_PortSpeed{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpRouterMac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MacAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_LacpRouterMac{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacpSystemPriority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemPriority{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_LacpSystemPriority{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthIndicator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthIndicator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_HealthIndicator{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutonegStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutonegotiationStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_AutonegStatus{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingViability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForwardingViability{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_ForwardingViability{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_Port_LoopbackStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest_Request_Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest_Request_Chassis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chassis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chassis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest_Request_OpticalNetworkInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticalNetworkInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticalNetworkInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			m.Module = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Module |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterface", wireType)
			}
			m.NetworkInterface = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkInterface |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticalTransceiverInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpticalTransceiverInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &SetRequest_Request_OpticalNetworkInterface_OpticalTransceiverInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
